<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>GenomeTools C API</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="menu">
<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="pub/">Download</a></li>
<li><a href="https://github.com/genometools/genometools">Browse source</a></li>
<li><a href="mailman/listinfo/gt-users">Mailing list</a></li>
<li><a href="http://github.com/genometools/genometools/issues/">Issue tracker</a></li>
<li><a href="documentation.html">Documentation</a></li>
  <ul class="submenu">
    <li><a href="tools.html">Tools</a></li>
    <li><a href="manuals.html">Manuals</a></li>
    <li><a id="current" href="libgenometools.html">C API</a></li>
    <li><a href="docs.html"><tt>gtscript</tt> docs</a></li>
    <li><a href="contract.html">Development Contract</a></li>
    <li><a href="contribute.html">Contribute</a></li>
  </ul>
<li><a href="annotationsketch.html"><tt>AnnotationSketch</tt></a></li>
<li><a href="/cgi-bin/gff3validator.cgi">GFF3 validator</a></li>
<li><a href="license.html">License</a></li>
</ul>
</div>
<div id="main">
<h1><i>GenomeTools</i> C API</h1>
<p>
This document describes the <i>GenomeTools</i> C API (that is, all public interfaces which are part of <tt>libgenometools</tt>).
</p>
<p>
See the <a href="#Index">index</a> for an alphabetical list of all available
interfaces.
</p>
<h2>Classes</h2>
<ul>

  <li><a href="#GtAddIntronsStream">GtAddIntronsStream</a>

  <li><a href="#GtAlphabet">GtAlphabet</a>

  <li><a href="#GtAnnoDBGFFlike">GtAnnoDBGFFlike</a>

  <li><a href="#GtAnnoDBSchema">GtAnnoDBSchema</a>

  <li><a href="#GtArray">GtArray</a>

  <li><a href="#GtArrayInStream">GtArrayInStream</a>

  <li><a href="#GtArrayOutStream">GtArrayOutStream</a>

  <li><a href="#GtBEDInStream">GtBEDInStream</a>

  <li><a href="#GtBittab">GtBittab</a>

  <li><a href="#GtBlock">GtBlock</a>

  <li><a href="#GtCDSStream">GtCDSStream</a>

  <li><a href="#GtCSAStream">GtCSAStream</a>

  <li><a href="#GtCanvas">GtCanvas</a>

  <li><a href="#GtCanvasCairoContext">GtCanvasCairoContext</a>

  <li><a href="#GtCanvasCairoFile">GtCanvasCairoFile</a>

  <li><a href="#GtCheckBoundariesVisitor">GtCheckBoundariesVisitor</a>

  <li><a href="#GtCodonIterator">GtCodonIterator</a>

  <li><a href="#GtCodonIteratorEncseq">GtCodonIteratorEncseq</a>

  <li><a href="#GtCodonIteratorSimple">GtCodonIteratorSimple</a>

  <li><a href="#GtColor">GtColor</a>

  <li><a href="#GtCommentNode">GtCommentNode</a>

  <li><a href="#GtCstrTable">GtCstrTable</a>

  <li><a href="#GtCustomTrack">GtCustomTrack</a>

  <li><a href="#GtCustomTrackGcContent">GtCustomTrackGcContent</a>

  <li><a href="#GtCustomTrackScriptWrapper">GtCustomTrackScriptWrapper</a>

  <li><a href="#GtDiagram">GtDiagram</a>

  <li><a href="#GtDiscDistri">GtDiscDistri</a>

  <li><a href="#GtDlist">GtDlist</a>

  <li><a href="#GtDlistelem">GtDlistelem</a>

  <li><a href="#GtEOFNode">GtEOFNode</a>

  <li><a href="#GtEncseq">GtEncseq</a>

  <li><a href="#GtEncseqBuilder">GtEncseqBuilder</a>

  <li><a href="#GtEncseqEncoder">GtEncseqEncoder</a>

  <li><a href="#GtEncseqLoader">GtEncseqLoader</a>

  <li><a href="#GtEncseqReader">GtEncseqReader</a>

  <li><a href="#GtError">GtError</a>

  <li><a href="#GtExtractFeatureStream">GtExtractFeatureStream</a>

  <li><a href="#GtFeatureInStream">GtFeatureInStream</a>

  <li><a href="#GtFeatureIndex">GtFeatureIndex</a>

  <li><a href="#GtFeatureIndexMemory">GtFeatureIndexMemory</a>

  <li><a href="#GtFeatureNode">GtFeatureNode</a>

  <li><a href="#GtFeatureNodeIterator">GtFeatureNodeIterator</a>

  <li><a href="#GtFeatureOutStream">GtFeatureOutStream</a>

  <li><a href="#GtFeatureStream">GtFeatureStream</a>

  <li><a href="#GtFile">GtFile</a>

  <li><a href="#GtGFF3InStream">GtGFF3InStream</a>

  <li><a href="#GtGFF3OutStream">GtGFF3OutStream</a>

  <li><a href="#GtGFF3Parser">GtGFF3Parser</a>

  <li><a href="#GtGFF3Visitor">GtGFF3Visitor</a>

  <li><a href="#GtGTFInStream">GtGTFInStream</a>

  <li><a href="#GtGTFOutStream">GtGTFOutStream</a>

  <li><a href="#GtGenomeNode">GtGenomeNode</a>

  <li><a href="#GtGraphics">GtGraphics</a>

  <li><a href="#GtGraphicsCairo">GtGraphicsCairo</a>

  <li><a href="#GtHashmap">GtHashmap</a>

  <li><a href="#GtIDToMD5Stream">GtIDToMD5Stream</a>

  <li><a href="#GtImageInfo">GtImageInfo</a>

  <li><a href="#GtInterFeatureStream">GtInterFeatureStream</a>

  <li><a href="#GtIntervalTree">GtIntervalTree</a>

  <li><a href="#GtIntervalTreeNode">GtIntervalTreeNode</a>

  <li><a href="#GtLayout">GtLayout</a>

  <li><a href="#GtLogger">GtLogger</a>

  <li><a href="#GtMD5Encoder">GtMD5Encoder</a>

  <li><a href="#GtMD5ToIDStream">GtMD5ToIDStream</a>

  <li><a href="#GtMatch">GtMatch</a>

  <li><a href="#GtMatchBlast">GtMatchBlast</a>

  <li><a href="#GtMatchIterator">GtMatchIterator</a>

  <li><a href="#GtMatchLAST">GtMatchLAST</a>

  <li><a href="#GtMatchOpen">GtMatchOpen</a>

  <li><a href="#GtMatchSW">GtMatchSW</a>

  <li><a href="#GtMatchVisitor">GtMatchVisitor</a>

  <li><a href="#GtMergeFeatureStream">GtMergeFeatureStream</a>

  <li><a href="#GtMergeStream">GtMergeStream</a>

  <li><a href="#GtMetaNode">GtMetaNode</a>

  <li><a href="#GtMutex">GtMutex</a>

  <li><a href="#GtNodeStream">GtNodeStream</a>

  <li><a href="#GtNodeStreamClass">GtNodeStreamClass</a>

  <li><a href="#GtNodeVisitor">GtNodeVisitor</a>

  <li><a href="#GtORFIterator">GtORFIterator</a>

  <li><a href="#GtOption">GtOption</a>

  <li><a href="#GtOptionParser">GtOptionParser</a>

  <li><a href="#GtOutputFileInfo">GtOutputFileInfo</a>

  <li><a href="#GtPhase">GtPhase</a>

  <li><a href="#GtQueue">GtQueue</a>

  <li><a href="#GtRDBMySQL">GtRDBMySQL</a>

  <li><a href="#GtRDBSqlite">GtRDBSqlite</a>

  <li><a href="#GtRDBVisitor">GtRDBVisitor</a>

  <li><a href="#GtRWLock">GtRWLock</a>

  <li><a href="#GtRange">GtRange</a>

  <li><a href="#GtReadmode">GtReadmode</a>

  <li><a href="#GtRecMap">GtRecMap</a>

  <li><a href="#GtRegionMapping">GtRegionMapping</a>

  <li><a href="#GtRegionNode">GtRegionNode</a>

  <li><a href="#GtScriptWrapperStream">GtScriptWrapperStream</a>

  <li><a href="#GtScriptWrapperVisitor">GtScriptWrapperVisitor</a>

  <li><a href="#GtSelectStream">GtSelectStream</a>

  <li><a href="#GtSeqIterator">GtSeqIterator</a>

  <li><a href="#GtSeqIteratorFastQ">GtSeqIteratorFastQ</a>

  <li><a href="#GtSeqIteratorSequenceBuffer">GtSeqIteratorSequenceBuffer</a>

  <li><a href="#GtSequenceNode">GtSequenceNode</a>

  <li><a href="#GtSetSourceVisitor">GtSetSourceVisitor</a>

  <li><a href="#GtSortStream">GtSortStream</a>

  <li><a href="#GtSplitter">GtSplitter</a>

  <li><a href="#GtStatStream">GtStatStream</a>

  <li><a href="#GtStr">GtStr</a>

  <li><a href="#GtStrArray">GtStrArray</a>

  <li><a href="#GtStrand">GtStrand</a>

  <li><a href="#GtStyle">GtStyle</a>

  <li><a href="#GtTagValueMap">GtTagValueMap</a>

  <li><a href="#GtTextWidthCalculator">GtTextWidthCalculator</a>

  <li><a href="#GtTextWidthCalculatorCairo">GtTextWidthCalculatorCairo</a>

  <li><a href="#GtThread">GtThread</a>

  <li><a href="#GtTimer">GtTimer</a>

  <li><a href="#GtTool">GtTool</a>

  <li><a href="#GtToolbox">GtToolbox</a>

  <li><a href="#GtTransTable">GtTransTable</a>

  <li><a href="#GtTranslator">GtTranslator</a>

  <li><a href="#GtTypeChecker">GtTypeChecker</a>

  <li><a href="#GtTypeCheckerOBO">GtTypeCheckerOBO</a>

  <li><a href="#GtUniqStream">GtUniqStream</a>

  <li><a href="#GtVisitorStream">GtVisitorStream</a>

  <li><a href="#GtXRFChecker">GtXRFChecker</a>

</ul>
<h2>Modules</h2>
<ul>

  <li><a href="#Array2dim">Array2dim</a>

  <li><a href="#Assert">Assert</a>

  <li><a href="#Bsearch">Bsearch</a>

  <li><a href="#BytePopcount">BytePopcount</a>

  <li><a href="#ByteSelect">ByteSelect</a>

  <li><a href="#Countingsort">Countingsort</a>

  <li><a href="#Cstr">Cstr</a>

  <li><a href="#Endianess">Endianess</a>

  <li><a href="#FASTA">FASTA</a>

  <li><a href="#Fileutils">Fileutils</a>

  <li><a href="#FunctionPointer">FunctionPointer</a>

  <li><a href="#Grep">Grep</a>

  <li><a href="#Init">Init</a>

  <li><a href="#Log">Log</a>

  <li><a href="#MD5Fingerprint">MD5Fingerprint</a>

  <li><a href="#MemoryAllocation">MemoryAllocation</a>

  <li><a href="#Msort">Msort</a>

  <li><a href="#Multithread">Multithread</a>

  <li><a href="#POSIX">POSIX</a>

  <li><a href="#Parseutils">Parseutils</a>

  <li><a href="#Qsort">Qsort</a>

  <li><a href="#Reverse">Reverse</a>

  <li><a href="#Strcmp">Strcmp</a>

  <li><a href="#Symbol">Symbol</a>

  <li><a href="#Threads">Threads</a>

  <li><a href="#Undef">Undef</a>

  <li><a href="#Unused">Unused</a>

  <li><a href="#Version">Version</a>

  <li><a href="#Warning">Warning</a>

  <li><a href="#XANSI">XANSI</a>

</ul>
<h2>Sole functions</h2>
<a name="gt_feature_index_gfflike_get_all_features"></a>

<code>int              gt_feature_index_gfflike_get_all_features(GtFeatureIndex *gfi,
                                                          GtArray *results,
                                                          GtError *err)</code>
<p>
Retrieves all features contained in <code>gfi</code> into <code>results</code>. Returns 0 on
   success, a negative value otherwise. The message in <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_dup_feature_stream_new"></a>

<code>GtNodeStream*  gt_dup_feature_stream_new(GtNodeStream*, const char *dest_type,
                                        const char *source_type)</code>
<p>
Duplicate internal feature nodes of type <code>source_type</code> as features with type
   <code>dest_type</code>. The duplicated features does not inherit the children.
</p>
<hr>
<a name="GtTrackSelectorFunc"></a>

<code>void  GtTrackSelectorFunc(GtBlock*, GtStr*, void*)</code>
<p>
A <code>GtTrackSelectorFunc</code> is a callback function which sets a <code>GtStr</code> to a
   string to be used as a track identifier for assignment of a <code>GtBlock</code>
   to a given track.
</p>
<hr>
<a name="GtTrackOrderingFunc"></a>

<code>int  GtTrackOrderingFunc(const char *s1, const char *s2, void *data)</code>
<p>
A function describing the order of tracks based on their track identifier
   strings <code>s1</code> and <code>s2</code>. Must return a negative value if the track with ID <code>s1</code>
   should appear before the track with ID <code>s2</code> and a positive value if <code>s1</code>
   should appear after <code>s2</code>. Returning a value of 0 will result in an undefined
   ordering of <code>s1</code> and <code>s2</code>.
</p>
<hr>
<a name="GtAddIntronsStream"></a>
<h2>Class GtAddIntronsStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtAddIntronsStream</code> inserts new
   feature nodes with type <em>intron</em> between existing feature nodes with type
   <em>exon</em>. This is a special case of the <code>GtInterFeatureStream</code>. </p>

<hr>
<a name="gt_add_introns_stream_new"></a>

<code>GtNodeStream*  gt_add_introns_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtAddIntronsStream*</code> which inserts feature nodes of type <em>intron</em>
   between feature nodes of type <em>exon</em> it retrieves from <code>in_stream</code> and
   returns them.
</p>
<hr>
<a name="GtAlphabet"></a>
<h2>Class GtAlphabet</h2>

<p> The following type is for storing alphabets.</p>

<hr>
<a name="gt_alphabet_new_dna"></a>

<code>GtAlphabet*     gt_alphabet_new_dna(void)</code>
<p>
Return a <code>GtAlphabet</code> object which represents a DNA alphabet.
</p>
<hr>
<a name="gt_alphabet_new_protein"></a>

<code>GtAlphabet*     gt_alphabet_new_protein(void)</code>
<p>
Return a <code>GtAlphabet</code> object which represents a protein alphabet.
</p>
<hr>
<a name="gt_alphabet_new_empty"></a>

<code>GtAlphabet*     gt_alphabet_new_empty(void)</code>
<p>
Return an empty <code>GtAlphabet</code> object.
</p>
<hr>
<a name="gt_alphabet_new_from_file"></a>

<code>GtAlphabet*     gt_alphabet_new_from_file(const char *filename, GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from an .al1 file specified by
   <code>filename</code> (i.e. no al1 suffix necessary).
</p>
<hr>
<a name="gt_alphabet_new_from_file_no_suffix"></a>

<code>GtAlphabet*     gt_alphabet_new_from_file_no_suffix(const char *filename,
                                                   GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from a file specified by
   <code>filename</code>.
</p>
<hr>
<a name="gt_alphabet_new_from_string"></a>

<code>GtAlphabet*     gt_alphabet_new_from_string(const char *alphadef,
                                           GtUword len, GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from a string of length <code>len</code>
   specified by <code>alphadef</code>.
</p>
<hr>
<a name="gt_alphabet_new_from_sequence"></a>

<code>GtAlphabet*     gt_alphabet_new_from_sequence(const GtStrArray *filenametab,
                                             GtError *err)</code>
<p>
Returns a new <code>GtAlphabet</code> object by scanning the sequence files in
   <code>filenametab</code> to determine whether they are DNA or protein sequences,
   and the appropriate alphabet will be used (see <code>gt_alphabet_guess()</code>).
   Returns NULL on error, see <code>err</code> for details.
</p>
<hr>
<a name="gt_alphabet_guess"></a>

<code>GtAlphabet*     gt_alphabet_guess(const char *sequence, GtUword seqlen)</code>
<p>
Try to guess which type the given <code>sequence</code> with <code>length</code> has (DNA or
   protein) and return an according <code>GtAlphabet*</code> object.
</p>
<hr>
<a name="gt_alphabet_clone"></a>

<code>GtAlphabet*     gt_alphabet_clone(const GtAlphabet *alphabet)</code>
<p>
Return a clone of <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_equals"></a>

<code>bool            gt_alphabet_equals(const GtAlphabet *a, const GtAlphabet *b)</code>
<p>
Returns TRUE if <code>a</code> and <code>b</code> are equal (i.e. have the same symbol
   mapping), FALSE otherwise.
</p>
<hr>
<a name="gt_alphabet_ref"></a>

<code>GtAlphabet*     gt_alphabet_ref(GtAlphabet *alphabet)</code>
<p>
Increase the reference count for <code>alphabet</code> and return it.
</p>
<hr>
<a name="gt_alphabet_add_mapping"></a>

<code>void            gt_alphabet_add_mapping(GtAlphabet *alphabet,
                                       const char *characters)</code>
<p>
Add the mapping of all given <code>characters</code> to the given <code>alphabet</code>. The first
   character is the result of subsequent <code>gt_alphabet_decode()</code> calls.
</p>
<hr>
<a name="gt_alphabet_add_wildcard"></a>

<code>void            gt_alphabet_add_wildcard(GtAlphabet *alphabet, char wildcard)</code>
<p>
Add <code>wildcard</code> to the <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_symbolmap"></a>

<code>const GtUchar*  gt_alphabet_symbolmap(const GtAlphabet *alphabet)</code>
<p>
Returns the array of symbols from <code>alphabet</code> such that the index of the
   character equals its encoding.
</p>
<hr>
<a name="gt_alphabet_num_of_chars"></a>

<code>unsigned int    gt_alphabet_num_of_chars(const GtAlphabet *alphabet)</code>
<p>
Returns number of characters in <code>alphabet</code> (excluding wildcards).
</p>
<hr>
<a name="gt_alphabet_size"></a>

<code>unsigned int    gt_alphabet_size(const GtAlphabet *alphabet)</code>
<p>
Returns number of characters in <code>alphabet</code> (including wildcards).
</p>
<hr>
<a name="gt_alphabet_characters"></a>

<code>const GtUchar*  gt_alphabet_characters(const GtAlphabet *alphabet)</code>
<p>
Returns an array of the characters in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_wildcard_show"></a>

<code>GtUchar         gt_alphabet_wildcard_show(const GtAlphabet *alphabet)</code>
<p>
Returns the character used in <code>alphabet</code> to represent wildcards in output.
</p>
<hr>
<a name="gt_alphabet_bits_per_symbol"></a>

<code>unsigned int    gt_alphabet_bits_per_symbol(const GtAlphabet *alphabet)</code>
<p>
Returns the required number of bits required to represent a symbol
   in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_output"></a>

<code>void            gt_alphabet_output(const GtAlphabet *alphabet, FILE *fpout)</code>
<p>
Writes a representation of <code>alphabet</code> to the file pointer <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_to_file"></a>

<code>int             gt_alphabet_to_file(const GtAlphabet *alphabet,
                                   const char *indexname,
                                   GtError *err)</code>
<p>
Writes a representation of <code>alphabet</code> to the .al1 output file as specified
   by <code>indexname</code> (i.e. without the .al1 suffix).
</p>
<hr>
<a name="gt_alphabet_to_str"></a>

<code>void            gt_alphabet_to_str(const GtAlphabet *alphabet, GtStr *dest)</code>
<p>
Writes a representation of <code>alphabet</code> to the <code>GtStr</code> as specified
   by <code>dest</code>.
</p>
<hr>
<a name="gt_alphabet_pretty_symbol"></a>

<code>GtUchar         gt_alphabet_pretty_symbol(const GtAlphabet *alphabet,
                                         unsigned int currentchar)</code>
<p>
Returns the printable character specified in <code>alphabet</code> for <code>currentchar</code>.
</p>
<hr>
<a name="gt_alphabet_echo_pretty_symbol"></a>

<code>void            gt_alphabet_echo_pretty_symbol(const GtAlphabet *alphabet,
                                              FILE *fpout,
                                              GtUchar currentchar)</code>
<p>
Prints the printable character specified in <code>alphabet</code> for <code>currentchar</code> on
   <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_is_protein"></a>

<code>bool            gt_alphabet_is_protein(const GtAlphabet *alphabet)</code>
<p>
The following method checks if the given <code>alphabet</code> is the protein
   alphabet with the aminoacids A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S,
   T, V, W, Y written in lower or upper case and returns <code>true</code>, if this is the
   case (<code>false</code> otherwise).
</p>
<hr>
<a name="gt_alphabet_is_dna"></a>

<code>bool            gt_alphabet_is_dna(const GtAlphabet *alphabet)</code>
<p>
The following method checks if the given alphabet is the DNA alphabet with
   the bases A, C, G, T written in lower or upper case and returns <code>true</code>, if
   this is the case (<code>false</code> otherwise).
</p>
<hr>
<a name="gt_alphabet_valid_input"></a>

<code>bool            gt_alphabet_valid_input(const GtAlphabet *alphabet, char c)</code>
<p>
Returns true if the character <code>c</code> is defined in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_encode"></a>

<code>GtUchar         gt_alphabet_encode(const GtAlphabet *alphabet, char c)</code>
<p>
Encode character <code>c</code> with given <code>alphabet</code>.
   Ensure that <code>c</code> is encodable with the given <code>alphabet</code>!
</p>
<hr>
<a name="gt_alphabet_decode"></a>

<code>char            gt_alphabet_decode(const GtAlphabet *alphabet, GtUchar c)</code>
<p>
Decode character <code>c</code> with given <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_encode_seq"></a>

<code>void            gt_alphabet_encode_seq(const GtAlphabet *alphabet, GtUchar *out,
                                      const char *in, GtUword length)</code>
<p>
Encode sequence <code>in</code> of given <code>length</code> with <code>alphabet</code> and store the result
   in <code>out</code>. <code>in</code> has to be encodable with the given <code>alphabet</code>!
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_fp"></a>

<code>void            gt_alphabet_decode_seq_to_fp(const GtAlphabet *alphabet,
                                            FILE *fpout,
                                            const GtUchar *src,
                                            GtUword len)</code>
<p>
Suppose the string <code>src</code> of length <code>len</code> was transformed according to the
   <code>alphabet</code>. The following method shows each character in <code>src</code> as the
   printable character specified in the transformation. The output is written
   to the given file pointer <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_cstr"></a>

<code>void            gt_alphabet_decode_seq_to_cstr(const GtAlphabet *alphabet,
                                              char *dest,
                                              const GtUchar *src,
                                              GtUword len)</code>
<p>
Analog to <code>gt_alphabet_decode_seq_to_fp()</code> but writing the output to
   <code>dest</code>.
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_str"></a>

<code>GtStr*          gt_alphabet_decode_seq_to_str(const GtAlphabet *alphabet,
                                             const GtUchar *src,
                                             GtUword len)</code>
<p>
Analog to <code>gt_alphabet_decode_seq_to_fp()</code> writing the output to
   a new <code>GtStr</code>.
</p>
<hr>
<a name="gt_alphabet_delete"></a>

<code>void            gt_alphabet_delete(GtAlphabet *alphabet)</code>
<p>
Decrease the reference count for <code>alphabet</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtAnnoDBGFFlike"></a>
<h2>Class GtAnnoDBGFFlike</h2>

<p> The <code>GtAnnoDBGFFlike</code> class implements the <code>GtAnnoDBSchema</code> interface,
   using a database schema specifically tailored to store <em>GenomeTools</em>
   annotations. </p>

<hr>
<a name="gt_anno_db_gfflike_new"></a>

<code>GtAnnoDBSchema*  gt_anno_db_gfflike_new(void)</code>
<p>
Creates a new <code>GtAnnoDBGFFlike</code> schema object.
</p>
<hr>
<a name="GtAnnoDBSchema"></a>
<h2>Class GtAnnoDBSchema</h2>

<p> The <code>GtAnnoDBSchema</code> interface for a database-backed abstract
   <code>GtFeatureIndex</code> factory. </p>

<hr>
<a name="gt_anno_db_schema_get_feature_index"></a>

<code>GtFeatureIndex*  gt_anno_db_schema_get_feature_index(GtAnnoDBSchema *schema,
                                                    GtRDB *db, GtError *err)</code>
<p>
Returns a <code>GtFeatureIndex</code> object representing <code>GtRDB</code> object <code>db</code>
   interpreted as having schema <code>schema</code>. Returns NULL if an error occurred,
   <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_anno_db_schema_delete"></a>

<code>void             gt_anno_db_schema_delete(GtAnnoDBSchema *schema)</code>
<p>
Deletes <code>schema</code> and frees all associated memory.
</p>
<hr>
<a name="GtArray"></a>
<h2>Class GtArray</h2>

<p> <code>GtArray</code> objects are generic arrays for elements of a certain size which
   grow on demand. </p>

<hr>
<a name="gt_array_new"></a>

<code>GtArray*  gt_array_new(size_t size_of_elem)</code>
<p>
Return a new <code>GtArray</code> object whose elements have the size <code>size_of_elem</code>.
</p>
<hr>
<a name="gt_array_ref"></a>

<code>GtArray*  gt_array_ref(GtArray *array)</code>
<p>
Increase the reference count for <code>array</code> and return it.
   If <code>array</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<a name="gt_array_clone"></a>

<code>GtArray*  gt_array_clone(const GtArray *array)</code>
<p>
Return a clone of <code>array</code>.
</p>
<hr>
<a name="gt_array_get"></a>

<code>void*     gt_array_get(const GtArray *array, GtUword index)</code>
<p>
Return pointer to element number <code>index</code> of <code>array</code>. <code>index</code> has to be
   smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_get_first"></a>

<code>void*     gt_array_get_first(const GtArray *array)</code>
<p>
Return pointer to first element of <code>array</code>.
</p>
<hr>
<a name="gt_array_get_last"></a>

<code>void*     gt_array_get_last(const GtArray *array)</code>
<p>
Return pointer to last element of <code>array</code>.
</p>
<hr>
<a name="gt_array_pop"></a>

<code>void*     gt_array_pop(GtArray *array)</code>
<p>
Return pointer to last element of <code>array</code> and remove it from <code>array</code>.
</p>
<hr>
<a name="gt_array_get_space"></a>

<code>void*     gt_array_get_space(const GtArray *array)</code>
<p>
Return pointer to the internal space of <code>array</code> where the elements are
   stored.
</p>
<hr>
<a name="gt_array_add"></a>

<code>#define gt_array_add(array, elem)</code>
<p>
Add element <code>elem</code> to <code>array</code>. The size of <code>elem</code> must equal the given
   element size when the <code>array</code> was created and is determined automatically
   with the <code>sizeof</code> operator.
</p>
<hr>
<a name="gt_array_add_elem"></a>

<code>void      gt_array_add_elem(GtArray *array, void *elem, size_t size_of_elem)</code>
<p>
Add element <code>elem</code> with size <code>size_of_elem</code> to <code>array</code>. <code>size_of_elem</code> must
   equal the given element size when the <code>array</code> was created. Usually, this
   method is not used directly and the macro <code>gt_array_add()</code> is used
   instead.
</p>
<hr>
<a name="gt_array_add_array"></a>

<code>void      gt_array_add_array(GtArray *dest, const GtArray *src)</code>
<p>
Add all elements of array <code>src</code> to the array <code>dest</code>. The element sizes of
   both arrays must be equal.
</p>
<hr>
<a name="gt_array_rem"></a>

<code>void      gt_array_rem(GtArray *array, GtUword index)</code>
<p>
Remove element with number <code>index</code> from <code>array</code> in O(<code>gt_array_size(array)</code>)
   time. <code>index</code> has to be smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_rem_span"></a>

<code>void      gt_array_rem_span(GtArray *array, GtUword frompos,
                                 GtUword topos)</code>
<p>
Remove elements starting with number <code>frompos</code> up to (and including) <code>topos</code>
   from <code>array</code> in O(<code>gt_array_size(array)</code>) time. <code>frompos</code> has to be smaller
   or equal than <code>topos</code> and both have to be smaller than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_reverse"></a>

<code>void      gt_array_reverse(GtArray *array)</code>
<p>
Reverse the order of the elements in <code>array</code>.
</p>
<hr>
<a name="gt_array_set_size"></a>

<code>void      gt_array_set_size(GtArray *array, GtUword size)</code>
<p>
Set the size of <code>array</code> to <code>size</code>. <code>size</code> must be smaller or equal than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_reset"></a>

<code>void      gt_array_reset(GtArray *array)</code>
<p>
Reset the <code>array</code>. That is, afterwards the array has size 0.
</p>
<hr>
<a name="gt_array_elem_size"></a>

<code>size_t    gt_array_elem_size(const GtArray *array)</code>
<p>
Return the size of the elements stored in <code>array</code>.
</p>
<hr>
<a name="gt_array_size"></a>

<code>GtUword   gt_array_size(const GtArray *array)</code>
<p>
Return the number of elements in <code>array</code>. If <code>array</code> equals <code>NULL</code>, 0 is
   returned.
</p>
<hr>
<a name="gt_array_sort"></a>

<code>void      gt_array_sort(GtArray *array, GtCompare compar)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_stable"></a>

<code>void      gt_array_sort_stable(GtArray *array, GtCompare compar)</code>
<p>
Sort <code>array</code> in a stable way with the given compare function <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_with_data"></a>

<code>void      gt_array_sort_with_data(GtArray *array, GtCompareWithData compar,
                                 void *data)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>. Passes a pointer with
   userdata <code>data</code> to <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_stable_with_data"></a>

<code>void      gt_array_sort_stable_with_data(GtArray *array,
                                        GtCompareWithData compar, void *data)</code>
<p>
Sort <code>array</code> in a stable way with the given compare function <code>compar</code>. Passes
   a pointer with userdata <code>data</code> to <code>compar</code>.
</p>
<hr>
<a name="gt_array_cmp"></a>

<code>int       gt_array_cmp(const GtArray *array_a, const GtArray *array_b)</code>
<p>
Compare the content of <code>array_a</code> with the content of <code>array_b</code>.
   <code>array_a</code> and <code>array_b</code> must have the same <code>gt_array_size()</code> and
   <code>gt_array_elem_size()</code>.
</p>
<hr>
<a name="gt_array_delete"></a>

<code>void      gt_array_delete(GtArray *array)</code>
<p>
Decrease the reference count for <code>array</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GtArrayInStream"></a>
<h2>Class GtArrayInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. <code>GtArrayOutStream</code> takes
   an array of <code>GtGenomeNodes</code> and delivers them when used as an input stream.
   This stream can be used to feed nodes from outside into a stream flow. </p>

<hr>
<a name="gt_array_in_stream_new"></a>

<code>GtNodeStream*  gt_array_in_stream_new(GtArray *nodes, GtUword *progress,
                                     GtError *err)</code>
<p>
Creates a new <code>GtArrayInStream</code>, delivering nodes from <code>nodes</code>. Note that
   the array must contain pointers to <code>GtGenomeNode</code>s! For every node passed,
   the value pointed to by <code>progress</code> is incremented by 1.
</p>
<hr>
<a name="GtArrayOutStream"></a>
<h2>Class GtArrayOutStream</h2>

<p> The <code>GtArrayOutStream</code> class implements the <code>GtNodeStream</code> interface.
   <code>GtArrayOutStream</code> takes nodes from an input stream and adds them to a
   <code>GtArray</code>. This stream can be used to obtain nodes for processing outside
   of the usual stream flow. </p>

<hr>
<a name="gt_array_out_stream_new"></a>

<code>GtNodeStream*  gt_array_out_stream_new(GtNodeStream *in_stream,
                                      GtArray *nodes, GtError *err)</code>
<p>
Creates a new <code>GtArrayInStream</code>, storing new references to <code>GtFeatureNode</code>s
   from <code>in_stream</code> in <code>nodes</code>. Note that the array must be set up to contain
   pointers to <code>GtGenomeNode</code>s!
</p>
<hr>
<a name="gt_array_out_stream_all_new"></a>

<code>GtNodeStream*  gt_array_out_stream_all_new(GtNodeStream *in_stream,
                                          GtArray *nodes, GtError *err)</code>
<p>
Like <code>gt_array_out_stream_new()</code>, but not restricted to feature nodes.
</p>
<hr>
<a name="GtBEDInStream"></a>
<h2>Class GtBEDInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtBEDInStream</code> allows one to
   parse a BED file and return it as a stream of <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_bed_in_stream_new"></a>

<code>GtNodeStream*  gt_bed_in_stream_new(const char *filename)</code>
<p>
Return a <code>GtBEDInStream</code> object which subsequently reads the BED file with
   the given <code>filename</code>. If <code>filename</code> equals <code>NULL</code>, the BED data is read from
   <code>stdin</code>.
</p>
<hr>
<a name="gt_bed_in_stream_set_feature_type"></a>

<code>void           gt_bed_in_stream_set_feature_type(GtBEDInStream *bed_in_stream,
                                                const char *type)</code>
<p>
Create BED features parsed by <code>bed_in_stream</code> with given <code>type</code> (instead of
   the default "BED_feature").
</p>
<hr>
<a name="gt_bed_in_stream_set_thick_feature_type"></a>

<code>void           gt_bed_in_stream_set_thick_feature_type(GtBEDInStream
                                                      *bed_in_stream,
                                                      const char *type)</code>
<p>
Create thick BED features parsed by <code>bed_in_stream</code> with given <code>type</code>
   (instead of the default "BED_thick_feature").
</p>
<hr>
<a name="gt_bed_in_stream_set_block_type"></a>

<code>void           gt_bed_in_stream_set_block_type(GtBEDInStream *bed_in_stream,
                                              const char *type)</code>
<p>
Create BED blocks parsed by <code>bed_in_stream</code> with given <code>type</code> (instead of
   the default "BED_block").
</p>
<hr>
<a name="GtBittab"></a>
<h2>Class GtBittab</h2>

<p> Implements arbitrary-length bit arrays and various operations on them. </p>

<hr>
<a name="gt_bittab_new"></a>

<code>GtBittab*      gt_bittab_new(GtUword num_of_bits)</code>
<p>
Return a new <code>GtBittab</code> of length <code>num_of_bits</code>, initialised to 0.
   <code>num_of_bits</code> has to be > 0
</p>
<hr>
<a name="gt_bittab_set_bit"></a>

<code>void           gt_bittab_set_bit(GtBittab *bittab, GtUword i)</code>
<p>
Set bit <code>i</code> in <code>bittab</code> to 1.
</p>
<hr>
<a name="gt_bittab_unset_bit"></a>

<code>void           gt_bittab_unset_bit(GtBittab *bittab, GtUword i)</code>
<p>
Set bit <code>i</code> in <code>bittab</code> to 0.
</p>
<hr>
<a name="gt_bittab_complement"></a>

<code>void           gt_bittab_complement(GtBittab *bittab_a,
                                   const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be the complement of <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_equal"></a>

<code>void           gt_bittab_equal(GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be equal to <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_and"></a>

<code>void           gt_bittab_and(GtBittab *bittab_a, const GtBittab *bittab_b,
                            const GtBittab *bittab_c)</code>
<p>
Set <code>bittab_a</code> to be the bitwise AND of <code>bittab_b</code> and <code>bittab_c</code>.
</p>
<hr>
<a name="gt_bittab_or"></a>

<code>void           gt_bittab_or(GtBittab *bittab_a, const GtBittab *bittab_b,
                           const GtBittab *bittab_c)</code>
<p>
Set <code>bittab_a</code> to be the bitwise OR of <code>bittab_b</code> and <code>bittab_c</code>.
</p>
<hr>
<a name="gt_bittab_nand"></a>

<code>void           gt_bittab_nand(GtBittab *bittab_a, const GtBittab *bittab_b,
                             const GtBittab *bittab_c)</code>
<p>
Set <code>bittab_a</code> to be <code>bittab_b</code> NAND <code>bittab_c</code>.
</p>
<hr>
<a name="gt_bittab_and_equal"></a>

<code>void           gt_bittab_and_equal(GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be the bitwise AND of <code>bittab_a</code> and <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_or_equal"></a>

<code>void           gt_bittab_or_equal(GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be the bitwise OR of <code>bittab_a</code> and <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_shift_left_equal"></a>

<code>void           gt_bittab_shift_left_equal(GtBittab *bittab)</code>
<p>
Shift <code>bittab</code> by one position to the left.
</p>
<hr>
<a name="gt_bittab_shift_right_equal"></a>

<code>void           gt_bittab_shift_right_equal(GtBittab *bittab)</code>
<p>
Shift <code>bittab</code> by one position to the right.
</p>
<hr>
<a name="gt_bittab_unset"></a>

<code>void           gt_bittab_unset(GtBittab *bittab)</code>
<p>
Set all bits in <code>bittab</code> to 0.
</p>
<hr>
<a name="gt_bittab_show"></a>

<code>void           gt_bittab_show(const GtBittab *bittab, FILE *fp)</code>
<p>
Output a representation of <code>bittab</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_bittab_get_all_bitnums"></a>

<code>void           gt_bittab_get_all_bitnums(const GtBittab *bittab, GtArray *array)</code>
<p>
Fill <code>array</code> with the indices of all set bits in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_bit_is_set"></a>

<code>bool           gt_bittab_bit_is_set(const GtBittab *bittab, GtUword i)</code>
<p>
Return <code>true</code> if bit <code>i</code> is set in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_cmp"></a>

<code>bool           gt_bittab_cmp(const GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Return <code>true</code> if <code>bittab_a</code> and <code>bittab_b</code> are identical.
</p>
<hr>
<a name="gt_bittab_get_first_bitnum"></a>

<code>GtUword  gt_bittab_get_first_bitnum(const GtBittab *bittab)</code>
<p>
Return the index of the first set bit in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_get_last_bitnum"></a>

<code>GtUword  gt_bittab_get_last_bitnum(const GtBittab *bittab)</code>
<p>
Return the index of the last set bit in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_get_next_bitnum"></a>

<code>GtUword  gt_bittab_get_next_bitnum(const GtBittab *bittab,
                                        GtUword i)</code>
<p>
Return the index of the next set bit in <code>bittab</code> with an index greater
   than <code>i</code>.
</p>
<hr>
<a name="gt_bittab_count_set_bits"></a>

<code>GtUword  gt_bittab_count_set_bits(const GtBittab *bittab)</code>
<p>
Return the number of set bits in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_size"></a>

<code>GtUword  gt_bittab_size(GtBittab *bittab)</code>
<p>
Return the total number of bits of <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_delete"></a>

<code>void           gt_bittab_delete(GtBittab *bittab)</code>
<p>
Delete <code>bittab</code>.
</p>
<hr>
<a name="GtBlock"></a>
<h2>Class GtBlock</h2>

<p> The <code>GtBlock</code> class represents a portion of screen space which relates to
   a specific ``top-level'' feature (and maybe its collapsed child features).
   It is the smallest layoutable unit in AnnotationSketch and has a caption
   (which may be displayed above the block rendering). </p>

<hr>
<a name="gt_block_new"></a>

<code>GtBlock*               gt_block_new(void)</code>
<p>
Creates a new <code>GtBlock</code> object.
</p>
<hr>
<a name="gt_block_ref"></a>

<code>GtBlock*               gt_block_ref(GtBlock*)</code>
<p>
Increases the reference count.
</p>
<hr>
<a name="gt_block_new_from_node"></a>

<code>GtBlock*               gt_block_new_from_node(GtFeatureNode *node)</code>
<p>
Create a new GtBlock object, setting block parameters (such as strand,
   range) from a given <code>node</code> template.
</p>
<hr>
<a name="gt_block_get_range"></a>

<code>GtRange                gt_block_get_range(const GtBlock*)</code>
<p>
Returns the base range of the <code>GtBlock</code>'s top level element.
</p>
<hr>
<a name="gt_block_get_range_ptr"></a>

<code>GtRange*               gt_block_get_range_ptr(const GtBlock *block)</code>
<p>
Returns a pointer to the base range of the <code>GtBlock</code>'s top level element.
</p>
<hr>
<a name="gt_block_has_only_one_fullsize_element"></a>

<code>bool                   gt_block_has_only_one_fullsize_element(const GtBlock*)</code>
<p>
Checks whether a <code>GtBlock</code> is occupied completely by a single element.
</p>
<hr>
<a name="gt_block_merge"></a>

<code>void                   gt_block_merge(GtBlock*, GtBlock*)</code>
<p>
Merges the contents of two <code>GtBlock</code>s into the first one.
</p>
<hr>
<a name="gt_block_clone"></a>

<code>GtBlock*               gt_block_clone(GtBlock*)</code>
<p>
Returns an independent copy of a <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_set_caption_visibility"></a>

<code>void                   gt_block_set_caption_visibility(GtBlock*, bool)</code>
<p>
Set whether a block caption should be displayed or not.
</p>
<hr>
<a name="gt_block_caption_is_visible"></a>

<code>bool                   gt_block_caption_is_visible(const GtBlock*)</code>
<p>
Returns whether a block caption should be displayed or not.
</p>
<hr>
<a name="gt_block_set_caption"></a>

<code>void                   gt_block_set_caption(GtBlock*, GtStr *caption)</code>
<p>
Sets the <code>GtBlock</code>'s caption to <code>caption</code>.
</p>
<hr>
<a name="gt_block_get_caption"></a>

<code>GtStr*                 gt_block_get_caption(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s caption.
</p>
<hr>
<a name="gt_block_set_strand"></a>

<code>void                   gt_block_set_strand(GtBlock*, GtStrand strand)</code>
<p>
Sets the <code>GtBlock</code>'s strand to <code>strand</code>.
</p>
<hr>
<a name="gt_block_get_strand"></a>

<code>GtStrand               gt_block_get_strand(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s strand.
</p>
<hr>
<a name="gt_block_get_top_level_feature"></a>

<code>GtFeatureNode*         gt_block_get_top_level_feature(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s top level feature as a <code>GtFeatureNode</code> object.
</p>
<hr>
<a name="gt_block_get_size"></a>

<code>GtUword          gt_block_get_size(const GtBlock*)</code>
<p>
Returns the number of elements in the <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_get_type"></a>

<code>const char*            gt_block_get_type(const GtBlock*)</code>
<p>
Returns the feature type of the <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_delete"></a>

<code>void                   gt_block_delete(GtBlock*)</code>
<p>
Deletes a <code>GtBlock</code>.
</p>
<hr>
<a name="GtCDSStream"></a>
<h2>Class GtCDSStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtCDSStream</code> determines the
   coding sequence (CDS) for sequences determined by feature nodes of type
   <em>exon</em> and adds them as feature nodes of type <em>CDS</em>. </p>

<hr>
<a name="gt_cds_stream_new"></a>

<code>GtNodeStream*  gt_cds_stream_new(GtNodeStream *in_stream,
                                GtRegionMapping *region_mapping,
                                unsigned int minorflen, const char *source,
                                bool start_codon, bool final_stop_codon,
                                bool generic_star_codons)</code>
<p>
Create a <code>GtCDSStream*</code> which determines the coding sequence (CDS) for
   sequences determined by feature nodes of type <em>exon</em> it retrieves from
   <code>in_stream</code>, adds them as feature nodes of type <em>CDS</em> and returns all
   nodes. <code>region_mapping</code> is used to map the sequence IDs of the feature nodes
   to the regions of the actual sequences. <code>minorflen</code> is the minimum length an
   ORF must have in order to be added. The CDS features are created with the
   given <code>source</code>. If <code>start_codon</code> equals <code>true</code> an ORF must begin with a start
   codon, otherwise it can start at any position. If <code>final_stop_codon</code> equals
   <code>true</code> the final ORF must end with a stop codon. If <code>generic_start_codons</code>
   equals <code>true</code>, the start codons of the standard translation scheme are used
   as start codons (otherwise the amino acid 'M' is regarded as a start codon).
</p>
<hr>
<a name="GtCSAStream"></a>
<h2>Class GtCSAStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtCSAStream</code> takes spliced
   alignments and transforms them into consensus spliced alignments. </p>

<hr>
<a name="gt_csa_stream_new"></a>

<code>GtNodeStream*  gt_csa_stream_new(GtNodeStream *in_stream,
                                GtUword join_length)</code>
<p>
Create a <code>GtCSAStream*</code> which takes spliced alignments from its <code>in_stream</code>
   (which are at most <code>join_length</code> many bases apart), transforms them into
   consensus spliced alignments, and returns them.
</p>
<hr>
<a name="GtCanvas"></a>
<h2>Class GtCanvas</h2>

<p> The <code>GtCanvas</code> class is an abstraction of a stateful drawing surface.
   Constructors must be implemented in subclasses as different arguments are
   required for drawing to specific graphics back-ends. </p>

<hr>
<a name="gt_canvas_get_height"></a>

<code>GtUword  gt_canvas_get_height(GtCanvas *canvas)</code>
<p>
Returns the height of the given <code>canvas</code>.
</p>
<hr>
<a name="gt_canvas_delete"></a>

<code>void     gt_canvas_delete(GtCanvas *canvas)</code>
<p>
Delete the given <code>canvas</code>.
</p>
<hr>
<a name="GtCanvasCairoContext"></a>
<h2>Class GtCanvasCairoContext</h2>

<p> Implements the <code>GtCanvas</code> interface using a Cairo context (<code>cairo_t</code>)
   as input. This Canvas uses the <code>GtGraphicsCairo</code> class.</p><p>   Drawing to a <code>cairo_t</code> allows the use of the  <em>AnnotationSketch</em> engine
   in any Cairo-based graphical application. </p>

<hr>
<a name="gt_canvas_cairo_context_new"></a>

<code>GtCanvas*  gt_canvas_cairo_context_new(GtStyle *style, cairo_t *context,
                                      double offsetpos,
                                      GtUword width,
                                      GtUword height,
                                      GtImageInfo *image_info,
                                      GtError *err)</code>
<p>
Create a new <code>GtCanvas</code> object tied to the cairo_t <code>context</code>, <code>width</code> and
   <code>height</code> using the given <code>style</code>. The optional <code>image_info</code> is
   filled when the created Canvas object is used to render a <code>GtDiagram</code> object.
   <code>offsetpos</code> determines where to start drawing on the surface.
</p>
<hr>
<a name="GtCanvasCairoFile"></a>
<h2>Class GtCanvasCairoFile</h2>

<p> Implements the <code>GtCanvas</code> interface.
   This Canvas uses the <code>GtGraphicsCairo</code> class.  </p>

<hr>
<a name="gt_canvas_cairo_file_new"></a>

<code>GtCanvas*  gt_canvas_cairo_file_new(GtStyle *style,
                                   GtGraphicsOutType output_type,
                                   GtUword width,
                                   GtUword height,
                                   GtImageInfo *image_info,
                                   GtError *err)</code>
<p>
Create a new <code>GtCanvasCairoFile</code> object with given <code>output_type</code> and
   <code>width</code> using the configuration given in <code>style</code>. The optional <code>image_info</code>
   is filled when the created object is used to render a <code>GtDiagram</code> object.
   Possible <code>GtGraphicsOutType</code> values are <code>GRAPHICS_PNG</code>, <code>GRAPHICS_PS</code>,
   <code>GRAPHICS_PDF</code> and <code>GRAPHICS_SVG</code>. Dependent on the local Cairo installation,
   not all of them may be available.
</p>
<hr>
<a name="gt_canvas_cairo_file_to_file"></a>

<code>int      gt_canvas_cairo_file_to_file(GtCanvasCairoFile *canvas,
                                     const char *filename, GtError *err)</code>
<p>
Write rendered <code>canvas</code> to the file with name <code>filename</code>. If this
   method returns a value other than 0, check <code>err</code> for an error message.
</p>
<hr>
<a name="gt_canvas_cairo_file_to_stream"></a>

<code>int      gt_canvas_cairo_file_to_stream(GtCanvasCairoFile *canvas,
                                       GtStr *stream)</code>
<p>
Append rendered <code>canvas</code> image data to given <code>stream</code>.
</p>
<hr>
<a name="GtCheckBoundariesVisitor"></a>
<h2>Class GtCheckBoundariesVisitor</h2>

<p> Implements the <code>GtNodeVisitor</code> interface. </p>

<hr>
<a name="gt_check_boundaries_visitor_new"></a>

<code>GtNodeVisitor*  gt_check_boundaries_visitor_new(void)</code>
<p>
Creates a new <code>GtCheckBoundariesVisitor</code> object.
</p>
<hr>
<a name="GtCodonIterator"></a>
<h2>Class GtCodonIterator</h2>

<p> The <code>GtCodonIterator</code> interface. </p>

<hr>
<a name="gt_codon_iterator_current_position"></a>

<code>GtUword           gt_codon_iterator_current_position(GtCodonIterator
                                                          *codon_iterator)</code>
<p>
Return the current reading offset of <code>codin_iterator</code>, starting from the
   position in the sequence given at iterator instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_length"></a>

<code>GtUword           gt_codon_iterator_length(GtCodonIterator
                                                *codon_iterator)</code>
<p>
Return the length of the substring to scan, given at instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_rewind"></a>

<code>void                    gt_codon_iterator_rewind(GtCodonIterator
                                                *codon_iterator)</code>
<p>
Rewind the <code>codon_iterator</code> to point again to the position in the sequence
   given at iterator instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_next"></a>

<code>GtCodonIteratorStatus   gt_codon_iterator_next(GtCodonIterator *codon_iterator,
                                              char *n1, char *n2, char *n3,
                                              unsigned int *frame,
                                              GtError *err)</code>
<p>
Sets the values of <code>n1</code>, <code>n2</code> and <code>n3</code> to the codon beginning at the current
   reading position of <code>codon_iterator</code> and then advances the reading position
   by one. The current reading frame shift (0, 1 or 2) is for the current codon
   is written to the position pointed to by <code>frame</code>.
   This function returns one of three status codes:
   GT_CODON_ITERATOR_OK    : a codon was read successfully,
   GT_CODON_ITERATOR_END   : no codon was read because the end of the scan
                             region has been reached,
   GT_CODON_ITERATOR_ERROR : no codon was read because an error occurred during
                             sequence access. See <code>err</code> for details.
</p>
<hr>
<a name="gt_codon_iterator_delete"></a>

<code>void                    gt_codon_iterator_delete(GtCodonIterator
                                                *codon_iterator)</code>
<p>
Delete <code>codon_iterator</code>.
</p>
<hr>
<a name="GtCodonIteratorEncseq"></a>
<h2>Class GtCodonIteratorEncseq</h2>
<a name="gt_codon_iterator_encseq_new"></a>

<code>GtCodonIterator*             gt_codon_iterator_encseq_new(GtEncseq *encseq,
                                                         GtUword startpos,
                                                         GtUword length,
                                                         GtError *err)</code>
<p>
Creates a new <code>GtCodonIterator</code> traversing <code>encseq</code> over a length of <code>len</code>
   starting at concatenated position <code>startpos</code>. If an error occurs, NULL is
   returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_codon_iterator_encseq_new_with_readmode"></a>

<code>GtCodonIterator*             gt_codon_iterator_encseq_new_with_readmode(
                                                        GtEncseq *encseq,
                                                        GtUword startpos,
                                                        GtUword length,
                                                        GtReadmode readmode,
                                                        GtError *err)</code>
<p>
Creates a new <code>GtCodonIterator</code> traversing <code>encseq</code> over a length of <code>len</code>
   starting at concatenated position <code>startpos</code>. <code>readmode</code> specified reading
   direction. If an error occurs, NULL is returned and <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="GtCodonIteratorSimple"></a>
<h2>Class GtCodonIteratorSimple</h2>
<a name="gt_codon_iterator_simple_new"></a>

<code>GtCodonIterator*             gt_codon_iterator_simple_new(const char *seq,
                                                         GtUword len,
                                                         GtError *err)</code>
<p>
Creates a new <code>GtCodonIterator</code> traversing <code>seq</code> over a length of <code>len</code>.
   If an error occurs, NULL is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="GtColor"></a>
<h2>Class GtColor</h2>

<p> The <code>GtColor</code> class holds a RGB color definition. </p>

<hr>
<a name="gt_color_new"></a>

<code>GtColor*  gt_color_new(double red, double green, double blue, double alpha)</code>
<p>
Create a new <code>GtColor</code> object with the color given by the <code>red</code>, <code>green</code>,
   and <code>blue</code> arguments. The value for each color channel must be between 0
   and 1.
</p>
<hr>
<a name="gt_color_set"></a>

<code>void       gt_color_set(GtColor *color, double red, double green, double blue,
                       double alpha)</code>
<p>
Change the color of the <code>color</code> object to the color given by the <code>red</code>,
   <code>green</code>, and <code>blue</code> arguments. The value for each color channel must be
   between 0 and 1.
</p>
<hr>
<a name="gt_color_equals"></a>

<code>bool       gt_color_equals(const GtColor *c1, const GtColor *c2)</code>
<p>
Returns <code>true</code> if the colors <code>c1</code> and <code>c2</code> are equal.
</p>
<hr>
<a name="gt_color_delete"></a>

<code>void       gt_color_delete(GtColor *color)</code>
<p>
Delete the <code>color</code> object.
</p>
<hr>
<a name="GtCommentNode"></a>
<h2>Class GtCommentNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Comment nodes correspond to comment
   lines in GFF3 files (i.e., lines which start with a single ``<code>#</code>''). </p>

<hr>
<a name="gt_comment_node_new"></a>

<code>GtGenomeNode*             gt_comment_node_new(const char *comment)</code>
<p>
Return a new <code>GtCommentNode</code> object representing a <code>comment</code>. Please note
   that the single leading ``<code>#</code>'' which denotes comment lines in GFF3 files
   should not be part of <code>comment</code>.
</p>
<hr>
<a name="gt_comment_node_get_comment"></a>

<code>const char*               gt_comment_node_get_comment(const GtCommentNode
                                                     *comment_node)</code>
<p>
Return the comment stored in <code>comment_node</code>.
</p>
<hr>
<a name="gt_comment_node_try_cast"></a>

<code>GtCommentNode*            gt_comment_node_try_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a comment node. If so, a pointer to the
   meta node is returned. If not, NULL is returned. Note that in most cases,
   one should implement a GtNodeVisitor to handle processing of different
   GtGenomeNode types.
</p>
<hr>
<a name="gt_comment_node_cast"></a>

<code>GtCommentNode*            gt_comment_node_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a comment node. If so, a pointer to the
   meta node is returned. If not, an assertion fails.
</p>
<hr>
<a name="GtCstrTable"></a>
<h2>Class GtCstrTable</h2>

<p> Implements a table of C strings. </p>

<hr>
<a name="gt_cstr_table_new"></a>

<code>GtCstrTable*   gt_cstr_table_new(void)</code>
<p>
Return a new <code>GtCstrTable</code> object.
</p>
<hr>
<a name="gt_cstr_table_add"></a>

<code>void           gt_cstr_table_add(GtCstrTable *table, const char *cstr)</code>
<p>
Add <code>cstr</code> to <code>table</code>. <code>table</code> must not already contain <code>cstr</code>!
</p>
<hr>
<a name="gt_cstr_table_get"></a>

<code>const char*    gt_cstr_table_get(const GtCstrTable *table, const char *cstr)</code>
<p>
If a C string equal to <code>cstr</code> is contained in <code>table</code>, it is returned.
   Otherwise <code>NULL</code> is returned.
</p>
<hr>
<a name="gt_cstr_table_get_all"></a>

<code>GtStrArray*    gt_cstr_table_get_all(const GtCstrTable *table)</code>
<p>
Return a <code>GtStrArray*</code> which contains all <code>cstr</code>s added to <code>table</code> in
   alphabetical order. The caller is responsible to free it!
</p>
<hr>
<a name="gt_cstr_table_remove"></a>

<code>void           gt_cstr_table_remove(GtCstrTable *table, const char *cstr)</code>
<p>
Remove <code>cstr</code> from <code>table</code>.
</p>
<hr>
<a name="gt_cstr_table_reset"></a>

<code>void           gt_cstr_table_reset(GtCstrTable *table)</code>
<p>
Reset <code>table</code> (that is, remove all contained C strings).
</p>
<hr>
<a name="gt_cstr_table_delete"></a>

<code>void           gt_cstr_table_delete(GtCstrTable *table)</code>
<p>
Delete C string <code>table</code>.
</p>
<hr>
<a name="GtCustomTrack"></a>
<h2>Class GtCustomTrack</h2>

<p> The <code>GtCustomTrack</code> interface allows the <code>GtCanvas</code> to call user-defined
   drawing functions on a <code>GtGraphics</code> object. Please refer to the specific
   implementations' documentation for more information on a particular
   custom track. </p>

<hr>
<a name="gt_custom_track_ref"></a>

<code>GtCustomTrack*  gt_custom_track_ref(GtCustomTrack *ctrack)</code>
<p>
Increase the reference count for <code>ctrack</code>.
</p>
<hr>
<a name="gt_custom_track_delete"></a>

<code>void            gt_custom_track_delete(GtCustomTrack *ctrack)</code>
<p>
Delete the given <code>ctrack</code>.
</p>
<hr>
<a name="GtCustomTrackGcContent"></a>
<h2>Class GtCustomTrackGcContent</h2>

<p> Implements the <code>GtCustomTrack</code> interface. This custom track draws a plot of
   the GC content of a given sequence in the displayed range. As a window
   size for GC content calculation, <code>windowsize</code> is used. </p>

<hr>
<a name="gt_custom_track_gc_content_new"></a>

<code>GtCustomTrack*  gt_custom_track_gc_content_new(const char *seq,
                                              GtUword seqlen,
                                              GtUword windowsize,
                                              GtUword height,
                                              double avg,
                                              bool show_scale)</code>
<p>
Creates a new <code>GtCustomTrackGcContent</code> for sequence <code>seq</code> with length
   <code>seqlen</code> of height <code>height</code> with windowsize <code>windowsize</code>.
   A horizontal line is drawn for the percentage value <code>avg</code>,
   with <code>avg</code> between 0 and 1. If <code>show_scale</code> is set to true, then a vertical
   scale rule is drawn at the left end of the curve.
</p>
<hr>
<a name="GtCustomTrackScriptWrapper"></a>
<h2>Class GtCustomTrackScriptWrapper</h2>

<p> Implements the <code>GtCustomTrack</code> interface. This custom track is
   only used to store pointers to external callbacks, e.g. written in a
   scripting language. This class does not store any state, relying on the
   developer of the external custom track class to do so.  </p>

<hr>
<a name="gt_custom_track_script_wrapper_new"></a>

<code>GtCustomTrack*  gt_custom_track_script_wrapper_new(GtCtScriptRenderFunc
                                                             render_func,
                                                  GtCtScriptGetHeightFunc
                                                             get_height_func,
                                                  GtCtScriptGetTitleFunc
                                                             get_title_func,
                                                  GtCtScriptFreeFunc
                                                             free_func)</code>
<p>
Creates a new <code>GtCustomTrackScriptWrapper</code> object.
</p>
<hr>
<a name="GtDiagram"></a>
<h2>Class GtDiagram</h2>

<p> The <code>GtDiagram</code> class acts as a representation of a sequence annotation
   diagram independent of any output format. Besides annotation features as
   annotation graphs, it can contain one or more custom tracks. A individual
   graphical representation of the <code>GtDiagram</code> contents is created by creating a
   <code>GtLayout</code> object using the <code>GtDiagram</code> and then calling
   <code>gt_layout_sketch()</code> with an appropriate <code>GtCanvas</code> object. </p>

<hr>
<a name="gt_diagram_new"></a>

<code>GtDiagram*  gt_diagram_new(GtFeatureIndex *feature_index, const char *seqid,
                          const GtRange *range, GtStyle *style, GtError*)</code>
<p>
Create a new <code>GtDiagram</code> object representing the feature nodes in
   <code>feature_index</code> in region <code>seqid</code> overlapping with <code>range</code>. The <code>GtStyle</code>
   object <code>style</code> will be used to determine collapsing options during the
   layout process.
</p>
<hr>
<a name="gt_diagram_new_from_array"></a>

<code>GtDiagram*  gt_diagram_new_from_array(GtArray *features, const GtRange *range,
                                     GtStyle *style)</code>
<p>
Create a new <code>GtDiagram</code> object representing the feature nodes in
   <code>features</code>. The features must overlap with <code>range</code>. The <code>GtStyle</code>
   object <code>style</code> will be used to determine collapsing options during the
   layout process.
</p>
<hr>
<a name="gt_diagram_get_range"></a>

<code>GtRange     gt_diagram_get_range(const GtDiagram *diagram)</code>
<p>
Returns the sequence position range represented by the <code>diagram</code>.
</p>
<hr>
<a name="gt_diagram_set_track_selector_func"></a>

<code>void        gt_diagram_set_track_selector_func(GtDiagram*, GtTrackSelectorFunc,
                                              void*)</code>
<p>
Assigns a GtTrackSelectorFunc to use to assign blocks to tracks.
   If none is set, or set to NULL, then track types are used as track keys
   (default behavior).
</p>
<hr>
<a name="gt_diagram_reset_track_selector_func"></a>

<code>void        gt_diagram_reset_track_selector_func(GtDiagram *diagram)</code>
<p>
Resets the track selection behavior of this <code>GtDiagram</code> back to the
   default.
</p>
<hr>
<a name="gt_diagram_add_custom_track"></a>

<code>void        gt_diagram_add_custom_track(GtDiagram*, GtCustomTrack*)</code>
<p>
Registers a new custom track in the diagram.
</p>
<hr>
<a name="gt_diagram_delete"></a>

<code>void        gt_diagram_delete(GtDiagram*)</code>
<p>
Delete the <code>diagram</code> and all its components.
</p>
<hr>
<a name="GtDiscDistri"></a>
<h2>Class GtDiscDistri</h2>

<p> The <code>GtDiscDistri</code> class represents a discrete distribution of integer
   values. </p>

<hr>
<a name="GtDiscDistriIterFunc"></a>

<code>void  GtDiscDistriIterFunc(GtUword key,
                                     GtUint64 value,
                                     void *data)</code>
<p>
Callback function called during iteration over each item of the
   distribution, where <code>key</code> is the counted value and <code>value</code> is the count.
</p>
<hr>
<a name="gt_disc_distri_new"></a>

<code>GtDiscDistri*  gt_disc_distri_new(void)</code>
<p>
Creates a new, empty <code>GtDiscDistri</code>.
</p>
<hr>
<a name="gt_disc_distri_add"></a>

<code>void           gt_disc_distri_add(GtDiscDistri *d, GtUword key)</code>
<p>
Adds one count of <code>key</code> to <code>d</code>.
</p>
<hr>
<a name="gt_disc_distri_add_multi"></a>

<code>void           gt_disc_distri_add_multi(GtDiscDistri *d, GtUword key,
                                       GtUint64 occurrences)</code>
<p>
Adds <code>occurrences</code> counts of <code>key</code> to <code>d</code>.
</p>
<hr>
<a name="gt_disc_distri_get"></a>

<code>GtUint64       gt_disc_distri_get(const GtDiscDistri *d, GtUword key)</code>
<p>
Return the current count of <code>key</code> as stored in <code>d</code>.
</p>
<hr>
<a name="gt_disc_distri_show"></a>

<code>void           gt_disc_distri_show(const GtDiscDistri *d, GtFile *outfp)</code>
<p>
Prints the current state of <code>d</code> to <code>outfile</code>. If <code>outfp</code> is NULL,
   stdout will be used for output.
</p>
<hr>
<a name="gt_disc_distri_foreach"></a>

<code>void           gt_disc_distri_foreach(const GtDiscDistri *d,
                                     GtDiscDistriIterFunc func,
                                     void *data)</code>
<p>
Iterate over all non-empty entries in <code>d</code>, calling <code>func</code> for each one,
   from the smallest to the largest key. The <code>data</code> pointer can be used to pass
   arbitrary data to <code>func</code>.
</p>
<hr>
<a name="gt_disc_distri_foreach_in_reverse_order"></a>

<code>void           gt_disc_distri_foreach_in_reverse_order(const GtDiscDistri *d,
                                                      GtDiscDistriIterFunc func,
                                                      void *data)</code>
<p>
Same as foreach, but from the longest to the smallest key.
</p>
<hr>
<a name="GtDlist"></a>
<h2>Class GtDlist</h2>

<p> A double-linked list which is sorted according to a <code>GtCompare</code> compare
   function (<code>qsort(3)</code>-like, only if one was supplied to the constructor). </p>

<hr>
<a name="gt_dlist_new"></a>

<code>GtDlist*      gt_dlist_new(GtCompare compar)</code>
<p>
Return a new <code>GtDlist</code> object sorted according to <code>compar</code> function. If
   <code>compar</code> equals <code>NULL</code>, no sorting is enforced.
</p>
<hr>
<a name="gt_dlist_new_with_data"></a>

<code>GtDlist*      gt_dlist_new_with_data(GtCompareWithData compar, void *data)</code>
<p>
Return a new <code>GtDlist</code> object sorted according to <code>compar</code> function. If
   <code>compar</code> equals <code>NULL</code>, no sorting is enforced. Use <code>data</code> to supply
   additional data to the comparator function.
</p>
<hr>
<a name="gt_dlist_first"></a>

<code>GtDlistelem*  gt_dlist_first(const GtDlist *dlist)</code>
<p>
Return the first <code>GtDlistelem</code> object in <code>dlist</code>.
</p>
<hr>
<a name="gt_dlist_last"></a>

<code>GtDlistelem*  gt_dlist_last(const GtDlist *dlist)</code>
<p>
Return the last <code>GtDlistelem</code> object in <code>dlist</code>.
</p>
<hr>
<a name="gt_dlist_find"></a>

<code>GtDlistelem*  gt_dlist_find(const GtDlist *dlist, void *data)</code>
<p>
Return the first <code>GtDlistelem</code> object in <code>dlist</code> which contains data
   identical to <code>data</code>. Takes O(n) time.
</p>
<hr>
<a name="gt_dlist_size"></a>

<code>GtUword       gt_dlist_size(const GtDlist *dlist)</code>
<p>
Return the number of <code>GtDlistelem</code> objects in <code>dlist</code>.
</p>
<hr>
<a name="gt_dlist_add"></a>

<code>void          gt_dlist_add(GtDlist *dlist, void *data)</code>
<p>
Add a new <code>GtDlistelem</code> object containing <code>data</code> to <code>dlist</code>.
   Usually O(n), but O(1) if data is added in sorted order.
</p>
<hr>
<a name="gt_dlist_remove"></a>

<code>void          gt_dlist_remove(GtDlist *dlist, GtDlistelem *dlistelem)</code>
<p>
Remove <code>dlistelem</code> from <code>dlist</code> and free it.
</p>
<hr>
<a name="gt_dlist_example"></a>

<code>int           gt_dlist_example(GtError *err)</code>
<p>
Example for usage of the <code>GtDlist</code> class.
</p>
<hr>
<a name="gt_dlist_delete"></a>

<code>void          gt_dlist_delete(GtDlist *dlist)</code>
<p>
Delete <code>dlist</code>.
</p>
<hr>
<a name="GtDlistelem"></a>
<h2>Class GtDlistelem</h2>
<a name="gt_dlistelem_next"></a>

<code>GtDlistelem*  gt_dlistelem_next(const GtDlistelem *dlistelem)</code>
<p>
Return the successor of <code>dlistelem</code>, or <code>NULL</code> if the element is the last
   one in the <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlistelem_previous"></a>

<code>GtDlistelem*  gt_dlistelem_previous(const GtDlistelem *dlistelem)</code>
<p>
Return the predecessor of <code>dlistelem</code>, or <code>NULL</code> if the element is the
   first one in the <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlistelem_get_data"></a>

<code>void*         gt_dlistelem_get_data(const GtDlistelem *dlistelem)</code>
<p>
Return the data pointer attached to <code>dlistelem</code>.
</p>
<hr>
<a name="GtEOFNode"></a>
<h2>Class GtEOFNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. EOF nodes mark the barrier between
   separate input files in an GFF3 stream. </p>

<hr>
<a name="gt_eof_node_new"></a>

<code>GtGenomeNode*             gt_eof_node_new(void)</code>
<p>
Create a new <code>GtEOFNode*</code> representing an EOF marker.
</p>
<hr>
<a name="gt_eof_node_try_cast"></a>

<code>GtEOFNode*                gt_eof_node_try_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is an EOF node. If so, a pointer to the
   EOF node is returned. If not, NULL is returned. Note that in most cases,
   one should implement a GtNodeVisitor to handle processing of different
   GtGenomeNode types.
</p>
<hr>
<a name="GtEncseq"></a>
<h2>Class GtEncseq</h2>

<p> The <code>GtEncseq</code> class represents a concatenated collection of sequences from
   one or more input files in a bit-compressed encoding. It is stored in a
   number of <code>mmap()</code>able files, depending on which features it is meant to
   support.
   The main compressed sequence information is stored in an <em>encoded sequence</em>
   table, with the file suffix '.esq'. This table is the minimum requirement
   for the <code>GtEncseq</code> structure and must always be present. In addition, if
   support for multiple sequences is desired, a <em>sequence separator position</em>
   table with the '.ssp' suffix is required. If support for sequence
   descriptions is required, two additional tables are needed: a <em>description</em>
   table with the suffix '.des' and a <em>description separator</em> table with the
   file suffix '.sds'. Creation and requirement of these tables can be switched
   on and off using API functions as outlined below.
   The <code>GtEncseq</code> represents the stored sequences as one concatenated string.
   It allows access to the sequences by providing start positions and lengths
   for each sequence, making it possible to extract encoded substrings into a
   given buffer, as well as accessing single characters both in a random and a
   sequential fashion. </p>

<hr>
<a name="gt_encseq_indexname"></a>

<code>const char*        gt_encseq_indexname(const GtEncseq *encseq)</code>
<p>
Returns the indexname (as given at loading time) of <code>encseq</code>
   or "generated" if the GtEncseq was build in memory only.
</p>
<hr>
<a name="gt_encseq_total_length"></a>

<code>GtUword            gt_encseq_total_length(const GtEncseq *encseq)</code>
<p>
Returns the total number of characters in all sequences of <code>encseq</code>,
   including separators and wildcards.
</p>
<hr>
<a name="gt_encseq_num_of_sequences"></a>

<code>GtUword            gt_encseq_num_of_sequences(const GtEncseq *encseq)</code>
<p>
Returns the total number of sequences contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_get_encoded_char"></a>

<code>GtUchar            gt_encseq_get_encoded_char(const GtEncseq *encseq,
                                             GtUword pos,
                                             GtReadmode readmode)</code>
<p>
Returns the encoded representation of the character at position <code>pos</code> of
   <code>encseq</code> read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_get_decoded_char"></a>

<code>char               gt_encseq_get_decoded_char(const GtEncseq *encseq,
                                             GtUword pos,
                                             GtReadmode readmode)</code>
<p>
Returns the decoded representation of the character at position <code>pos</code> of
   <code>encseq</code> read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_position_is_separator"></a>

<code>bool               gt_encseq_position_is_separator(const GtEncseq *encseq,
                                                  GtUword pos,
                                                  GtReadmode readmode)</code>
<p>
Returns true iff <code>pos</code> is a separator position of <code>encseq</code>
   read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_ref"></a>

<code>GtEncseq*          gt_encseq_ref(GtEncseq *encseq)</code>
<p>
Increases the reference count of <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_create_reader_with_readmode"></a>

<code>GtEncseqReader*    gt_encseq_create_reader_with_readmode(const GtEncseq *encseq,
                                                        GtReadmode readmode,
                                                        GtUword startpos)</code>
<p>
Returns a new <code>GtEncseqReader</code> for <code>encseq</code>, starting from position
   <code>startpos</code>. Also supports reading the sequence from the reverse and
   delivering (reverse) complement characters on DNA alphabets using the
   <code>readmode</code> option. Please make sure that the <code>GT_READMODE_COMPL</code> and
   <code>GT_READMODE_REVCOMPL</code> readmodes are only used on DNA alphabets.
</p>
<hr>
<a name="gt_encseq_extract_encoded"></a>

<code>void               gt_encseq_extract_encoded(const GtEncseq *encseq,
                                            GtUchar *buffer,
                                            GtUword frompos,
                                            GtUword topos)</code>
<p>
Returns the encoded representation of the substring from position <code>frompos</code>
   to position <code>topos</code> of <code>encseq</code>. The result is written to the location
   pointed to by <code>buffer</code>, which must be large enough to hold the result.
</p>
<hr>
<a name="gt_encseq_extract_decoded"></a>

<code>void               gt_encseq_extract_decoded(const GtEncseq *encseq,
                                            char *buffer,
                                            GtUword frompos,
                                            GtUword topos)</code>
<p>
Returns the decoded version of the substring from position <code>frompos</code>
   to position <code>topos</code> of <code>encseq</code>. The result is written to the location
   pointed to by <code>buffer</code>, which must be large enough to hold the result.
</p>
<hr>
<a name="gt_encseq_seqlength"></a>

<code>GtUword            gt_encseq_seqlength(const GtEncseq *encseq,
                                      GtUword seqnum)</code>
<p>
Returns the length of the <code>seqnum</code>-th sequence in the <code>encseq</code>.
   Requires multiple sequence support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_min_seq_length"></a>

<code>GtUword            gt_encseq_min_seq_length(const GtEncseq *encseq)</code>
<p>
Returns the length of the shortest sequence in the <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_max_seq_length"></a>

<code>GtUword            gt_encseq_max_seq_length(const GtEncseq *encseq)</code>
<p>
Returns the length of the longest sequence in the <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_has_multiseq_support"></a>

<code>bool               gt_encseq_has_multiseq_support(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> has multiple sequence support.
</p>
<hr>
<a name="gt_encseq_has_description_support"></a>

<code>bool               gt_encseq_has_description_support(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> has description support.
</p>
<hr>
<a name="gt_encseq_has_md5_support"></a>

<code>bool               gt_encseq_has_md5_support(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> has MD5 support.
</p>
<hr>
<a name="gt_encseq_seqstartpos"></a>

<code>GtUword            gt_encseq_seqstartpos(const GtEncseq *encseq,
                                        GtUword seqnum)</code>
<p>
Returns the start position of the <code>seqnum</code>-th sequence in the <code>encseq</code>.
   Requires multiple sequence support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_seqnum"></a>

<code>GtUword            gt_encseq_seqnum(const GtEncseq *encseq,
                                   GtUword position)</code>
<p>
Returns the sequence number from the given <code>position</code> for a given
   GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_description"></a>

<code>const char*        gt_encseq_description(const GtEncseq *encseq,
                                        GtUword *desclen,
                                        GtUword seqnum)</code>
<p>
Returns a pointer to the description of the <code>seqnum</code>-th sequence in the
   <code>encseq</code>. The length of the returned string is written to the
   location pointed at by <code>desclen</code>.
   The returned description pointer is not <code>\0</code>-terminated!
   Requires description support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenames"></a>

<code>const GtStrArray*  gt_encseq_filenames(const GtEncseq *encseq)</code>
<p>
Returns a <code>GtStrArray</code> of the names of the original sequence files
   contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_num_of_files"></a>

<code>GtUword            gt_encseq_num_of_files(const GtEncseq *encseq)</code>
<p>
Returns the number of files contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_effective_filelength"></a>

<code>GtUint64           gt_encseq_effective_filelength(const GtEncseq *encseq,
                                                 GtUword filenum)</code>
<p>
Returns the effective length (sum of sequence lengths and separators
   between them) of the <code>filenum</code>-th file contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filestartpos"></a>

<code>GtUword            gt_encseq_filestartpos(const GtEncseq *encseq,
                                         GtUword filenum)</code>
<p>
Returns the start position of the sequences of the  <code>filenum</code>-th file in the
   <code>encseq</code>. Requires multiple file support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenum"></a>

<code>GtUword            gt_encseq_filenum(const GtEncseq *encseq,
                                    GtUword position)</code>
<p>
Returns the file number from the given <code>position</code> for a given
   GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenum_first_seqnum"></a>

<code>GtUword            gt_encseq_filenum_first_seqnum(const GtEncseq *encseq,
                                                 GtUword filenum)</code>
<p>
Returns the first sequence number of the sequences in file <code>filenum</code> for a
   given GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_alphabet"></a>

<code>GtAlphabet*        gt_encseq_alphabet(const GtEncseq *encseq)</code>
<p>
Returns the <code>GtAlphabet</code> associated with <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_mirror"></a>

<code>int                gt_encseq_mirror(GtEncseq *encseq, GtError *err)</code>
<p>
Extends <code>encseq</code>  by virtual reverse complement sequences.
   Returns 0 if mirroring has been successfully enabled, otherwise -1.
   <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_encseq_unmirror"></a>

<code>void               gt_encseq_unmirror(GtEncseq *encseq)</code>
<p>
Removes virtual reverse complement sequences added by
   <code>gt_encseq_mirror()</code>.
</p>
<hr>
<a name="gt_encseq_is_mirrored"></a>

<code>bool               gt_encseq_is_mirrored(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> contains virtual reverse complement sequences as
   added by <code>gt_encseq_mirror()</code>.
</p>
<hr>
<a name="gt_encseq_version"></a>

<code>GtUword            gt_encseq_version(const GtEncseq *encseq)</code>
<p>
Returns the version number of the file representation of <code>encseq</code> if it
   exists, or 0 if it was not mapped from a file.
</p>
<hr>
<a name="gt_encseq_is_64_bit"></a>

<code>bool               gt_encseq_is_64_bit(const GtEncseq *encseq)</code>
<p>
Returns TRUE if <code>encseq</code> was created on a 64-bit system.
</p>
<hr>
<a name="gt_encseq_delete"></a>

<code>void               gt_encseq_delete(GtEncseq *encseq)</code>
<p>
Deletes <code>encseq</code> and frees all associated space.
</p>
<hr>
<a name="GtEncseqBuilder"></a>
<h2>Class GtEncseqBuilder</h2>

<p> The <code>GtEncseqBuilder</code> class creates <code>GtEncseq</code> objects by constructing
   uncompressed, encoded string copies in memory. </p>

<hr>
<a name="gt_encseq_builder_new"></a>

<code>GtEncseqBuilder*   gt_encseq_builder_new(GtAlphabet *alpha)</code>
<p>
Creates a new <code>GtEncseqBuilder</code> using the alphabet <code>alpha</code> as a basis for
   on-the-fly encoding of sequences in memory.
</p>
<hr>
<a name="gt_encseq_builder_enable_description_support"></a>

<code>void               gt_encseq_builder_enable_description_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   to be built by <code>eb</code>. Requires additional memory to hold the descriptions and
   a position index.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_builder_disable_description_support"></a>

<code>void               gt_encseq_builder_disable_description_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   to be built by <code>eb</code>. Disabling this support will result in an error when
   trying to call the method <code>gt_encseq_description()</code> on the
   <code>GtEncseq</code> object created by <code>eb</code>.
</p>
<hr>
<a name="gt_encseq_builder_enable_multiseq_support"></a>

<code>void               gt_encseq_builder_enable_multiseq_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence to be built by <code>eb</code>. Requires additional memory for an index of
   starting positions. Activated by default.
</p>
<hr>
<a name="gt_encseq_builder_disable_multiseq_support"></a>

<code>void               gt_encseq_builder_disable_multiseq_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence to be built by <code>eb</code>. Disabling this support will result in an
   error when trying to call the method <code>gt_encseq_seqlength()</code> or
   <code>gt_encseq_seqstartpos()</code> on the <code>GtEncseq</code> object created by <code>eb</code>.
</p>
<hr>
<a name="gt_encseq_builder_create_esq_tab"></a>

<code>void               gt_encseq_builder_create_esq_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .esq table containing the encoded sequence itself.
   Naturally, enabled by default.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_esq_tab"></a>

<code>void               gt_encseq_builder_do_not_create_esq_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .esq table.
</p>
<hr>
<a name="gt_encseq_builder_create_des_tab"></a>

<code>void               gt_encseq_builder_create_des_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .des table containing sequence descriptions.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_des_tab"></a>

<code>void               gt_encseq_builder_do_not_create_des_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .des table.
</p>
<hr>
<a name="gt_encseq_builder_create_ssp_tab"></a>

<code>void               gt_encseq_builder_create_ssp_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .ssp table containing indexes for multiple sequences.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_ssp_tab"></a>

<code>void               gt_encseq_builder_do_not_create_ssp_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .ssp table.
</p>
<hr>
<a name="gt_encseq_builder_create_sds_tab"></a>

<code>void               gt_encseq_builder_create_sds_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .sds table containing indexes for sequence
   descriptions.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_sds_tab"></a>

<code>void               gt_encseq_builder_do_not_create_sds_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .sds table.
</p>
<hr>
<a name="gt_encseq_builder_add_cstr"></a>

<code>void               gt_encseq_builder_add_cstr(GtEncseqBuilder *eb,
                                             const char *str,
                                             GtUword strlen,
                                             const char *desc)</code>
<p>
Adds a sequence given as a C string <code>str</code> of length <code>strlen</code> to the
   encoded sequence to be built by <code>eb</code>. Additionally, a description can be
   given (<code>desc</code>). If description support is enabled, this must not be <code>NULL</code>.
   A copy will be made during the addition process and the sequence will
   be encoded using the alphabet set at the construction time of <code>eb</code>. Thus it
   must only contain symbols compatible with the alphabet.
</p>
<hr>
<a name="gt_encseq_builder_add_str"></a>

<code>void               gt_encseq_builder_add_str(GtEncseqBuilder *eb, GtStr *str,
                                           const char *desc)</code>
<p>
Adds a sequence given as a GtStr <code>str</code> to the encoded sequence to be built
   by <code>eb</code>. Additionally, a description can be given. If description support
   is enabled, <code>desc</code> must not be <code>NULL</code>.
   A copy will be made during the addition process and the sequence will
   be encoded using the alphabet set at the construction time of <code>eb</code>. Thus it
   must only contain symbols compatible with the alphabet.
</p>
<hr>
<a name="gt_encseq_builder_add_encoded"></a>

<code>void               gt_encseq_builder_add_encoded(GtEncseqBuilder *eb,
                                               const GtUchar *str,
                                               GtUword strlen,
                                               const char *desc)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>. <code>str</code> is not allowed to
   include sequence separators. Does not take ownership of <code>str</code>.
   Additionally, a description <code>desc</code> can be given. If description support
   is enabled, this must not be <code>NULL</code>.
</p>
<hr>
<a name="gt_encseq_builder_add_encoded_own"></a>

<code>void               gt_encseq_builder_add_encoded_own(GtEncseqBuilder *eb,
                                                   const GtUchar *str,
                                                   GtUword strlen,
                                                   const char *desc)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>.
   Always creates a copy of <code>str</code>, so it can be used with memory that is to be
   freed immediately after adding.
   Additionally, a description <code>desc</code> can be given. If description support
   is enabled, this must not be <code>NULL</code>.
</p>
<hr>
<a name="gt_encseq_builder_add_multiple_encoded"></a>

<code>void               gt_encseq_builder_add_multiple_encoded(GtEncseqBuilder *eb,
                                                         const GtUchar *str,
                                                         GtUword strlen)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>. <code>str</code> may include
   sequence separators. Does not take ownership of <code>str</code>.
</p>
<hr>
<a name="gt_encseq_builder_set_logger"></a>

<code>void               gt_encseq_builder_set_logger(GtEncseqBuilder*, GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is <code>NULL</code> (no
   logging).
</p>
<hr>
<a name="gt_encseq_builder_build"></a>

<code>GtEncseq*          gt_encseq_builder_build(GtEncseqBuilder *eb, GtError *err)</code>
<p>
Creates a new <code>GtEncseq</code> from the sequences added to <code>eb</code>.
   Returns a <code>GtEncseq</code> instance on success, or <code>NULL</code> on error.
   If an error occurred, <code>err</code> is set accordingly.
   The state of <code>eb</code> is reset to empty after successful creation of a new
   <code>GtEncseq</code> (like having called <code>gt_encseq_builder_reset()</code>).
</p>
<hr>
<a name="gt_encseq_builder_reset"></a>

<code>void               gt_encseq_builder_reset(GtEncseqBuilder *eb)</code>
<p>
Clears all added sequences and descriptions, resetting <code>eb</code> to a state
   similar to the state immediately after its initial creation.
</p>
<hr>
<a name="gt_encseq_builder_delete"></a>

<code>void               gt_encseq_builder_delete(GtEncseqBuilder *eb)</code>
<p>
Deletes <code>eb</code>.
</p>
<hr>
<a name="GtEncseqEncoder"></a>
<h2>Class GtEncseqEncoder</h2>

<p> The <code>GtEncseqEncoder</code> class creates objects encapsulating a parameter
   set for conversion from sequence files into encoded sequence files on
   secondary storage. </p>

<hr>
<a name="gt_encseq_encoder_new"></a>

<code>GtEncseqEncoder*   gt_encseq_encoder_new(void)</code>
<p>
Creates a new <code>GtEncseqEncoder</code>.
</p>
<hr>
<a name="gt_encseq_encoder_set_timer"></a>

<code>void               gt_encseq_encoder_set_timer(GtEncseqEncoder *ee, GtTimer *t)</code>
<p>
Sets <code>t</code> to be the timer for <code>ee</code>. Default is <code>NULL</code> (no progress
reporting).
</p>
<hr>
<a name="gt_encseq_encoder_get_timer"></a>

<code>GtTimer*           gt_encseq_encoder_get_timer(const GtEncseqEncoder *ee)</code>
<p>
Returns the timer set for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_use_representation"></a>

<code>int                gt_encseq_encoder_use_representation(GtEncseqEncoder *ee,
                                                      const char *sat,
                                                      GtError *err)</code>
<p>
Sets the representation of <code>ee</code> to <code>sat</code> which must be one of 'direct',
   'bytecompress', 'bit', 'uchar', 'ushort' or 'uint32'. Returns 0 on success,
   and a negative value on error (<code>err</code> is set accordingly).
</p>
<hr>
<a name="gt_encseq_encoder_representation"></a>

<code>GtStr*             gt_encseq_encoder_representation(const GtEncseqEncoder *ee)</code>
<p>
Returns the representation requested for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_use_symbolmap_file"></a>

<code>int                gt_encseq_encoder_use_symbolmap_file(GtEncseqEncoder *ee,
                                                      const char *smap,
                                                      GtError *err)</code>
<p>
Sets the symbol map file to use in <code>ee</code> to <code>smap</code> which must a valid
   alphabet description file. Returns 0 on success, and a negative value on
   error (<code>err</code> is set accordingly). Default is <code>NULL</code> (no alphabet
   transformation).
</p>
<hr>
<a name="gt_encseq_encoder_symbolmap_file"></a>

<code>const char*        gt_encseq_encoder_symbolmap_file(const GtEncseqEncoder *ee)</code>
<p>
Returns the symbol map file requested for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_set_logger"></a>

<code>void               gt_encseq_encoder_set_logger(GtEncseqEncoder *ee,
                                              GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is <code>NULL</code> (no
   logging).
</p>
<hr>
<a name="gt_encseq_encoder_enable_description_support"></a>

<code>void               gt_encseq_encoder_enable_description_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   encoded by <code>ee</code>. That is, the .des and .sds tables are created.
   This is a prerequisite for being able to activate description support in
   <code>gt_encseq_loader_require_description_support()</code>. Activated by default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_description_support"></a>

<code>void               gt_encseq_encoder_disable_description_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   encoded by <code>ee</code>. That is, the .des and .sds tables are not created.
   Encoded sequences created without this support will not be able to be
   loaded via a <code>GtEncseqLoader</code> with
   <code>gt_encseq_loader_require_description_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_multiseq_support"></a>

<code>void               gt_encseq_encoder_enable_multiseq_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence encoded by <code>ee</code>. That is, the .ssp table is created.
   This is a prerequisite for being able to activate description support in
   <code>gt_encseq_loader_require_multiseq_support()</code>. Activated by default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_multiseq_support"></a>

<code>void               gt_encseq_encoder_disable_multiseq_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence encoded by <code>ee</code>. That is, the .ssp table is not created.
   Encoded sequences created without this support will not be able to be
   loaded via a <code>GtEncseqLoader</code> with
   <code>gt_encseq_loader_require_multiseq_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_lossless_support"></a>

<code>void               gt_encseq_encoder_enable_lossless_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Enables support for lossless reproduction of the original sequence,
   regardless of alphabet transformations that may apply. Deactivated by
   default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_lossless_support"></a>

<code>void               gt_encseq_encoder_disable_lossless_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Enables support for lossless reproduction of the original sequence,
   regardless of alphabet transformations that may apply. Encoded sequences
   created without this support will not be able to be loaded via a
   <code>GtEncseqLoader</code> with <code>gt_encseq_loader_require_lossless_support()</code>
   enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_md5_support"></a>

<code>void               gt_encseq_encoder_enable_md5_support(GtEncseqEncoder *ee)</code>
<p>
Enables support for quick MD5 indexing of the sequences in <code>ee</code>. Activated by
   default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_md5_support"></a>

<code>void               gt_encseq_encoder_disable_md5_support(GtEncseqEncoder *ee)</code>
<p>
Enables support for quick MD5 indexing of the sequences in <code>ee</code>. Encoded
   sequences created without this support will not be able to be loaded via
   a <code>GtEncseqLoader</code> with <code>gt_encseq_loader_require_md5_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_create_des_tab"></a>

<code>void               gt_encseq_encoder_create_des_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .des table containing sequence descriptions.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_des_tab"></a>

<code>void               gt_encseq_encoder_do_not_create_des_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .des table.
</p>
<hr>
<a name="gt_encseq_encoder_des_tab_requested"></a>

<code>bool               gt_encseq_encoder_des_tab_requested(
                                                     const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .des table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_ssp_tab"></a>

<code>void               gt_encseq_encoder_create_ssp_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .ssp table containing indexes for multiple sequences.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_ssp_tab"></a>

<code>void               gt_encseq_encoder_do_not_create_ssp_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .ssp table.
</p>
<hr>
<a name="gt_encseq_encoder_ssp_tab_requested"></a>

<code>bool               gt_encseq_encoder_ssp_tab_requested(
                                                     const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .ssp table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_sds_tab"></a>

<code>void               gt_encseq_encoder_create_sds_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .sds table containing indexes for sequence
   descriptions. Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_sds_tab"></a>

<code>void               gt_encseq_encoder_do_not_create_sds_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .sds table.
</p>
<hr>
<a name="gt_encseq_encoder_sds_tab_requested"></a>

<code>bool               gt_encseq_encoder_sds_tab_requested(
                                                     const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .sds table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_md5_tab"></a>

<code>void               gt_encseq_encoder_create_md5_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .md5 table containing MD5 sums. Enabled by
   default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_md5_tab"></a>

<code>void               gt_encseq_encoder_do_not_create_md5_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .md5 table.
</p>
<hr>
<a name="gt_encseq_encoder_md5_tab_requested"></a>

<code>bool               gt_encseq_encoder_md5_tab_requested(
                                                     const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .md5 table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_set_input_dna"></a>

<code>void               gt_encseq_encoder_set_input_dna(GtEncseqEncoder *ee)</code>
<p>
Sets the sequence input type for <code>ee</code> to DNA.
</p>
<hr>
<a name="gt_encseq_encoder_is_input_dna"></a>

<code>bool               gt_encseq_encoder_is_input_dna(GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the input sequence has been defined as being DNA.
</p>
<hr>
<a name="gt_encseq_encoder_set_input_protein"></a>

<code>void               gt_encseq_encoder_set_input_protein(GtEncseqEncoder *ee)</code>
<p>
Sets the sequence input type for <code>ee</code> to protein/amino acids.
</p>
<hr>
<a name="gt_encseq_encoder_is_input_protein"></a>

<code>bool               gt_encseq_encoder_is_input_protein(GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the input sequence has been defined as being protein.
</p>
<hr>
<a name="gt_encseq_encoder_clip_desc"></a>

<code>void               gt_encseq_encoder_clip_desc(GtEncseqEncoder *ee)</code>
<p>
Makes <code>ee</code> ignore all description suffixes after the first whitespace
   character per description (as defined via isspace(3)).
</p>
<hr>
<a name="gt_encseq_encoder_are_descs_clipped"></a>

<code>bool               gt_encseq_encoder_are_descs_clipped(GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if <code>ee</code> clips all descriptions after the first whitespace.
</p>
<hr>
<a name="gt_encseq_encoder_encode"></a>

<code>int                gt_encseq_encoder_encode(GtEncseqEncoder *ee,
                                          GtStrArray *seqfiles,
                                          const char *indexname,
                                          GtError *err)</code>
<p>
Encodes the sequence files given in <code>seqfiles</code> using the settings in <code>ee</code>
   and <code>indexname</code> as the prefix for the index tables. Returns 0 on success, or
   a negative value on error (<code>err</code> is set accordingly).
</p>
<hr>
<a name="gt_encseq_encoder_delete"></a>

<code>void               gt_encseq_encoder_delete(GtEncseqEncoder *ee)</code>
<p>
Deletes <code>ee</code>.
</p>
<hr>
<a name="GtEncseqLoader"></a>
<h2>Class GtEncseqLoader</h2>

<p> The <code>GtEncseqLoader</code> class creates <code>GtEncseq</code> objects by mapping index files
   from secondary storage into memory. </p>

<hr>
<a name="gt_encseq_loader_new"></a>

<code>GtEncseqLoader*    gt_encseq_loader_new(void)</code>
<p>
Creates a new <code>GtEncseqLoader</code>.
</p>
<hr>
<a name="gt_encseq_loader_enable_autosupport"></a>

<code>void               gt_encseq_loader_enable_autosupport(GtEncseqLoader *el)</code>
<p>
Enables auto-discovery of supported features when loading an encoded
   sequence. That is, if a file with <code>indexname</code>.<code>suffix</code> exists which
   is named like a table file, it is loaded automatically.
   Use <code>gt_encseq_has_multiseq_support()</code> etc. to query for these capabilities.
</p>
<hr>
<a name="gt_encseq_loader_disable_autosupport"></a>

<code>void               gt_encseq_loader_disable_autosupport(GtEncseqLoader *el)</code>
<p>
Disables auto-discovery of supported features.
</p>
<hr>
<a name="gt_encseq_loader_require_description_support"></a>

<code>void               gt_encseq_loader_require_description_support(
                                                            GtEncseqLoader *el)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   to be loaded by <code>el</code>. That is, the .des and .sds tables must be present.
   For example, these tables are created by having enabled the
   <code>gt_encseq_encoder_enable_description_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_description_support"></a>

<code>void               gt_encseq_loader_drop_description_support(GtEncseqLoader *el)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   to be loaded by <code>el</code>. That is, the .des and .sds tables need not be present.
   However, disabling this support will result in an error when trying to call
   the method <code>gt_encseq_description()</code> on the <code>GtEncseq</code>
   object created by <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_require_multiseq_support"></a>

<code>void               gt_encseq_loader_require_multiseq_support(GtEncseqLoader *el)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence to be loaded by <code>el</code>. That is, the .ssp table must be present.
   For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_multiseq_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_multiseq_support"></a>

<code>void               gt_encseq_loader_drop_multiseq_support(GtEncseqLoader *el)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence to be loaded by <code>el</code>. That is, the .ssp table needs not be present.
   However, disabling this support will result in an error when trying to call
   the method <code>gt_encseq_seqlength()</code> and <code>gt_encseq_seqstartpos()</code> on
   the <code>GtEncseq</code> object created by <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_require_lossless_support"></a>

<code>void               gt_encseq_loader_require_lossless_support(GtEncseqLoader *el)</code>
<p>
Enables support for lossless reproduction of the original sequence
   in the encoded sequence to be loaded by <code>el</code>. That is, the .ois table
   must be present.
   For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_lossless_support()</code> option when encoding.
   Deactivated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_lossless_support"></a>

<code>void               gt_encseq_loader_drop_lossless_support(GtEncseqLoader *el)</code>
<p>
Disables support for lossless reproduction of the original sequence
   in the encoded sequence to be loaded by <code>el</code>. That is, the .ois table
   needs not be present.
   However, disabling this support may result in a reduced alphabet
   representation when accessing decoded characters.
</p>
<hr>
<a name="gt_encseq_loader_require_md5_support"></a>

<code>void               gt_encseq_loader_require_md5_support(GtEncseqLoader *el)</code>
<p>
Enables support for quick retrieval of the MD5 sums for the sequences in the
   encoded sequence to be loaded by <code>el</code>. That is, the .md5 table must be
   present. For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_md5_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_md5_support"></a>

<code>void               gt_encseq_loader_drop_md5_support(GtEncseqLoader *el)</code>
<p>
Disables support for quick retrieval of the MD5 sums for the sequences in the
   encoded sequence to be loaded by <code>el</code>. That is, the .md5 table needs not be
   present.
</p>
<hr>
<a name="gt_encseq_loader_require_des_tab"></a>

<code>void               gt_encseq_loader_require_des_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .des table containing sequence descriptions.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_des_tab"></a>

<code>void               gt_encseq_loader_do_not_require_des_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .des table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_des_tab_required"></a>

<code>bool               gt_encseq_loader_des_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns <code>true</code> if a .des table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_require_ssp_tab"></a>

<code>void               gt_encseq_loader_require_ssp_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .ssp table containing indexes for multiple
   sequences. Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_ssp_tab"></a>

<code>void               gt_encseq_loader_do_not_require_ssp_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .ssp table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_ssp_tab_required"></a>

<code>bool               gt_encseq_loader_ssp_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns <code>true</code> if a .ssp table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_require_sds_tab"></a>

<code>void               gt_encseq_loader_require_sds_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .sds table containing indexes for sequence
   descriptions. Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_sds_tab"></a>

<code>void               gt_encseq_loader_do_not_require_sds_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .sds table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_sds_tab_required"></a>

<code>bool               gt_encseq_loader_sds_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns <code>true</code> if a .sds table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_set_logger"></a>

<code>void               gt_encseq_loader_set_logger(GtEncseqLoader *el, GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is <code>NULL</code> (no
   logging).
</p>
<hr>
<a name="gt_encseq_loader_mirror"></a>

<code>void               gt_encseq_loader_mirror(GtEncseqLoader *el)</code>
<p>
Enables loading of a sequence using <code>el</code> with mirroring enabled from the
   start. Identical to invoking <code>gt_encseq_mirror()</code> directly after loading.
</p>
<hr>
<a name="gt_encseq_loader_do_not_mirror"></a>

<code>void               gt_encseq_loader_do_not_mirror(GtEncseqLoader *el)</code>
<p>
Disables loading of a sequence using <code>el</code> with mirroring enabled right from
   the start.
</p>
<hr>
<a name="gt_encseq_loader_load"></a>

<code>GtEncseq*          gt_encseq_loader_load(GtEncseqLoader *el,
                                        const char *indexname,
                                        GtError *err)</code>
<p>
Attempts to map the index files as specified by <code>indexname</code> using the options
   set in <code>el</code> using this interface. Returns a <code>GtEncseq</code> instance
   on success, or <code>NULL</code> on error. If an error occurred, <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_encseq_loader_delete"></a>

<code>void               gt_encseq_loader_delete(GtEncseqLoader *el)</code>
<p>
Deletes <code>el</code>.
</p>
<hr>
<a name="GtEncseqReader"></a>
<h2>Class GtEncseqReader</h2>

<p> The <code>GtEncseqReader</code> class represents the current state of a
   sequential scan of a <code>GtEncseq</code> region as an iterator. </p>

<hr>
<a name="gt_encseq_reader_reinit_with_readmode"></a>

<code>void               gt_encseq_reader_reinit_with_readmode(GtEncseqReader *esr,
                                                      const GtEncseq *encseq,
                                                      GtReadmode readmode,
                                                      GtUword startpos)</code>
<p>
Reinitializes the given <code>esr</code> with the values as described in
   <code>gt_encseq_create_reader_with_readmode()</code>.
</p>
<hr>
<a name="gt_encseq_reader_next_encoded_char"></a>

<code>GtUchar            gt_encseq_reader_next_encoded_char(GtEncseqReader *esr)</code>
<p>
Returns the next encoded character from current position of <code>esr</code>, advancing
   the iterator by one position.
</p>
<hr>
<a name="gt_encseq_reader_next_decoded_char"></a>

<code>char               gt_encseq_reader_next_decoded_char(GtEncseqReader *esr)</code>
<p>
Returns the next decoded character from current position of <code>esr</code>, advancing
   the iterator by one position.
</p>
<hr>
<a name="gt_encseq_reader_delete"></a>

<code>void               gt_encseq_reader_delete(GtEncseqReader *esr)</code>
<p>
Deletes <code>esr</code>, freeing all associated space.
</p>
<hr>
<a name="GtError"></a>
<h2>Class GtError</h2>

<p>
   This class is used for the handling of <strong>user errors</strong> in <em>GenomeTools</em>.
   Thereby, the actual <code>GtError</code> object is used to store the <em>error message</em>
   while it is signaled by the return value of the called function, if an error
   occured.</p><p>   By convention in <em>GenomeTools</em>, the <code>GtError</code> object is always passed into
   a function as the last parameter and -1 (or <code>NULL</code> for constructors) is used
   as return value to indicate that an error occurred.
   Success is usually indicated by 0 as return value or via a non-<code>NULL</code> object
   pointer for constructors.</p><p>   It is possible to use <code>NULL</code> as an <code>GtError</code> object, if one is not interested
   in the actual error message.</p><p>   Functions which do not get an <code>GtError</code> object cannot fail due to a user
   error and it is not necessary to check their return code for an error
   condition.
</p>

<hr>
<a name="gt_error_new"></a>

<code>GtError*    gt_error_new(void)</code>
<p>
Return a new <code>GtError</code> object
</p>
<hr>
<a name="gt_error_check"></a>

<code>#define gt_error_check(err)</code>
<p>
Insert an assertion to check that the error <code>err</code> is not set or is <code>NULL</code>.
   This macro should be used at the beginning of every routine which has an
   <code>GtError*</code> argument to make sure the error propagation has been coded
   correctly.
</p>
<hr>
<a name="gt_error_set"></a>

<code>void         gt_error_set(GtError *err, const char *format, ...)</code>
<p>
Set the error message stored in <code>err</code> according to <code>format</code> (as in
   <code>printf(3)</code>).
</p>
<hr>
<a name="gt_error_vset"></a>

<code>void         gt_error_vset(GtError *err, const char *format, va_list ap)</code>
<p>
Set the error message stored in <code>err</code> according to <code>format</code> (as in
   <code>vprintf(3)</code>).
</p>
<hr>
<a name="gt_error_set_nonvariadic"></a>

<code>void         gt_error_set_nonvariadic(GtError *err, const char *msg)</code>
<p>
Set the error message stored in <code>err</code> to <code>msg</code>.
</p>
<hr>
<a name="gt_error_is_set"></a>

<code>bool         gt_error_is_set(const GtError *err)</code>
<p>
Return <code>true</code> if the error <code>err</code> is set, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_error_unset"></a>

<code>void         gt_error_unset(GtError *err)</code>
<p>
Unset the error <code>err</code>.
</p>
<hr>
<a name="gt_error_get"></a>

<code>const char*  gt_error_get(const GtError *err)</code>
<p>
Return the error string stored in <code>err</code> (the error must be set).
</p>
<hr>
<a name="gt_error_delete"></a>

<code>void         gt_error_delete(GtError *err)</code>
<p>
Delete the error object <code>err</code>.
</p>
<hr>
<a name="GtExtractFeatureStream"></a>
<h2>Class GtExtractFeatureStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtExtractFeatureStream</code> extracts
   the corresponding sequences of features. </p>

<hr>
<a name="gt_extract_feature_stream_new"></a>

<code>GtNodeStream*  gt_extract_feature_stream_new(GtNodeStream *in_stream,
                                            GtRegionMapping *region_Mapping,
                                            const char *type, bool join,
                                            bool translate, bool seqid,
                                            bool target, GtUword width,
                                            GtFile *outfp)</code>
<p>
Create a <code>GtExtractFeatureStream*</code> which extracts the corresponding sequences
   of feature nodes (of the given <code>type</code>) it retrieves from <code>in_stream</code> and
   writes them in FASTA format (with the given <code>width</code>) to <code>outfp</code>. If <code>join</code> is
   <code>true</code>, features of the given <code>type</code> are joined together before the sequence
   is extracted. If <code>translate</code> is <code>true</code>, the sequences are translated into
   amino acid sequences before they are written to <code>outfp</code>. If <code>seqid</code> is <code>true</code>
   the sequence IDs of the extracted features are added to the FASTA header.
   If <code>target</code> is <code>true</code> the target IDs of the extracted features are added to
   the FASTA header. Takes ownership of <code>region_mapping</code>!
</p>
<hr>
<a name="GtFeatureInStream"></a>
<h2>Class GtFeatureInStream</h2>
<a name="gt_feature_in_stream_new"></a>

<code>GtNodeStream*  gt_feature_in_stream_new(GtFeatureIndex *fi)</code>
<p>
Create a new <code>GtFeatureInStream</code> using the given <code>GtFeatureIndex</code> as the
   source of a node stream.
</p>
<hr>
<a name="gt_feature_in_stream_use_orig_ranges"></a>

<code>void  gt_feature_in_stream_use_orig_ranges(GtFeatureInStream *stream)</code>
<p>
Instruct <code>stream</code> to deliver GtRegionNode objects whose ranges are
   specified such as with <code>##sequence-region</code> pragmas, rather than those
   inferred from the features. Specifically, use
   <code>gt_feature_index_get_orig_range_for_seqid</code> on the underlying feature
   index rather than the default <code>gt_feature_index_get_range_for_seqid</code>.
</p>
<hr>
<a name="GtFeatureIndex"></a>
<h2>Class GtFeatureIndex</h2>

<p> This interface represents a searchable container for <code>GtFeatureNode</code> objects,
   typically root nodes of larger structures. How storage and searching takes
   place is left to the discretion of the implementing class.</p><p>   Output from a <code>gt_feature_index_get_features_*()</code> method should always
   be sorted by feature start position. </p>

<hr>
<a name="gt_feature_index_add_region_node"></a>

<code>int          gt_feature_index_add_region_node(GtFeatureIndex *feature_index,
                                             GtRegionNode *region_node,
                                             GtError *err)</code>
<p>
Add <code>region_node</code> to <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_add_feature_node"></a>

<code>int          gt_feature_index_add_feature_node(GtFeatureIndex *feature_index,
                                              GtFeatureNode *feature_node,
                                              GtError *err)</code>
<p>
Add <code>feature_node</code> to <code>feature_index</code>, associating it with a sequence
   region denoted by its identifier string.
</p>
<hr>
<a name="gt_feature_index_remove_node"></a>

<code>int          gt_feature_index_remove_node(GtFeatureIndex *feature_index,
                                         GtFeatureNode *node,
                                         GtError *err)</code>
<p>
Removes node <code>genome_node</code> from <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_add_gff3file"></a>

<code>int          gt_feature_index_add_gff3file(GtFeatureIndex *feature_index,
                                          const char *gff3file, GtError *err)</code>
<p>
Add all features contained in <code>gff3file</code> to <code>feature_index</code>, if <code>gff3file</code> is
   valid. Otherwise, <code>feature_index</code> is not changed and <code>err</code> is set.
</p>
<hr>
<a name="gt_feature_index_get_features_for_seqid"></a>

<code>GtArray*     gt_feature_index_get_features_for_seqid(GtFeatureIndex*,
                                                    const char *seqid,
                                                    GtError *err)</code>
<p>
Returns an array of <code>GtFeatureNodes</code> associated with a given sequence region
   identifier <code>seqid</code>.
</p>
<hr>
<a name="gt_feature_index_get_features_for_range"></a>

<code>int          gt_feature_index_get_features_for_range(GtFeatureIndex
                                                    *feature_index,
                                                    GtArray *results,
                                                    const char *seqid,
                                                    const GtRange *range,
                                                    GtError*)</code>
<p>
Look up genome features in <code>feature_index</code> for sequence region <code>seqid</code> in
   <code>range</code> and store them in <code>results</code>.
</p>
<hr>
<a name="gt_feature_index_get_first_seqid"></a>

<code>char*        gt_feature_index_get_first_seqid(const GtFeatureIndex
                                             *feature_index,
                                             GtError *err)</code>
<p>
Returns the first sequence region identifier added to <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_get_seqids"></a>

<code>GtStrArray*  gt_feature_index_get_seqids(const GtFeatureIndex *feature_index,
                                        GtError *err)</code>
<p>
Returns a <code>GtStrArray</code> of all sequence region identifiers contained in
   <code>feature_index</code> (in alphabetical order).
</p>
<hr>
<a name="gt_feature_index_get_range_for_seqid"></a>

<code>int          gt_feature_index_get_range_for_seqid(GtFeatureIndex *feature_index,
                                                 GtRange *range,
                                                 const char *seqid,
                                                 GtError *err)</code>
<p>
Writes the range of all features contained in the <code>feature_index</code> for
   region identifier <code>seqid</code> to the <code>GtRange</code> pointer <code>range</code>.
</p>
<hr>
<a name="gt_feature_index_get_orig_range_for_seqid"></a>

<code>int          gt_feature_index_get_orig_range_for_seqid(GtFeatureIndex
                                                                *feature_index,
                                                      GtRange *range,
                                                      const char *seqid,
                                                      GtError *err)</code>
<p>
Writes the range of the whole sequence region contained in the
   <code>feature_index</code> for region identifier <code>seqid</code> to the <code>GtRange</code>
   pointer <code>range</code>.
</p>
<hr>
<a name="gt_feature_index_has_seqid"></a>

<code>int          gt_feature_index_has_seqid(const GtFeatureIndex *feature_index,
                                       bool *has_seqid,
                                       const char *seqid,
                                       GtError *err)</code>
<p>
Returns <code>has_seqid</code>  to true if the sequence region identified by <code>seqid</code>
   has been registered in the <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_save"></a>

<code>int          gt_feature_index_save(GtFeatureIndex *feature_index, GtError *err)</code>
<p>
Calls the save function for the given <code>feature_index</code>. The save functions
   must be defined, otherwise the method fails with an assertion (for example,
   the memory based feature index does not have a save function) .
</p>
<hr>
<a name="gt_feature_index_delete"></a>

<code>void         gt_feature_index_delete(GtFeatureIndex*)</code>
<p>
Deletes the <code>feature_index</code> and all its referenced features.
</p>
<hr>
<a name="GtFeatureIndexMemory"></a>
<h2>Class GtFeatureIndexMemory</h2>

<p> The <code>GtFeatureIndexMemory</code> class implements a <code>GtFeatureIndex</code> in memory.
   Features are organized by region node. Each region node collects its
   feature nodes in an interval tree structure, which allows for efficient
   range queries. </p>

<hr>
<a name="gt_feature_index_memory_new"></a>

<code>GtFeatureIndex*  gt_feature_index_memory_new(void)</code>
<p>
Creates a new <code>GtFeatureIndexMemory</code> object.
</p>
<hr>
<a name="gt_feature_index_memory_get_node_by_ptr"></a>

<code>GtFeatureNode*   gt_feature_index_memory_get_node_by_ptr(GtFeatureIndexMemory*,
                                                        GtFeatureNode *ptr,
                                                        GtError *err)</code>
<p>
Returns <code>ptr</code> if it is a valid node indexed in <code>GtFeatureIndexMemory</code>.
   Otherwise NULL is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="GtFeatureNode"></a>
<h2>Class GtFeatureNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. A single feature node corresponds
   to a GFF3 feature line (i.e., a line which does not start with <code>#</code>).
   Part-of relationships (which are realized in GFF3 with the <code>Parent</code> and <code>ID</code>
   attributes) are realized in the C API with the
   <code>gt_feature_node_add_child()</code> method.</p><p>   Besides the ``mere'' feature nodes two ``special'' feature nodes exist:
   multi-features and pseudo-features.</p><p>   Multi-features represent features which span multiple lines (it is indicated
   in GFF3 files by the fact, that each line has the same ID attribute).</p><p>   To check if a feature is a multi-feature use the method
   <code>gt_feature_node_is_multi()</code>.
   Multi-features are connected via a ``representative''. That is, two features
   are part of the same multi-feature if they have the same representative.
   The feature node representative can be be retrieved via the
   <code>gt_feature_node_get_multi_representative()</code> method.</p><p>   Pseudo-features became a technical necessity to be able to pass related
   top-level features as a single entity through the streaming machinery.
   There are two cases in which a pseudo-feature has to be introduced.</p><p>   First, if a multi-feature has no parent. In this case all features which
   comprise the multi-feature become the children of a pseudo-feature.</p><p>   Second, if two or more top-level features have the same children (and are
   thereby connected). In this case all these top-level features become the
   children of a pseudo-feature.</p><p>   It should be clear from the explanation above that pseudo-features make only
   sense as top-level features (a fact which is enforced in the code).</p><p>   Pseudo-features are typically ignored during a traversal to give the illusion
   that they do not exist. </p>

<hr>
<a name="gt_feature_node_new"></a>

<code>GtGenomeNode*   gt_feature_node_new(GtStr *seqid, const char *type,
                                   GtUword start, GtUword end,
                                   GtStrand strand)</code>
<p>
Return an new <code>GtFeatureNode</code> object on sequence with ID <code>seqid</code> and type
   <code>type</code> which lies from <code>start</code> to <code>end</code> on strand <code>strand</code>.
   The <code>GtFeatureNode*</code> stores a new reference to <code>seqid</code>, so make sure you do
   not modify the original <code>seqid</code> afterwards!
   <code>start</code> and <code>end</code> always refer to the forward strand, therefore <code>start</code> has
   to be smaller or equal than <code>end</code>.
</p>
<hr>
<a name="gt_feature_node_new_pseudo"></a>

<code>GtGenomeNode*   gt_feature_node_new_pseudo(GtStr *seqid, GtUword start,
                                          GtUword end, GtStrand strand)</code>
<p>
Return a new pseudo-<code>GtFeatureNode</code> object on sequence with ID <code>seqid</code> which
   lies from <code>start</code> to <code>end</code> on strand <code>strand</code>. Pseudo-features do not have a
   type.  The <code>GtFeatureNode </code> stores a new reference to <code>seqid</code>, so make sure
   you do not modify the original <code>seqid</code> afterwards.  <code>start</code> and <code>end</code> always
   refer to the forward strand, therefore <code>start</code> has to be smaller or equal
   than <code>end</code>.
</p>
<hr>
<a name="gt_feature_node_new_pseudo_template"></a>

<code>GtGenomeNode*   gt_feature_node_new_pseudo_template(GtFeatureNode *feature_node)</code>
<p>
Return a new pseudo-<code>GtFeatureNode</code> object which uses <code>feature_node</code> as
   template.  That is, the sequence ID, range, strand, and source are taken from
   <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_new_standard_gene"></a>

<code>GtGenomeNode*   gt_feature_node_new_standard_gene(void)</code>
<p>
Return the ``standard gene'' (mainly for testing purposes).
</p>
<hr>
<a name="gt_feature_node_add_child"></a>

<code>void            gt_feature_node_add_child(GtFeatureNode *parent,
                                         GtFeatureNode *child)</code>
<p>
Add <code>child</code> feature node to <code>parent</code> feature node.
   <code>parent</code> takes ownership of <code>child</code>.
</p>
<hr>
<a name="gt_feature_node_get_source"></a>

<code>const char*     gt_feature_node_get_source(const GtFeatureNode *feature_node)</code>
<p>
Return the source of <code>feature_node</code>. If no source has been set, "." is
   returned. Corresponds to column 2 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_source"></a>

<code>void            gt_feature_node_set_source(GtFeatureNode *feature_node,
                                          GtStr *source)</code>
<p>
Set the <code>source</code> of <code>feature_node</code>. Stores a new reference to <code>source</code>.
   Corresponds to column 2 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_has_source"></a>

<code>bool            gt_feature_node_has_source(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> has a defined source (i.e., on different
   from "."). <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_get_type"></a>

<code>const char*     gt_feature_node_get_type(const GtFeatureNode *feature_node)</code>
<p>
Return the type of <code>feature_node</code>.
   Corresponds to column 3 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_type"></a>

<code>void            gt_feature_node_set_type(GtFeatureNode *feature_node,
                                        const char *type)</code>
<p>
Set the type of <code>feature_node</code> to <code>type</code>.
</p>
<hr>
<a name="gt_feature_node_has_type"></a>

<code>bool            gt_feature_node_has_type(GtFeatureNode *feature_node,
                                        const char *type)</code>
<p>
Return <code>true</code> if <code>feature_node</code> has given <code>type</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_number_of_children"></a>

<code>GtUword   gt_feature_node_number_of_children(const GtFeatureNode
                                                  *feature_node)</code>
<p>
Return the number of children for given <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_number_of_children_of_type"></a>

<code>GtUword   gt_feature_node_number_of_children_of_type(const GtFeatureNode
                                                          *parent,
                                                          const GtFeatureNode
                                                          *node)</code>
<p>
Return the number of children of type <code>node</code>
   for given GtFeatureNode <code>parent</code>.
</p>
<hr>
<a name="gt_feature_node_score_is_defined"></a>

<code>bool            gt_feature_node_score_is_defined(const GtFeatureNode
                                                *feature_node)</code>
<p>
Return <code>true</code> if the score of <code>feature_node</code> is defined, <code>false</code>
   otherwise.
</p>
<hr>
<a name="gt_feature_node_get_score"></a>

<code>float           gt_feature_node_get_score(const GtFeatureNode *feature_node)</code>
<p>
Return the score of <code>feature_node</code>. The score has to be defined.
   Corresponds to column 6 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_score"></a>

<code>void            gt_feature_node_set_score(GtFeatureNode *feature_node,
                                         float score)</code>
<p>
Set the score of <code>feature_node</code> to <code>score</code>.
</p>
<hr>
<a name="gt_feature_node_unset_score"></a>

<code>void            gt_feature_node_unset_score(GtFeatureNode *feature_node)</code>
<p>
Unset the score of <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_get_strand"></a>

<code>GtStrand        gt_feature_node_get_strand(const GtFeatureNode *feature_node)</code>
<p>
Return the strand of <code>feature_node</code>.
   Corresponds to column 7 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_strand"></a>

<code>void            gt_feature_node_set_strand(GtFeatureNode *feature_node,
                                          GtStrand strand)</code>
<p>
Set the strand of <code>feature_node</code> to <code>strand</code>.
</p>
<hr>
<a name="gt_feature_node_get_phase"></a>

<code>GtPhase         gt_feature_node_get_phase(const GtFeatureNode *feature_node)</code>
<p>
Return the phase of <code>feature_node</code>.
   Corresponds to column 8 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_phase"></a>

<code>void            gt_feature_node_set_phase(GtFeatureNode *feature_node,
                                         GtPhase phase)</code>
<p>
Set the phase of <code>feature_node</code> to <code>phase</code>.
</p>
<hr>
<a name="gt_feature_node_get_attribute"></a>

<code>const char*     gt_feature_node_get_attribute(const GtFeatureNode *feature_node,
                                             const char *name)</code>
<p>
Return the attribute of <code>feature_node</code> with the given <code>name</code>.
   If no such attribute has been added, <code>NULL</code> is returned.
   The attributes are stored in column 9 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_get_attribute_list"></a>

<code>GtStrArray*     gt_feature_node_get_attribute_list(const GtFeatureNode
                                                  *feature_node)</code>
<p>
Return a string array containing the used attribute names of <code>feature_node</code>.
   The caller is responsible to free the returned <code>GtStrArray*</code>.
</p>
<hr>
<a name="gt_feature_node_add_attribute"></a>

<code>void            gt_feature_node_add_attribute(GtFeatureNode *feature_node,
                                             const char *tag,
                                             const char *value)</code>
<p>
Add attribute <code>tag</code>=<code>value</code> to <code>feature_node</code>. <code>tag</code> and <code>value</code> must at
   least have length 1. <code>feature_node</code> must not contain an attribute with the
   given <code>tag</code> already. You should not add Parent and ID attributes, use
   <code>gt_feature_node_add_child()</code> to denote part-of relationships.
</p>
<hr>
<a name="gt_feature_node_set_attribute"></a>

<code>void            gt_feature_node_set_attribute(GtFeatureNode* feature_node,
                                             const char *tag,
                                             const char *value)</code>
<p>
Set attribute <code>tag</code> to new <code>value</code> in <code>feature_node</code>, if it exists already.
   Otherwise the attribute <code>tag</code>=<code>value</code> is added to <code>feature_node</code>.
   <code>tag</code> and <code>value</code> must at least have length 1.
   You should not set Parent and ID attributes, use
   <code>gt_feature_node_add_child()</code> to denote part-of relationships.
</p>
<hr>
<a name="gt_feature_node_remove_attribute"></a>

<code>void            gt_feature_node_remove_attribute(GtFeatureNode* feature_node,
                                                const char *tag)</code>
<p>
Remove attribute <code>tag</code> from <code>feature_node</code>. <code>feature_node</code> must contain an
   attribute with the given <code>tag</code> already! You should not remove Parent and ID
   attributes.
</p>
<hr>
<a name="GtFeatureNodeAttributeIterFunc"></a>

<code>void  GtFeatureNodeAttributeIterFunc(const char *attr_name,
                                               const char *attr_value,
                                               void *data)</code>
<p>
Delivers the key (in <code>attr_name</code>)and value (in <code>attr_value</code>) of an
   attribute. The <code>data</code> parameter carries over arbitrary user data from the
   <code>gt_feature_node_foreach_attribute</code> call.
</p>
<hr>
<a name="gt_feature_node_foreach_attribute"></a>

<code>void            gt_feature_node_foreach_attribute(GtFeatureNode *feature_node,
                                            GtFeatureNodeAttributeIterFunc func,
                                            void *data)</code>
<p>
Calls <code>func</code> for each attribute in <code>feature_node</code>. Use <code>data</code> to forward
   arbitrary data during traversal.
</p>
<hr>
<a name="gt_feature_node_is_multi"></a>

<code>bool            gt_feature_node_is_multi(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> is a multi-feature, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_is_pseudo"></a>

<code>bool            gt_feature_node_is_pseudo(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> is a pseudo-feature, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_make_multi_representative"></a>

<code>void            gt_feature_node_make_multi_representative(GtFeatureNode
                                                         *feature_node)</code>
<p>
Make <code>feature_node</code> the representative of a multi-feature.
   Thereby <code>feature_node</code> becomes a multi-feature.
</p>
<hr>
<a name="gt_feature_node_set_multi_representative"></a>

<code>void            gt_feature_node_set_multi_representative(GtFeatureNode
                                                        *feature_node,
                                                        GtFeatureNode
                                                        *representative)</code>
<p>
Set the multi-feature representative of <code>feature_node</code> to <code>representative</code>.
   Thereby <code>feature_node</code> becomes a multi-feature.
</p>
<hr>
<a name="gt_feature_node_unset_multi"></a>

<code>void            gt_feature_node_unset_multi(GtFeatureNode *feature_node)</code>
<p>
Unset the multi-feature status of <code>feature_node</code> and remove its multi-feature
   representative.
</p>
<hr>
<a name="gt_feature_node_get_multi_representative"></a>

<code>GtFeatureNode*  gt_feature_node_get_multi_representative(GtFeatureNode
                                                        *feature_node)</code>
<p>
Return the representative of the multi-feature <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_is_similar"></a>

<code>bool            gt_feature_node_is_similar(const GtFeatureNode *feature_node_a,
                                          const GtFeatureNode *feature_node_b)</code>
<p>
Returns <code>true</code>, if the given <code>feature_node_a</code> has the same seqid, feature
   type, range, strand, and phase as <code>feature_node_b</code>.
   Returns <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_mark"></a>

<code>void            gt_feature_node_mark(GtFeatureNode*)</code>
<p>
Marks the given <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_unmark"></a>

<code>void            gt_feature_node_unmark(GtFeatureNode*)</code>
<p>
If the given <code>feature_node</code> is marked it will be unmarked.
</p>
<hr>
<a name="gt_feature_node_contains_marked"></a>

<code>bool            gt_feature_node_contains_marked(GtFeatureNode *feature_node)</code>
<p>
Returns <code>true</code> if the given <code>feature_node</code> graph contains a marked node.
</p>
<hr>
<a name="gt_feature_node_is_marked"></a>

<code>bool            gt_feature_node_is_marked(const GtFeatureNode *feature_node)</code>
<p>
Returns <code>true</code> if the (top-level) <code>feature_node</code> is marked.
</p>
<hr>
<a name="gt_feature_node_remove_leaf"></a>

<code>void            gt_feature_node_remove_leaf(GtFeatureNode *tree,
                                           GtFeatureNode *leafn)</code>
<p>
Removes the parent-child relationship between the leaf node <code>leafn</code> and a
   parent node <code>tree</code>. <code>tree</code> needs not be the direct parent of the <code>leafn</code>.
   Note that <code>leafn</code> is freed, use <code>gt_genome_node_ref()</code> to increase the
   reference count if deletion is not wanted. As a side effect, the tree
   property of <code>tree</code> is set back to an undefined state.
</p>
<hr>
<a name="gt_feature_node_try_cast"></a>

<code>GtFeatureNode*  gt_feature_node_try_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a feature node. If so, a pointer to the
   feature node is returned. If not, NULL is returned. Note that in most cases,
   one should implement a GtNodeVisitor to handle processing of different
   GtGenomeNode types.
</p>
<hr>
<a name="gt_feature_node_cast"></a>

<code>GtFeatureNode*  gt_feature_node_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a feature node. If so, a pointer to the
   feature node is returned. If not, an assertion fails.
</p>
<hr>
<a name="GtFeatureNodeIterator"></a>
<h2>Class GtFeatureNodeIterator</h2>
<a name="gt_feature_node_iterator_new"></a>

<code>GtFeatureNodeIterator*  gt_feature_node_iterator_new(const GtFeatureNode
                                                    *feature_node)</code>
<p>
Return a new <code>GtFeatureNodeIterator*</code> which performs a depth-first
   traversal of <code>feature_node</code> (including <code>feature_node</code> itself).
   It ignores pseudo-features.
</p>
<hr>
<a name="gt_feature_node_iterator_new_direct"></a>

<code>GtFeatureNodeIterator*  gt_feature_node_iterator_new_direct(const GtFeatureNode
                                                           *feature_node)</code>
<p>
Return a new <code>GtFeatureNodeIterator*</code> which iterates over all direct
   children of <code>feature_node</code> (without <code>feature_node</code> itself).
</p>
<hr>
<a name="gt_feature_node_iterator_next"></a>

<code>GtFeatureNode*          gt_feature_node_iterator_next(GtFeatureNodeIterator
                                                     *feature_node_iterator)</code>
<p>
Return the next <code>GtFeatureNode*</code> in <code>feature_node_iterator</code> or <code>NULL</code> if none
   exists.
</p>
<hr>
<a name="gt_feature_node_iterator_delete"></a>

<code>void                    gt_feature_node_iterator_delete(GtFeatureNodeIterator
                                                       *feature_node_iterator)</code>
<p>
Delete <code>feature_node_iterator</code>.
</p>
<hr>
<a name="GtFeatureOutStream"></a>
<h2>Class GtFeatureOutStream</h2>
<a name="gt_feature_out_stream_new"></a>

<code>GtNodeStream*  gt_feature_out_stream_new(GtNodeStream*, GtFeatureIndex *fi)</code>
<p>
Create a new <code>GtFeatureOutStream</code> which writes all passed nodes to
   <code>GtFeatureIndex</code> <code>fi</code>.
</p>
<hr>
<a name="GtFeatureStream"></a>
<h2>Class GtFeatureStream</h2>
<a name="gt_feature_stream_new"></a>

<code>GtNodeStream*  gt_feature_stream_new(GtNodeStream*, GtFeatureIndex *fi)</code>
<p>
Create a new <code>GtFeatureStream</code> which writes all passed nodes to
   <code>GtFeatureIndex</code> <code>fi</code>. Note: The <code>GtFeatureStream</code> class is now deprecated.
   Please use the <code>GtFeatureOutStream</code> class instead.
</p>
<hr>
<a name="GtFile"></a>
<h2>Class GtFile</h2>

<p> This class defines (generic) files in <em>GenomeTools</em>. A generic file is is a
   file which either uncompressed or compressed (with gzip or bzip2).
   A <code>NULL</code>-pointer as generic file implies <code>stdout</code>. </p>

<hr>
<a name="gt_file_new"></a>

<code>GtFile*  gt_file_new(const char *path, const char *mode, GtError *err)</code>
<p>
Return a new <code>GtFile</code> object for the given <code>path</code> and open the underlying
   file handle with given <code>mode</code>. Returns <code>NULL</code> and sets <code>err</code> accordingly, if
   the file <code>path</code> could not be opened. The compression mode is determined by
   the ending of <code>path</code> (gzip compression if it ends with '.gz', bzip2
   compression if it ends with '.bz2', and uncompressed otherwise).
</p>
<hr>
<a name="gt_file_new_from_fileptr"></a>

<code>GtFile*  gt_file_new_from_fileptr(FILE *fp)</code>
<p>
Create a new <code>GtFile</code> object from a normal file pointer <code>fp</code>.
</p>
<hr>
<a name="gt_file_xprintf"></a>

<code>void     gt_file_xprintf(GtFile *file, const char *format, ...)</code>
<p>
<code>printf(3)</code> for generic <code>file</code>.
</p>
<hr>
<a name="gt_file_xfputs"></a>

<code>void     gt_file_xfputs(const char *cstr, GtFile *file)</code>
<p>
Write <code>\0</code>-terminated C string <code>cstr</code> to <code>file</code>. Similar to <code>fputs(3)</code>, but
   terminates on error.
</p>
<hr>
<a name="gt_file_xfputc"></a>

<code>void     gt_file_xfputc(int c, GtFile *file)</code>
<p>
Write single character <code>c</code> to <code>file</code>. Similar to <code>fputc(3)</code>, but terminates
   on error.
</p>
<hr>
<a name="gt_file_xfgetc"></a>

<code>int      gt_file_xfgetc(GtFile *file)</code>
<p>
Return next character from <code>file</code> or <code>EOF</code>, if end-of-file is reached.
</p>
<hr>
<a name="gt_file_xread"></a>

<code>int      gt_file_xread(GtFile *file, void *buf, size_t nbytes)</code>
<p>
Read up to <code>nbytes</code> from generic <code>file</code> and store result in <code>buf</code>, returns
   bytes read.
</p>
<hr>
<a name="gt_file_xwrite"></a>

<code>void     gt_file_xwrite(GtFile *file, void *buf, size_t nbytes)</code>
<p>
Write <code>nbytes</code> from <code>buf</code> to given generic <code>file</code>.
</p>
<hr>
<a name="gt_file_xrewind"></a>

<code>void     gt_file_xrewind(GtFile *file)</code>
<p>
Rewind the generic <code>file</code>.
</p>
<hr>
<a name="gt_file_delete"></a>

<code>void     gt_file_delete(GtFile *file)</code>
<p>
Close the underlying file handle and destroy the <code>file</code> object.
</p>
<hr>
<a name="gt_file_delete_without_handle"></a>

<code>void     gt_file_delete_without_handle(GtFile*)</code>
<p>
Destroy the file handle object, but do not close the underlying handle.
</p>
<hr>
<a name="GtGFF3InStream"></a>
<h2>Class GtGFF3InStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGFF3InStream</code> parses GFF3 files
   and returns them as a stream of <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_gff3_in_stream_new_unsorted"></a>

<code>GtNodeStream*  gt_gff3_in_stream_new_unsorted(int num_of_files,
                                             const char **filenames)</code>
<p>
Return a <code>GtGFF3InStream</code> object which subsequently reads the <code>num_of_files</code>
   many GFF3 files denoted in <code>filenames</code>. The GFF3 files do not have to be
   sorted. If <code>num_of_files</code> is 0 or a file name is "-", it is read from
   <code>stdin</code>. The memory footprint is O(file size) in the worst-case.
</p>
<hr>
<a name="gt_gff3_in_stream_new_sorted"></a>

<code>GtNodeStream*  gt_gff3_in_stream_new_sorted(const char *filename)</code>
<p>
Create a <code>GtGFF3InStream*</code> which reads the sorted GFF3 file denoted by
   <code>filename</code>. If filename is <code>NULL</code>, it is read from <code>stdin</code>.
   The memory footprint is O(1) on average.
</p>
<hr>
<a name="gt_gff3_in_stream_check_id_attributes"></a>

<code>void           gt_gff3_in_stream_check_id_attributes(GtGFF3InStream
                                                               *gff3_in_stream)</code>
<p>
Make sure all ID attributes which are parsed by <code>gff3_in_stream</code> are correct.
   Increases the memory footprint to O(file size).
</p>
<hr>
<a name="gt_gff3_in_stream_enable_tidy_mode"></a>

<code>void           gt_gff3_in_stream_enable_tidy_mode(GtGFF3InStream
                                                               *gff3_in_stream)</code>
<p>
Enable tidy mode for <code>gff3_in_stream</code>. That is, the GFF3 parser tries to tidy
   up features which would normally lead to an error.
</p>
<hr>
<a name="gt_gff3_in_stream_enable_strict_mode"></a>

<code>void           gt_gff3_in_stream_enable_strict_mode(GtGFF3InStream
                                                               *gff3_in_stream)</code>
<p>
Enable strict mode for <code>gff3_in_stream</code>.
</p>
<hr>
<a name="gt_gff3_in_stream_show_progress_bar"></a>

<code>void           gt_gff3_in_stream_show_progress_bar(GtGFF3InStream
                                                               *gff3_in_stream)</code>
<p>
Show progress bar on <code>stdout</code> to convey the progress of parsing the GFF3
   files underlying <code>gff3_in_stream</code>.
</p>
<hr>
<a name="gt_gff3_in_stream_get_used_types"></a>

<code>GtStrArray*    gt_gff3_in_stream_get_used_types(GtNodeStream *gff3_in_stream)</code>
<p>
Returns a <code>GtStrArray*</code> which contains all type names in alphabetical order
   which have been parsed by <code>gff3_in_stream</code>. The caller is responsible to
   free it!
</p>
<hr>
<a name="gt_gff3_in_stream_set_type_checker"></a>

<code>void           gt_gff3_in_stream_set_type_checker(GtNodeStream *gff3_in_stream,
                                                 GtTypeChecker *type_checker)</code>
<p>
Sets <code>type_checker</code> to be the type checker used in <code>gff3_in_stream</code>. That
   is, it will be queried when the validity of SO types is to be determined.
</p>
<hr>
<a name="GtGFF3OutStream"></a>
<h2>Class GtGFF3OutStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGFF3OutStream</code> produces GFF3
   output.
   It automatically inserts termination lines at the appropriate places. </p>

<hr>
<a name="gt_gff3_out_stream_new"></a>

<code>GtNodeStream*  gt_gff3_out_stream_new(GtNodeStream *in_stream, GtFile *outfp)</code>
<p>
Create a <code>GtGFF3OutStream*</code> which uses <code>in_stream</code> as input.
   It shows the nodes passed through it as GFF3 on <code>outfp</code>.
</p>
<hr>
<a name="gt_gff3_out_stream_set_fasta_width"></a>

<code>void           gt_gff3_out_stream_set_fasta_width(GtGFF3OutStream
                                                 *gff3_out_stream,
                                                 GtUword fasta_width)</code>
<p>
Set the width with which the FASTA sequences of <code>GtSequenceNode</code>s passed
   through <code>gff3_out_stream</code> are shown to <code>fasta_width</code>.
   Per default, each FASTA entry is shown on a single line.
</p>
<hr>
<a name="gt_gff3_out_stream_retain_id_attributes"></a>

<code>void           gt_gff3_out_stream_retain_id_attributes(GtGFF3OutStream
                                                      *gff3_out_stream)</code>
<p>
If this method is called upon <code>gff3_out_stream</code>, use the original ID
   attributes provided in the input (instead of creating new ones, which
   is the default). Memory consumption for <code>gff3_out_stream</code> is raised from O(1)
   to O(<code>input_size</code>), because bookkeeping of used IDs becomes necessary to
   avoid ID collisions.
</p>
<hr>
<a name="GtGFF3Parser"></a>
<h2>Class GtGFF3Parser</h2>

<p> A <code>GtGFF3Parser</code> can be used to parse GFF3 files and convert them into
   <code>GtGenomeNode</code> objects. If the GFF3 files do not contain the encouraged
   sequence-region meta directives, the GFF3 parser introduces the corresponding
   region nodes automatically. This is a low-level class and it is usually not
   used directly. Normally, a <code>GtGFF3InStream</code> is used to parse GFF3 files. </p>

<hr>
<a name="gt_gff3_parser_new"></a>

<code>GtGFF3Parser*  gt_gff3_parser_new(GtTypeChecker *type_checker)</code>
<p>
Return a new <code>GtGFF3Parser</code> object with optional <code>type_checker</code>. If a
   <code>type_checker</code> was given, the <code>GtGFF3Parser</code> stores a new reference to it
   internally and uses the <code>type_checker</code> to check types during parsing.
</p>
<hr>
<a name="gt_gff3_parser_check_id_attributes"></a>

<code>void           gt_gff3_parser_check_id_attributes(GtGFF3Parser *gff3_parser)</code>
<p>
Enable ID attribute checking in <code>gff3_parser</code>. Thereby, the memory
   consumption of the <code>gff3_parser</code> becomes proportional to the input file
   size(s).
</p>
<hr>
<a name="gt_gff3_parser_check_region_boundaries"></a>

<code>void           gt_gff3_parser_check_region_boundaries(GtGFF3Parser *gff3_parser)</code>
<p>
Enable sequence region boundary checking in <code>gff3_parser</code>. That is,
   encountering features outside the sequence region boundaries will result in
   an error.
</p>
<hr>
<a name="gt_gff3_parser_do_not_check_region_boundaries"></a>

<code>void           gt_gff3_parser_do_not_check_region_boundaries(GtGFF3Parser
                                                                  *gff3_parser)</code>
<p>
Disable sequence region boundary checking in <code>gff3_parser</code>. That is,
   features outside the sequence region boundaries will be permitted.
</p>
<hr>
<a name="gt_gff3_parser_set_offset"></a>

<code>void           gt_gff3_parser_set_offset(GtGFF3Parser *gff3_parser,
                                        GtWord offset)</code>
<p>
Transform all features parsed by <code>gff3_parser</code> by the given <code>offset</code>.
</p>
<hr>
<a name="gt_gff3_parser_set_type_checker"></a>

<code>void           gt_gff3_parser_set_type_checker(GtGFF3Parser *gff3_parser,
                                              GtTypeChecker *type_checker)</code>
<p>
Set <code>type_checker</code> used by <code>gff3_parser</code>.
</p>
<hr>
<a name="gt_gff3_parser_set_xrf_checker"></a>

<code>void           gt_gff3_parser_set_xrf_checker(GtGFF3Parser *gff3_parser,
                                             GtXRFChecker *xrf_checker)</code>
<p>
Set <code>xrf_checker</code> used by <code>gff3_parser</code>.
</p>
<hr>
<a name="gt_gff3_parser_enable_tidy_mode"></a>

<code>void           gt_gff3_parser_enable_tidy_mode(GtGFF3Parser *gff3_parser)</code>
<p>
Enable the tidy mode in <code>gff3_parser</code>. In tidy mode the <code>gff3_parser</code> parser
   tries to tidy up features which would normally lead to a parse error.
</p>
<hr>
<a name="gt_gff3_parser_parse_genome_nodes"></a>

<code>int            gt_gff3_parser_parse_genome_nodes(GtGFF3Parser *gff3_parser,
                                                int *status_code,
                                                GtQueue *genome_nodes,
                                                GtCstrTable *used_types,
                                                GtStr *filenamestr,
                                                GtUint64 *line_number,
                                                GtFile *fpin,
                                                GtError *err)</code>
<p>
Use <code>gff3_parser</code> to parse genome nodes from file pointer <code>fpin</code>.
   <code>status_code</code> is set to 0 if at least one genome node was created (and stored
   in <code>genome_nodes</code>) and to <code>EOF</code> if no further genome nodes could be parsed
   from <code>fpin</code>. Every encountered (genome feature) type is recorded in the
   C string table <code>used_types</code>. The parser uses the given <code>filenamestr</code> to
   store the file name of <code>fpin</code> in the created genome nodes or to give the
   correct filename in error messages, if necessary.
   <code>line_number</code> is increased accordingly during parsing and has to be set to 0
   before parsing a new <code>fpin</code>.
   If an error occurs during parsing this method returns -1 and sets <code>err</code>
   accordingly.
</p>
<hr>
<a name="gt_gff3_parser_reset"></a>

<code>void           gt_gff3_parser_reset(GtGFF3Parser *gff3_parser)</code>
<p>
Reset the <code>gff3_parser</code> (necessary if the input file is switched).
</p>
<hr>
<a name="gt_gff3_parser_delete"></a>

<code>void           gt_gff3_parser_delete(GtGFF3Parser *gff3_parser)</code>
<p>
Delete the <code>gff3_parser</code>.
</p>
<hr>
<a name="GtGFF3Visitor"></a>
<h2>Class GtGFF3Visitor</h2>

<p> Implements the <code>GtNodeVisitor</code> interface with a visitor that produces GFF3
   output. This is a low-level class and it is usually not used directly.
   Normally, a <code>GtGFF3OutStream</code> is used to produce GFF3 output. </p>

<hr>
<a name="gt_gff3_visitor_new"></a>

<code>GtNodeVisitor*  gt_gff3_visitor_new(GtFile *outfp)</code>
<p>
Create a new <code>GtNodeVisitor*</code> which writes the output it produces to the
   given output file pointer <code>outfp</code>. If <code>outfp</code> is <code>NULL</code>, the output is
   written to <code>stdout</code>.
</p>
<hr>
<a name="gt_gff3_visitor_set_fasta_width"></a>

<code>void            gt_gff3_visitor_set_fasta_width(GtGFF3Visitor *gff3_visitor,
                                               GtUword fasta_width)</code>
<p>
Set the width with which the FASTA sequences of <code>GtSequenceNode</code>s visited
   by <code>gff3_visitor</code> are shown to <code>fasta_width</code>.
   Per default, each FASTA entry is shown on a single line.
</p>
<hr>
<a name="gt_gff3_visitor_retain_id_attributes"></a>

<code>void            gt_gff3_visitor_retain_id_attributes(GtGFF3Visitor
                                                    *gff3_visitor)</code>
<p>
Retain the original ID attributes (instead of creating new ones), if
   possible.  Memory consumption for <code>gff3_visitor</code> is raised from O(1) to
   O(<code>input_size</code>), because bookkeeping of used IDs becomes necessary to avoid
   ID collisions.
</p>
<hr>
<a name="GtGTFInStream"></a>
<h2>Class GtGTFInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGTFInStream</code> parses a GTF2.2
   file and returns it as a stream of <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_gtf_in_stream_new"></a>

<code>GtNodeStream*  gt_gtf_in_stream_new(const char *filename)</code>
<p>
Create a <code>GtGTFInStream*</code> which subsequently reads the GTF file with the
   given <code>filename</code>. If <code>filename</code> equals <code>NULL</code>, the GTF data is read from
   <code>stdin</code>.
</p>
<hr>
<a name="GtGTFOutStream"></a>
<h2>Class GtGTFOutStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGTFOutStream</code> produces GTF2.2
   output. </p>

<hr>
<a name="gt_gtf_out_stream_new"></a>

<code>GtNodeStream*  gt_gtf_out_stream_new(GtNodeStream *in_stream, GtFile *outfp)</code>
<p>
Create a <code>GtNodeStream*</code> which uses <code>in_stream</code> as input.
   It shows the nodes passed through it as GTF2.2 on <code>outfp</code>.
</p>
<hr>
<a name="GtGenomeNode"></a>
<h2>Class GtGenomeNode</h2>

<p> The <code>GtGenomeNode</code> interface. The different implementation of the
   <code>GtGenomeNode</code> interface represent different parts of genome annotations (as
   they are usually found in GFF3 files). </p>

<hr>
<a name="gt_genome_node_ref"></a>

<code>GtGenomeNode*  gt_genome_node_ref(GtGenomeNode *genome_node)</code>
<p>
Increase the reference count for <code>genome_node</code> and return it.
   <code>genome_node</code> cannot be <code>NULL</code>.
</p>
<hr>
<a name="gt_genome_node_get_seqid"></a>

<code>GtStr*         gt_genome_node_get_seqid(GtGenomeNode *genome_node)</code>
<p>
Return the sequence ID of <code>genome_node</code>.
   Corresponds to column 1 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_range"></a>

<code>GtRange        gt_genome_node_get_range(GtGenomeNode *genome_node)</code>
<p>
Return the genomic range of of <code>genome_node</code>.
   Corresponds to columns 4 and 5 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_start"></a>

<code>GtUword  gt_genome_node_get_start(GtGenomeNode *genome_node)</code>
<p>
Return the start of <code>genome_node</code>.
   Corresponds to column 4 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_end"></a>

<code>GtUword  gt_genome_node_get_end(GtGenomeNode *genome_node)</code>
<p>
Return the end of <code>genome_node</code>.
   Corresponds to column 5 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_length"></a>

<code>GtUword  gt_genome_node_get_length(GtGenomeNode *genome_node)</code>
<p>
Return the length of <code>genome_node</code>.
   Computed from column 4 and 5 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_filename"></a>

<code>const char*    gt_genome_node_get_filename(const GtGenomeNode* genome_node)</code>
<p>
Return the filename the <code>genome_node</code> was read from.
   If the node did not originate from a file, an appropriate string is
   returned.
</p>
<hr>
<a name="gt_genome_node_get_line_number"></a>

<code>unsigned int   gt_genome_node_get_line_number(const GtGenomeNode*)</code>
<p>
Return the line of the source file the <code>genome_node</code> was encountered on
   (if the node was read from a file, otherwise 0 is returned).
</p>
<hr>
<a name="gt_genome_node_set_range"></a>

<code>void           gt_genome_node_set_range(GtGenomeNode *genome_node,
                                       const GtRange *range)</code>
<p>
Set the genomic range of <code>genome_node</code> to given <code>range</code>.
</p>
<hr>
<a name="gt_genome_node_add_user_data"></a>

<code>void           gt_genome_node_add_user_data(GtGenomeNode *genome_node,
                                           const char *key, void *data,
                                           GtFree free_func)</code>
<p>
Attach a pointer to <code>data</code> to the <code>genome_node</code> using a given string as
   <code>key</code>. <code>free_func</code> is the optional destructor for <code>data</code>.
</p>
<hr>
<a name="gt_genome_node_get_user_data"></a>

<code>void*          gt_genome_node_get_user_data(const GtGenomeNode *genome_node,
                                           const char *key)</code>
<p>
Return the pointer attached to the <code>genome_node</code> for a given <code>key</code>.
</p>
<hr>
<a name="gt_genome_node_release_user_data"></a>

<code>void           gt_genome_node_release_user_data(GtGenomeNode *genome_node,
                                               const char *key)</code>
<p>
Call the destructor function associated with the user data attached to
   <code>genome_node</code> under the <code>key</code> on the attached data.
</p>
<hr>
<a name="gt_genome_node_cmp"></a>

<code>int            gt_genome_node_cmp(GtGenomeNode *genome_node_a,
                                 GtGenomeNode *genome_node_b)</code>
<p>
Compare <code>genome_node_a</code> with <code>genome_node_b</code> and return the result (similar
   to <code>strcmp(3)</code>). This method is the criterion used to sort genome nodes.
</p>
<hr>
<a name="gt_genome_nodes_sort"></a>

<code>void           gt_genome_nodes_sort(GtArray *nodes)</code>
<p>
Sort node array <code>nodes</code>
</p>
<hr>
<a name="gt_genome_nodes_sort_stable"></a>

<code>void           gt_genome_nodes_sort_stable(GtArray *nodes)</code>
<p>
Sort node array <code>nodes</code> in a stable way
</p>
<hr>
<a name="gt_genome_node_accept"></a>

<code>int            gt_genome_node_accept(GtGenomeNode *genome_node,
                                    GtNodeVisitor *node_visitor, GtError *err)</code>
<p>
Let <code>genome_node</code> accept the <code>node_visitor</code>.
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_genome_node_delete"></a>

<code>void           gt_genome_node_delete(GtGenomeNode *genome_node)</code>
<p>
Decrease the reference count for <code>genome_node</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtGraphics"></a>
<h2>Class GtGraphics</h2>

<p> The <code>GtGraphics</code> interface acts as a low-level abstraction of a drawing
   surface. It is used as a common drawing object in <code>GtCanvas</code> and
   <code>GtCustomTrack</code> implementations and supports a variety of drawing operations
   for both text and basic primitive shapes. </p>

<hr>
<a name="gt_graphics_draw_text"></a>

<code>void    gt_graphics_draw_text(GtGraphics*, double x, double y, const char*)</code>
<p>
Draws text in black to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as
   a baseline.
</p>
<hr>
<a name="gt_graphics_draw_text_clip"></a>

<code>void    gt_graphics_draw_text_clip(GtGraphics*, double x, double y, const char*)</code>
<p>
Draws text in black to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as
   a baseline. If the text exceeds the margins, it is clipped.
</p>
<hr>
<a name="gt_graphics_draw_text_left"></a>

<code>#define gt_graphics_draw_text_left(g,x,y,t)</code>
<p>
Synonym to <code>gt_graphics_draw_text()</code>
</p>
<hr>
<a name="gt_graphics_draw_text_centered"></a>

<code>void    gt_graphics_draw_text_centered(GtGraphics*, double x, double y,
                                      const char*)</code>
<p>
Draws text in black centered at (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as a
   baseline.
</p>
<hr>
<a name="gt_graphics_draw_text_right"></a>

<code>void    gt_graphics_draw_text_right(GtGraphics*, double x, double y,
                                   const char*)</code>
<p>
Draws text in black to the left of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as a
   baseline.
</p>
<hr>
<a name="gt_graphics_draw_colored_text"></a>

<code>void    gt_graphics_draw_colored_text(GtGraphics*, double x, double y,
                                     GtColor, const char*)</code>
<p>
Draws text in a given <code>GtColor</code> to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code>
   is used as a baseline.
</p>
<hr>
<a name="gt_graphics_get_text_height"></a>

<code>double  gt_graphics_get_text_height(GtGraphics*)</code>
<p>
Returns the height of a capital letter in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_background_color"></a>

<code>int  gt_graphics_set_background_color(GtGraphics*, GtColor)</code>
<p>
Sets the background color of the <code>GtGraphics</code> to a specific color.
   Note that this may only be supported for bitmap output formats.
</p>
<hr>
<a name="gt_graphics_get_text_width"></a>

<code>double  gt_graphics_get_text_width(GtGraphics*, const char *text)</code>
<p>
Returns the width of the given string in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_font"></a>

<code>void    gt_graphics_set_font(GtGraphics *g, const char *family,
                            FontSlant slant, FontWeight weight, double size)</code>
<p>
Sets basic font family, slant and weight options. Font families are
   implementation-specific, e.g. in Cairo there is no operation to list
   available family names on the system, but the standard CSS2 generic family
   names, ("serif", "sans-serif", "cursive", "fantasy", "monospace"), are
   likely to work as expected.
</p>
<hr>
<a name="gt_graphics_get_image_width"></a>

<code>double  gt_graphics_get_image_width(GtGraphics*)</code>
<p>
Returns the width of the image in pixels/points.
</p>
<hr>
<a name="gt_graphics_get_image_height"></a>

<code>double  gt_graphics_get_image_height(GtGraphics*)</code>
<p>
Returns the height of the image in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_margins"></a>

<code>void    gt_graphics_set_margins(GtGraphics*, double margin_x,
                                  double margin_y)</code>
<p>
Set margins (space to the image boundaries that are clear of elements)
   in the graphics.
   <code>margin_x</code> denotes the Margin to the left and right, in pixels.
   <code>margin_y</code> denotes the Margin to the top and bottom, in pixels.
</p>
<hr>
<a name="gt_graphics_get_xmargins"></a>

<code>double  gt_graphics_get_xmargins(GtGraphics*)</code>
<p>
Returns the horizontal margins in pixels/points.
</p>
<hr>
<a name="gt_graphics_get_ymargins"></a>

<code>double  gt_graphics_get_ymargins(GtGraphics*)</code>
<p>
Returns the vertical margins in pixels/points.
</p>
<hr>
<a name="gt_graphics_draw_horizontal_line"></a>

<code>void    gt_graphics_draw_horizontal_line(GtGraphics *g, double x, double y,
                                        GtColor color, double width,
                                        double stroke_width)</code>
<p>
Draws a horizontal line of length <code>width</code> beginning at the given coordinates
   to the right in the color <code>color</code> with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_vertical_line"></a>

<code>void    gt_graphics_draw_vertical_line(GtGraphics *g, double x, double y,
                                      GtColor color, double length,
                                      double stroke_width)</code>
<p>
Draws a vertical line of length <code>length</code> beginning at the given coordinates
   downwards in the color <code>color</code> with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_line"></a>

<code>void    gt_graphics_draw_line(GtGraphics *g, double x, double y,
                             double xto, double yto, GtColor color,
                             double stroke_width)</code>
<p>
Draws a line beginning at (<code>x</code>,<code>y</code>) to (<code>xto</code>,<code>yto</code>) in the color <code>color</code>
   with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_box"></a>

<code>void    gt_graphics_draw_box(GtGraphics*, double x, double y, double width,
                            double height, GtColor fill_color,
                            ArrowStatus arrow_status, double arrow_width,
                            double stroke_width, GtColor stroke_color,
                            bool dashed)</code>
<p>
Draws a arrow-like box glyph at (<code>x</code>,<code>y</code>) where these are the top left
   coordinates. The box extends <code>width</code> pixels (incl. arrowhead) into the x
   direction and <code>height</code> pixels into the y direction. It will be filled with
   <code>fill_color</code> and stroked with width <code>stroke_width</code> and color <code>stroke_color</code>.
   The width of the arrowhead is given by the <code>arrow_width</code> parameter.
   The <code>arrow_status</code> parameter determines whether an arrowhead will be drawn
   at the left or right end, both ends, or none.
   If <code>dashed</code> is set to true, then the outline will be dashed instead of
   solid.
</p>
<hr>
<a name="gt_graphics_draw_dashes"></a>

<code>void    gt_graphics_draw_dashes(GtGraphics*, double x, double y,
                                  double width, double height,
                                  ArrowStatus arrow_status, double arrow_width,
                                  double stroke_width, GtColor stroke_color)</code>
<p>
Draws a transparent box with a dashed line at the center at (<code>x</code>,<code>y</code>)
   (where these are the top left coordinates). The box extends <code>width</code> pixels
   (incl. arrowhead) into the x direction and <code>height</code> pixels into the y
   direction. It will be stroked with width <code>stroke_width</code> and color
   <code>stroke_color</code>. The width of the arrowhead is given by the <code>arrow_width</code>
   parameter. The <code>arrow_status</code> parameter determines whether an arrowhead will
   be drawn at the left or right end, both ends, or none.
</p>
<hr>
<a name="gt_graphics_draw_caret"></a>

<code>void    gt_graphics_draw_caret(GtGraphics*, double x, double y, double width,
                              double height, ArrowStatus arrow_status,
                              double arrow_width,  double stroke_width,
                              GtColor stroke_color)</code>
<p>
Draws a caret (``hat'') style glyph at (<code>x</code>,<code>y</code>) (where these are the top
   left coordinates). The box extends <code>width</code> pixels (incl. arrowhead) into the
   x direction and <code>height</code> pixels into the y direction. It will be stroked
   with width <code>stroke_width</code> and color <code>stroke_color</code>. The width of the
   arrowhead is given by the <code>arrow_width</code> parameter. The <code>arrow_status</code>
   parameter determines whether an arrowhead will be drawn at the left or right
   end, both ends, or none.
</p>
<hr>
<a name="gt_graphics_draw_rectangle"></a>

<code>void    gt_graphics_draw_rectangle(GtGraphics*, double x, double y,
                                  bool filled, GtColor fill_color,
                                  bool stroked, GtColor stroke_color,
                                  double stroke_width, double width,
                                  double height)</code>
<p>
Draws a rectangle at (<code>x</code>,<code>y</code>) where these are the top left coordinates.
   The rectangle extends <code>width</code> pixels (incl. arrowhead) into the x
   direction and <code>height</code> pixels into the y direction. It will be filled with
   <code>fill_color</code> if <code>filled</code> is set to true and stroked with width <code>stroke_width</code>
   and color <code>stroke_color</code> if <code>stroked</code> is set to true.
</p>
<hr>
<a name="gt_graphics_draw_arrowhead"></a>

<code>void    gt_graphics_draw_arrowhead(GtGraphics*, double x, double y, GtColor,
                                  ArrowStatus arrow_status)</code>
<p>
Draws an arrowhead at (<code>x</code>,<code>y</code>) where these are the top left coordinates.
   The direction is determined by the <code>arrow_status</code> parameter.
</p>
<hr>
<a name="gt_graphics_draw_curve_data"></a>

<code>void    gt_graphics_draw_curve_data(GtGraphics *g, double x, double y,
                                   GtColor color,
                                   double data[], GtUword ndata,
                                   GtRange valrange, GtUword height)</code>
<p>
Draws a curve over the full visible image width (without margins) at
   (<code>x</code>,<code>y</code>) where these are the top left coordinates. As input, the array of
   double values <code>data</code> with <code>ndata</code> data points is used. The <code>valrange</code> gives
   the minimum and maximum value of the displayed data. If a value outside the
   data range is encountered, the drawing will be stopped at this data point.
</p>
<hr>
<a name="gt_graphics_save_to_file"></a>

<code>int     gt_graphics_save_to_file(const GtGraphics*, const char *filename,
                                GtError*)</code>
<p>
Write out the <code>GtGraphics</code> object to the given file with <code>filename</code>.
</p>
<hr>
<a name="gt_graphics_save_to_stream"></a>

<code>void    gt_graphics_save_to_stream(const GtGraphics*, GtStr *stream)</code>
<p>
Write out the <code>GtGraphics</code> object to the given <code>stream</code>.
</p>
<hr>
<a name="gt_graphics_delete"></a>

<code>void    gt_graphics_delete(GtGraphics*)</code>
<p>
Deletes the the <code>GtGraphics</code> object.
</p>
<hr>
<a name="GtGraphicsCairo"></a>
<h2>Class GtGraphicsCairo</h2>

<p> Implements the <code>GtGraphics</code> interface.
   This implementation uses the Cairo 2D vector graphics library as a
   drawing back-end. </p>

<hr>
<a name="gt_graphics_cairo_new"></a>

<code>GtGraphics*   gt_graphics_cairo_new(GtGraphicsOutType type, unsigned int width,
                                   unsigned int height)</code>
<p>
Creates a new <code>GtGraphics</code> object using the Cairo backend. The object
   is meant for writing a new image of width <code>width</code> and height <code>height</code>
   to a file or stream. Use <code>type</code> to define the output format.
</p>
<hr>
<a name="gt_graphics_cairo_new_from_context"></a>

<code>GtGraphics*   gt_graphics_cairo_new_from_context(cairo_t *context,
                                                unsigned int width,
                                                unsigned int height)</code>
<p>
Creates a new <code>GtGraphics</code> object using the Cairo backend. The object
   is meant for writing on an existing cairo_t <code>context</code> within the boundaries
   of width <code>width</code> and height <code>height</code>.
</p>
<hr>
<a name="gt_graphics_cairo_draw_curve_data"></a>

<code>void          gt_graphics_cairo_draw_curve_data(GtGraphics *gg,
                                               double x, double y,
                                               GtColor color, double data[],
                                               GtUword ndata, GtRange valrange,
                                               GtUword height)</code>
<p>
Draws a curve in <code>gg</code> at the position <code>x</code>,<code>y</code> for <code>ndata</code> data points as
   given in <code>data</code>. The data points must be in the range <code>valrange</code> and the
   resulting graph has the height <code>height</code> in type-dependent units
   (e.g. pixels).
</p>
<hr>
<a name="GtHashmap"></a>
<h2>Class GtHashmap</h2>

<p> A hashmap allowing to index any kind of pointer (as a value). As keys,
   strings or any other pointer can be used. </p>

<hr>
<a name="GtHashmapVisitFunc"></a>

<code>int  GtHashmapVisitFunc(void *key, void *value, void *data,
                                  GtError *err)</code>
<p>
Callback function when using the gt_hashmap_foreach*() functions.
   Must return a status code (0 = continue iteration, 1 = stop iteration,
   2 = deleted element, 3 = modified key, 4 = redo iteration).
   Gets called with the key and value of the current hashmap member, and the
   <code>err</code> object given in the original gt_hashmap_foreach*() call.
</p>
<hr>
<a name="gt_hashmap_new"></a>

<code>GtHashmap*  gt_hashmap_new(GtHashType keyhashtype, GtFree keyfree,
                          GtFree valuefree)</code>
<p>
Creates a new <code>GtHashmap</code> object of type <code>keyhashtype</code>. If <code>keyfree</code> and/or
   <code>valuefree</code> are given, they will be used to free the hashmap members
   when the <code>GtHashmap</code> is deleted. <code>keyhashtype</code> defines how to hash the
   keys given when using the <code>GtHashmap</code>.
   <code>GT_HASH_DIRECT</code> uses the key pointer as a basis for the hash function.
   Equal pointers will refer to the same value. If <code>GT_HASH_STRING</code> is used, the
   keys will be  evaluated as strings and keys will be considered equal if the
   strings are identical, regardless of their address in memory
</p>
<hr>
<a name="gt_hashmap_ref"></a>

<code>GtHashmap*  gt_hashmap_ref(GtHashmap *hm)</code>
<p>
Increase the reference count of <code>hm</code>.
</p>
<hr>
<a name="gt_hashmap_get"></a>

<code>void*       gt_hashmap_get(GtHashmap *hashmap, const void *key)</code>
<p>
Return the value stored in <code>hashmap</code> for <code>key</code> or <code>NULL</code> if no such key
   exists.
</p>
<hr>
<a name="gt_hashmap_add"></a>

<code>void        gt_hashmap_add(GtHashmap *hashmap, void *key, void *value)</code>
<p>
Set the value stored in <code>hashmap</code> for <code>key</code> to <code>value</code>, overwriting the prior
   value for that key if present.
</p>
<hr>
<a name="gt_hashmap_remove"></a>

<code>void        gt_hashmap_remove(GtHashmap *hashmap, const void *key)</code>
<p>
Remove the member with key <code>key</code> from <code>hashmap</code>.
</p>
<hr>
<a name="gt_hashmap_foreach_ordered"></a>

<code>int         gt_hashmap_foreach_ordered(GtHashmap *hashmap,
                                      GtHashmapVisitFunc func,
                                      void *data, GtCompare cmp, GtError *err)</code>
<p>
Iterate over <code>hashmap</code> in order given by compare function <code>cmp</code>.
   For each member, <code>func</code> is called (see interface).
</p>
<hr>
<a name="gt_hashmap_foreach"></a>

<code>int         gt_hashmap_foreach(GtHashmap *hashmap, GtHashmapVisitFunc func,
                              void *data, GtError *err)</code>
<p>
Iterate over <code>hashmap</code> in arbitrary order.
   For each member, <code>func</code> is called (see interface).
</p>
<hr>
<a name="gt_hashmap_foreach_in_key_order"></a>

<code>int         gt_hashmap_foreach_in_key_order(GtHashmap *hashmap,
                                           GtHashmapVisitFunc func,
                                           void *data, GtError *err)</code>
<p>
Iterate over <code>hashmap</code> in either alphabetical order (if <code>GtHashType</code> was
   specified as <code>GT_HASH_STRING</code>) or numerical order (if <code>GtHashType</code> was
   specified as <code>GT_HASH_DIRECT</code>).
</p>
<hr>
<a name="gt_hashmap_reset"></a>

<code>void        gt_hashmap_reset(GtHashmap *hashmap)</code>
<p>
Reset <code>hashmap</code> by unsetting values for all keys, calling the free function
   if necessary.
</p>
<hr>
<a name="gt_hashmap_delete"></a>

<code>void        gt_hashmap_delete(GtHashmap *hashmap)</code>
<p>
Delete <code>hashmap</code>, calling the free function if necessary.
</p>
<hr>
<a name="GtIDToMD5Stream"></a>
<h2>Class GtIDToMD5Stream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtIDToMD5Stream</code> converts
   ``regular'' sequence IDs to MD5 fingerprints. </p>

<hr>
<a name="gt_id_to_md5_stream_new"></a>

<code>GtNodeStream*  gt_id_to_md5_stream_new(GtNodeStream *in_stream,
                                      GtRegionMapping *region_mapping,
                                      bool substitute_target_ids)</code>
<p>
Create a <code>GtIDToMD5Stream</code> object which converts ``regular'' sequence IDs
   from nodes it retrieves from its <code>in_stream</code> to MD5 fingerprints (with the
   help of the given <code>region_mapping</code>). If <code>substitute_target_ids</code> is true, the
   IDs of Target attributes are also converted to MD5 fingerprints.
   Takes ownership of <code>region_mapping</code>!
</p>
<hr>
<a name="GtImageInfo"></a>
<h2>Class GtImageInfo</h2>

<p> The <code>GtImageInfo</code> class is a container for 2D coordinate to <code>GtFeatureNode</code>
   mappings which could, for example, be used to associate sections of a
   rendered image with GUI widgets or HTML imagemap areas. This information is
   given in the form of <code>GtRecMap</code> objects. They are created during the
   image rendering process and stored inside a <code>GtImageInfo</code> object for later
   retrieval. Additionally, the rendered width of an image can be obtained via
   a <code>GtImageInfo</code> method. </p>

<hr>
<a name="gt_image_info_new"></a>

<code>GtImageInfo*      gt_image_info_new(void)</code>
<p>
Creates a new <code>GtImageInfo</code> object.
</p>
<hr>
<a name="gt_image_info_get_height"></a>

<code>unsigned int      gt_image_info_get_height(GtImageInfo *image_info)</code>
<p>
Returns the height of the rendered image (in pixels or points).
</p>
<hr>
<a name="gt_image_info_num_of_rec_maps"></a>

<code>GtUword     gt_image_info_num_of_rec_maps(GtImageInfo *image_info)</code>
<p>
Returns the total number of mappings in <code>image_info</code>.
</p>
<hr>
<a name="gt_image_info_get_rec_map"></a>

<code>const GtRecMap*   gt_image_info_get_rec_map(GtImageInfo *image_info,
                                           GtUword i)</code>
<p>
Returns the <code>i</code>-th <code>GtRecMap</code> mapping in <code>image_info</code>.
</p>
<hr>
<a name="gt_image_info_delete"></a>

<code>void              gt_image_info_delete(GtImageInfo *image_info)</code>
<p>
Deletes <code>image_info</code> and all the <code>GtRecMap</code> objects created by it.
</p>
<hr>
<a name="GtInterFeatureStream"></a>
<h2>Class GtInterFeatureStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtInterFeatureStream</code> inserts new
   feature nodes between existing feature nodes of a certain type. </p>

<hr>
<a name="gt_inter_feature_stream_new"></a>

<code>GtNodeStream*  gt_inter_feature_stream_new(GtNodeStream *in_stream,
                                          const char *outside_type,
                                          const char *inter_type)</code>
<p>
Create a <code>GtInterFeatureStream*</code> which inserts feature nodes of type
   <code>inter_type</code> between the feature nodes of type <code>outside_type</code> it retrieves
   from <code>in_stream</code> and returns them.
</p>
<hr>
<a name="GtIntervalTree"></a>
<h2>Class GtIntervalTree</h2>

<p> This is an interval tree data structure, implemented according to
   Cormen et al., Introduction to Algorithms, 2nd edition, MIT Press,
   Cambridge, MA, USA, 2001 </p>

<hr>
<a name="gt_interval_tree_new"></a>

<code>GtIntervalTree*      gt_interval_tree_new(GtFree)</code>
<p>
Creates a new <code>GtIntervalTree</code>. If a <code>GtFree</code> function is given as an
   argument, it is applied on the data pointers in all inserted nodes when the
   <code>GtIntervalTree</code> is deleted.
</p>
<hr>
<a name="gt_interval_tree_size"></a>

<code>GtUword        gt_interval_tree_size(GtIntervalTree*)</code>
<p>
Returns the number of elements in the <code>GtIntervalTree</code>.
</p>
<hr>
<a name="gt_interval_tree_find_first_overlapping"></a>

<code>GtIntervalTreeNode*  gt_interval_tree_find_first_overlapping(GtIntervalTree*,
                                                            GtUword start,
                                                            GtUword end)</code>
<p>
Returns the first node in the <code>GtIntervalTree</code> which overlaps the given
   range (from <code>start</code> to <code>end</code>).
</p>
<hr>
<a name="gt_interval_tree_insert"></a>

<code>void                 gt_interval_tree_insert(GtIntervalTree *tree,
                                            GtIntervalTreeNode *node)</code>
<p>
Inserts node <code>node</code> into <code>tree</code>.
</p>
<hr>
<a name="gt_interval_tree_find_all_overlapping"></a>

<code>void                 gt_interval_tree_find_all_overlapping(GtIntervalTree*,
                                                          GtUword start,
                                                          GtUword end,
                                                          GtArray*)</code>
<p>
Collects data pointers of all <code>GtIntervalTreeNode</code>s in the tree which
   overlap with the query range (from <code>start</code> to <code>end</code>) in a <code>GtArray</code>.
</p>
<hr>
<a name="gt_interval_tree_iterate_overlapping"></a>

<code>void                 gt_interval_tree_iterate_overlapping(GtIntervalTree *it,
                                                GtIntervalTreeIteratorFunc func,
                                                GtUword start,
                                                GtUword end,
                                                void *data)</code>
<p>
Call <code>func</code> for all <code>GtIntervalTreeNode</code>s in the tree which overlap with
   the query range (from <code>start</code> to <code>end</code>). Use <code>data</code> to pass in arbitrary
   user data.
</p>
<hr>
<a name="gt_interval_tree_traverse"></a>

<code>int                  gt_interval_tree_traverse(GtIntervalTree*,
                                              GtIntervalTreeIteratorFunc func,
                                              void *data)</code>
<p>
Traverses the <code>GtIntervalTree</code> in a depth-first fashion, applying <code>func</code> to
   each node encountered. The <code>data</code> pointer can be used to reference arbitrary
   data needed in the <code>GtIntervalTreeIteratorFunc</code>.
</p>
<hr>
<a name="gt_interval_tree_remove"></a>

<code>void                 gt_interval_tree_remove(GtIntervalTree*,
                                            GtIntervalTreeNode *node)</code>
<p>
Removes the entry referenced by <code>node</code> from the <code>GtIntervalTree</code>.
   The data attached to <code>node</code> is freed according to the free function defined
   in the tree.
   Note that the memory pointed to by <code>node</code> can be re-used internally,
   referencing other data in the tree. Make sure to handle this pointer as
   expired after calling <code>gt_interval_tree_remove()</code>!
</p>
<hr>
<a name="gt_interval_tree_delete"></a>

<code>void                 gt_interval_tree_delete(GtIntervalTree*)</code>
<p>
Deletes a <code>GtIntervalTree</code>. If a <code>GtFree</code> function was set in the tree
   constructor, data pointers specified in the nodes are freed using the given
   <code>GtFree</code> function.
</p>
<hr>
<a name="GtIntervalTreeNode"></a>
<h2>Class GtIntervalTreeNode</h2>
<a name="gt_interval_tree_node_new"></a>

<code>GtIntervalTreeNode*  gt_interval_tree_node_new(void *data,
                                              GtUword low,
                                              GtUword high)</code>
<p>
Creates a new <code>GtIntervalTreeNode</code>. Transfers ownership of <code>data</code> to interval
   tree if inserted into a <code>GtIntervalTree</code> in which a
   <code>GtIntervalTreeDataFreeFunc</code> is set.
</p>
<hr>
<a name="gt_interval_tree_node_get_data"></a>

<code>void*                gt_interval_tree_node_get_data(GtIntervalTreeNode* node)</code>
<p>
Returns a pointer to the data associated with node <code>node</code>.
</p>
<hr>
<a name="GtLayout"></a>
<h2>Class GtLayout</h2>

<p> The <code>GtLayout</code> class represents contents (tracks) of a <code>GtDiagram</code> broken up
   into lines such that a given horizontal space allotment given in pixels
   or points is used up most efficiently. This is done using the <code>GtLineBreaker</code>
   and <code>GtTextWidthCalculator</code> classes. As defaults, Cairo-based instances of
   these classes are used but can be specified separately.</p><p>   A <code>GtLayout</code> can be queried for the height of the laid out representation and
   finally be rendered to a <code>GtCanvas</code>. </p>

<hr>
<a name="gt_layout_new"></a>

<code>GtLayout*      gt_layout_new(GtDiagram *diagram, unsigned int width, GtStyle*,
                            GtError*)</code>
<p>
Creates a new <code>GtLayout</code> object for the contents of <code>diagram</code>.
   The layout is done for a target image width of <code>width</code> and using the rules in
   <code>GtStyle</code> object <code>style</code>.
</p>
<hr>
<a name="gt_layout_new_with_twc"></a>

<code>GtLayout*      gt_layout_new_with_twc(GtDiagram*,
                                     unsigned int width,
                                     GtStyle*,
                                     GtTextWidthCalculator*,
                                     GtError*)</code>
<p>
Like <code>gt_layout_new()</code>, but allows use of a different <code>GtTextWidthCalculator</code>
   implementation.
</p>
<hr>
<a name="gt_layout_set_track_ordering_func"></a>

<code>void           gt_layout_set_track_ordering_func(GtLayout *layout,
                                                GtTrackOrderingFunc func,
                                                void *data)</code>
<p>
Sets the <code>GtTrackOrderingFunc</code> comparator function <code>func</code> which defines an
   order on the tracks contained in <code>layout</code>. This determines the order in
   which the tracks are drawn vertically.
   Additional data necessary in the comparator function can be given in <code>data</code>,
   the caller is responsible to free it.
</p>
<hr>
<a name="gt_layout_get_height"></a>

<code>int            gt_layout_get_height(GtLayout *layout,
                                   GtUword *result,
                                   GtError *err)</code>
<p>
Calculates the height of <code>layout</code> in pixels. The height value is written to
   the location pointed to by <code>result</code>. If an error occurs during the
   calculation, this function returns -1 and <code>err</code> is set accordingly.
   Returns 0 on success.
</p>
<hr>
<a name="gt_layout_sketch"></a>

<code>int            gt_layout_sketch(GtLayout *layout, GtCanvas *target_canvas,
                               GtError*)</code>
<p>
Renders <code>layout</code> on the <code>target_canvas</code>.
</p>
<hr>
<a name="gt_layout_delete"></a>

<code>void           gt_layout_delete(GtLayout*)</code>
<p>
Destroys a layout.
</p>
<hr>
<a name="GtLogger"></a>
<h2>Class GtLogger</h2>
<a name="gt_logger_new"></a>

<code>GtLogger*  gt_logger_new(bool enabled, const char *prefix, FILE *target)</code>
<p>
Creates a new <code>GtLogger</code>, with logging <code>enabled</code> or not,
   and prefixing all log entries with <code>prefix</code> (e.g. "debug").
   The log output is terminated by a newline. All log output will
   be written to <code>target</code>.
</p>
<hr>
<a name="gt_logger_enable"></a>

<code>void       gt_logger_enable(GtLogger *logger)</code>
<p>
Enable logging on <code>logger</code>.
</p>
<hr>
<a name="gt_logger_disable"></a>

<code>void       gt_logger_disable(GtLogger *logger)</code>
<p>
Disable logging on <code>logger</code>.
</p>
<hr>
<a name="gt_logger_enabled"></a>

<code>bool       gt_logger_enabled(GtLogger *logger)</code>
<p>
Return <code>true</code> if logging is enabled on <code>logger</code>, false otherwise.
</p>
<hr>
<a name="gt_logger_target"></a>

<code>FILE*      gt_logger_target(GtLogger *logger)</code>
<p>
Return logging target of <code>logger</code>.
</p>
<hr>
<a name="gt_logger_set_target"></a>

<code>void       gt_logger_set_target(GtLogger *logger, FILE *fp)</code>
<p>
Set logging target of <code>logger</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_logger_log_force"></a>

<code>void       gt_logger_log_force(GtLogger *logger, const char *format, ...)</code>
<p>
Log to target regardless of logging status.
</p>
<hr>
<a name="gt_logger_log"></a>

<code>void       gt_logger_log(GtLogger *logger, const char *format, ...)</code>
<p>
Log to target depending on logging status.
</p>
<hr>
<a name="gt_logger_log_va_force"></a>

<code>void       gt_logger_log_va_force(GtLogger *logger, const char *format, va_list)</code>
<p>
Log to target regardless of logging status, using a va_list argument.
</p>
<hr>
<a name="gt_logger_log_va"></a>

<code>void       gt_logger_log_va(GtLogger *logger, const char *format, va_list)</code>
<p>
Log to target depending on logging status, using a va_list argument.
</p>
<hr>
<a name="gt_logger_delete"></a>

<code>void       gt_logger_delete(GtLogger *logger)</code>
<p>
Delete <code>logger</code>.
</p>
<hr>
<a name="GtMD5Encoder"></a>
<h2>Class GtMD5Encoder</h2>

<p> The <code>GtMD5Encoder</code> class implements a stateful encoder for MD5 hashes
   for strings build by iterative addition of blocks. </p>

<hr>
<a name="gt_md5_encoder_new"></a>

<code>GtMD5Encoder*  gt_md5_encoder_new(void)</code>
<p>
Returns a new <code>GtMD5Encoder</code> object.
</p>
<hr>
<a name="gt_md5_encoder_add_block"></a>

<code>void           gt_md5_encoder_add_block(GtMD5Encoder *enc, const char *message,
                                       GtUword len)</code>
<p>
Processes <code>message</code> of length <code>len</code> (max. block length 64 bytes) to be
   incorporated in the hash currently represented by <code>enc</code>.
</p>
<hr>
<a name="gt_md5_encoder_finish"></a>

<code>void           gt_md5_encoder_finish(GtMD5Encoder *enc, unsigned char *output,
                                    char *outstr)</code>
<p>
Finishes <code>enc</code> to produce the final MD5 value, written to the 16-byte array
   <code>output</code>. If <code>outstr</code> is not NULL, a \0-terminated string representation of
   the hash will be written to the 32-byte string buffer it points to.
</p>
<hr>
<a name="gt_md5_encoder_reset"></a>

<code>void           gt_md5_encoder_reset(GtMD5Encoder *enc)</code>
<p>
Discards the current state of <code>enc</code> and resets it to represent the MD5 hash
   of the empty string.
</p>
<hr>
<a name="gt_md5_encoder_delete"></a>

<code>void           gt_md5_encoder_delete(GtMD5Encoder *enc)</code>
<p>
Deletes <code>enc</code> and frees all associated space.
</p>
<hr>
<a name="GtMD5ToIDStream"></a>
<h2>Class GtMD5ToIDStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtMD5ToIDStream</code> converts MD5
   fingerprints used as sequence IDs to ``regular'' ones. </p>

<hr>
<a name="gt_md5_to_id_stream_new"></a>

<code>GtNodeStream*  gt_md5_to_id_stream_new(GtNodeStream *in_stream,
                                      GtRegionMapping *region_mapping)</code>
<p>
Create a <code>GtMD5toIDStream*</code> which converts MD5 sequence IDs from nodes it
   retrieves from its <code>in_stream</code> to ``regular'' ones (with the help of the
   given <code>region_mapping</code>). Takes ownership of <code>region_mapping</code>!
</p>
<hr>
<a name="GtMatch"></a>
<h2>Class GtMatch</h2>

<p> The <code>GtMatch</code> interface defines a generic set of functions for a data
   structure designed to hold matches, that is, two similar locations on two
   sequences which are further described by additional data specific to the
   matching engine. Matches have a direction, e.g. direct or reverse
   (palindromic). </p>

<hr>
<a name="gt_match_set_seqid1"></a>

<code>void              gt_match_set_seqid1(GtMatch *match, const char *seqid)</code>
<p>
Sets the sequence ID of the first sequence involved in the match <code>match</code> to
   <code>seqid</code>. The string <code>seqid</code> must be null-terminated.
</p>
<hr>
<a name="gt_match_set_seqid1_nt"></a>

<code>void              gt_match_set_seqid1_nt(GtMatch *match, const char *seqid,
                                        GtUword len)</code>
<p>
Sets the sequence ID of the first sequence involved in the match <code>match</code> to
   <code>seqid</code>. The string <code>seqid</code> needs not be null-terminated, its length is
   given by <code>len</code>.
</p>
<hr>
<a name="gt_match_set_seqid2"></a>

<code>void              gt_match_set_seqid2(GtMatch *match, const char *seqid)</code>
<p>
Sets the sequence ID of the second sequence involved in the match <code>match</code> to
   <code>seqid</code>. The string <code>seqid</code> must be null-terminated.
</p>
<hr>
<a name="gt_match_set_seqid2_nt"></a>

<code>void              gt_match_set_seqid2_nt(GtMatch *match, const char *seqid,
                                        GtUword len)</code>
<p>
Sets the sequence ID of the second sequence involved in the match <code>match</code> to
   <code>seqid</code>. The string <code>seqid</code> needs not be null-terminated, its length is
   given by <code>len</code>.
</p>
<hr>
<a name="gt_match_get_seqid1"></a>

<code>const char*       gt_match_get_seqid1(const GtMatch *match)</code>
<p>
Returns the sequence ID of the first sequence involved in the match
   <code>match</code>.
</p>
<hr>
<a name="gt_match_get_seqid2"></a>

<code>const char*       gt_match_get_seqid2(const GtMatch *match)</code>
<p>
Returns the sequence ID of the second sequence involved in the match
   <code>match</code>.
</p>
<hr>
<a name="gt_match_set_range_seq1"></a>

<code>void              gt_match_set_range_seq1(GtMatch *match, GtUword start,
                                         GtUword end)</code>
<p>
Sets the range of the first sequence involved in the match <code>match</code> to
   <code>start</code>-<code>end</code>.
</p>
<hr>
<a name="gt_match_set_range_seq2"></a>

<code>void              gt_match_set_range_seq2(GtMatch *match, GtUword start,
                                         GtUword end)</code>
<p>
Sets the range of the second sequence involved in the match <code>match</code> to
   <code>start</code>-<code>end</code>.
</p>
<hr>
<a name="gt_match_get_range_seq1"></a>

<code>void              gt_match_get_range_seq1(const GtMatch *match, GtRange *range)</code>
<p>
Writes the range of the first sequence involved in the match <code>match</code> to the
   location pointed to by <code>range</code>.
</p>
<hr>
<a name="gt_match_get_range_seq2"></a>

<code>void              gt_match_get_range_seq2(const GtMatch *match, GtRange *range)</code>
<p>
Writes the range of the second sequence involved in the match <code>match</code> to the
   location pointed to by <code>range</code>.
</p>
<hr>
<a name="gt_match_get_direction"></a>

<code>GtMatchDirection  gt_match_get_direction(const GtMatch *match)</code>
<p>
Returns the match direction of <code>match</code>.
</p>
<hr>
<a name="gt_match_delete"></a>

<code>void              gt_match_delete(GtMatch *match)</code>
<p>
Deletes the match <code>match</code>, freeing all associated memory.
</p>
<hr>
<a name="GtMatchBlast"></a>
<h2>Class GtMatchBlast</h2>
<a name="gt_match_blast_new"></a>

<code>GtMatch*  gt_match_blast_new(char *seqid1,
                            char *seqid2,
                            GtUword start_seq1,
                            GtUword start_seq2,
                            GtUword end_seq1,
                            GtUword end_seq2,
                            double evalue,
                            float bitscore,
                            GtUword ali_l,
                            double similarity,
                            GtMatchDirection dir)</code>
<p>
Creates a new <code>GtMatch</code> object meant to store results in the BLAST
   format. That is, it stores double values <code>evalue</code> for match E-values,
   <code>bitscore</code>s and the alignment length <code>ali_l</code> in addition to the generic
   match contents <code>seqid1</code>, <code>seqid2</code>, <code>start_seq1</code>, <code>start_seq2</code>, <code>end_seq1</code>,
   and <code>end_seq2</code>.
</p>
<hr>
<a name="gt_match_blast_set_evalue"></a>

<code>void  gt_match_blast_set_evalue(GtMatchBlast *mb, double evalue)</code>
<p>
Sets <code>evalue</code> to be the E-value in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_set_bitscore"></a>

<code>void  gt_match_blast_set_bitscore(GtMatchBlast *mb, float bits)</code>
<p>
Sets <code>bits</code> to be the bit-score in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_set_align_length"></a>

<code>void  gt_match_blast_set_align_length(GtMatchBlast *mb, GtUword length)</code>
<p>
Sets <code>length</code> to be the alignment length in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_set_similarity"></a>

<code>void  gt_match_blast_set_similarity(GtMatchBlast *mb, double similarity)</code>
<p>
Sets <code>similarity</code> to be the match similarity in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_get_evalue"></a>

<code>double  gt_match_blast_get_evalue(GtMatchBlast *mb)</code>
<p>
Returns the E-value stored in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_get_bitscore"></a>

<code>float  gt_match_blast_get_bitscore(GtMatchBlast *mb)</code>
<p>
Returns the bit-score value stored in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_get_align_length"></a>

<code>GtUword  gt_match_blast_get_align_length(GtMatchBlast *mb)</code>
<p>
Returns the alignment length stored in <code>mb</code>.
</p>
<hr>
<a name="gt_match_blast_get_similarity"></a>

<code>double  gt_match_blast_get_similarity(GtMatchBlast *mb)</code>
<p>
Returns the alignment similarity stored in <code>mb</code>.
</p>
<hr>
<a name="GtMatchIterator"></a>
<h2>Class GtMatchIterator</h2>
<a name="gt_match_iterator_next"></a>

<code>GtMatchIteratorStatus  gt_match_iterator_next(GtMatchIterator *mp,
                                             GtMatch **match, GtError *err)</code>
<p>
Advances <code>mp</code> by one, returning the next match.
   Writes a pointer to the next match to the position pointed to by <code>match</code>.
   Returns GT_MATCHER_STATUS_OK when the match could be delivered and there are
   more matches to come, GT_MATCHER_STATUS_END when no more matches are
   available, and GT_MATCHER_STATUS_ERROR if an error occurred. <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_match_iterator_delete"></a>

<code>void                   gt_match_iterator_delete(GtMatchIterator *mp)</code>
<p>
Deletes <code>mp</code>, freeing all associated space.
</p>
<hr>
<a name="GtMatchLAST"></a>
<h2>Class GtMatchLAST</h2>

<p> The <code>GtMatchLAST</code> class, implementing the <code>GtMatch</code> interface, is meant to
    store results given in the format as output by LAST. </p>

<hr>
<a name="gt_match_last_new"></a>

<code>GtMatch*       gt_match_last_new(const char *seqid1,
                                const char *seqid2,
                                GtUword score,
                                GtUword seqno1,
                                GtUword seqno2,
                                GtUword start_seq1,
                                GtUword start_seq2,
                                GtUword end_seq1,
                                GtUword end_seq2,
                                GtMatchDirection dir)</code>
<p>
Creates a new <code>GtMatch</code> object meant to store results from the
   LAST software.
</p>
<hr>
<a name="gt_match_last_get_seqno1"></a>

<code>GtUword  gt_match_last_get_seqno1(const GtMatchLAST *ml)</code>
<p>
Returns the sequence number of the match <code>ms</code> in the first sequence set.
</p>
<hr>
<a name="gt_match_last_get_seqno2"></a>

<code>GtUword  gt_match_last_get_seqno2(const GtMatchLAST *ml)</code>
<p>
Returns the sequence number of the match <code>ms</code> in the second sequence set.
</p>
<hr>
<a name="gt_match_last_get_score"></a>

<code>GtUword  gt_match_last_get_score(const GtMatchLAST *ml)</code>
<p>
Returns the LAST score of the match <code>ms</code>.
</p>
<hr>
<a name="GtMatchOpen"></a>
<h2>Class GtMatchOpen</h2>

<p> The <code>GtMatchOpen</code> class, implementing the <code>GtMatch</code> interface, is meant to
    store results in the OpenMatch format, e.g. as output by Vmatch. </p>

<hr>
<a name="gt_match_open_new"></a>

<code>GtMatch*  gt_match_open_new(char *seqid1,
                           char *seqid2,
                           GtUword start_seq1,
                           GtUword start_seq2,
                           GtUword end_seq1,
                           GtUword end_seq2,
                           GtWord weight,
                           GtMatchDirection dir)</code>
<p>
Creates a new <code>GtMatchOpen</code> object, storing long values <code>weight</code> in addition
   to the generic match contents <code>seqid1</code>, <code>seqid2</code>, <code>start_seq1</code>, <code>start_seq2</code>,
   <code>end_seq1</code>, and <code>end_seq2</code>.
</p>
<hr>
<a name="gt_match_open_set_weight"></a>

<code>void  gt_match_open_set_weight(GtMatchOpen *mo, GtWord weight)</code>
<p>
Sets <code>weight</code> to be the weight value in <code>mo</code>.
</p>
<hr>
<a name="gt_match_open_get_weight"></a>

<code>GtWord  gt_match_open_get_weight(GtMatchOpen *mo)</code>
<p>
Returns the weight value stored in <code>mo</code>.
</p>
<hr>
<a name="GtMatchSW"></a>
<h2>Class GtMatchSW</h2>

<p> The <code>GtMatchSW</code> class, implementing the <code>GtMatch</code> interface, is meant to
    store results from Smith-Waterman matching (using the <code>swalign</code> module). </p>

<hr>
<a name="gt_match_sw_new"></a>

<code>GtMatch*       gt_match_sw_new(const char *seqid1,
                              const char *seqid2,
                              GtUword seqno1,
                              GtUword seqno2,
                              GtUword length,
                              GtUword edist,
                              GtUword start_seq1,
                              GtUword start_seq2,
                              GtUword end_seq1,
                              GtUword end_seq2,
                              GtMatchDirection dir)</code>
<p>
Creates a new <code>GtMatch</code> object, storing the alignment length <code>length</code>,
   the edit distance <code>edist</code> and the sequence numbers in the sequence
   collections in addition to the generic match contents <code>seqid1</code>, <code>seqid2</code>,
   <code>start_seq1</code>, <code>start_seq2</code>, <code>end_seq1</code> and <code>end_seq2</code>.
</p>
<hr>
<a name="gt_match_sw_get_seqno1"></a>

<code>GtUword  gt_match_sw_get_seqno1(const GtMatchSW *ms)</code>
<p>
Returns the sequence number of the match <code>ms</code> in the first sequence set.
</p>
<hr>
<a name="gt_match_sw_get_seqno2"></a>

<code>GtUword  gt_match_sw_get_seqno2(const GtMatchSW *ms)</code>
<p>
Returns the sequence number of the match <code>ms</code> in the second sequence set.
</p>
<hr>
<a name="gt_match_sw_get_alignment_length"></a>

<code>GtUword  gt_match_sw_get_alignment_length(const GtMatchSW *ms)</code>
<p>
Returns the alignment length of the match <code>ms</code>.
</p>
<hr>
<a name="gt_match_sw_get_edist"></a>

<code>GtUword  gt_match_sw_get_edist(const GtMatchSW *ms)</code>
<p>
Returns the edit distance of the match <code>ms</code>.
</p>
<hr>
<a name="GtMatchVisitor"></a>
<h2>Class GtMatchVisitor</h2>

<p> The <code>GtMatchVisitor</code> class allows one to distinguish a <code>GtMatch</code>
   implementation, e.g. BLAST or OpenMatch, and to call different
   code for each implementation. </p>

<hr>
<a name="gt_match_visitor_visit_match_blast"></a>

<code>int  gt_match_visitor_visit_match_blast(GtMatchVisitor *match_visitor,
                                       GtMatchBlast *match_blast,
                                       GtError *err)</code>
<p>
Visit <code>match_blast</code> with <code>match_visitor</code>.
</p>
<hr>
<a name="gt_match_visitor_visit_match_open"></a>

<code>int  gt_match_visitor_visit_match_open(GtMatchVisitor *match_visitor,
                                      GtMatchOpen *match_open,
                                      GtError *err)</code>
<p>
Visit <code>match_open</code> with <code>match_visitor</code>.
</p>
<hr>
<a name="gt_match_visitor_delete"></a>

<code>void  gt_match_visitor_delete(GtMatchVisitor *match_visitor)</code>
<p>
Deletes <code>match_visitor</code> freeing all associated space.
</p>
<hr>
<a name="GtMergeFeatureStream"></a>
<h2>Class GtMergeFeatureStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtMergeFeatureStream</code> merges
   adjacent features of the same type. </p>

<hr>
<a name="gt_merge_feature_stream_new"></a>

<code>GtNodeStream*  gt_merge_feature_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtMergeFeatureStream*</code> which merges adjacent features of the same
   type it retrieves from <code>in_stream</code> and returns them (and all other unmodified
   features).
</p>
<hr>
<a name="GtMergeStream"></a>
<h2>Class GtMergeStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtMergeStream</code> allows one to
   merge a set of sorted streams in a sorted fashion. </p>

<hr>
<a name="gt_merge_stream_new"></a>

<code>GtNodeStream*  gt_merge_stream_new(const GtArray *node_streams)</code>
<p>
Create a <code>GtMergeStream*</code> which merges the given (sorted) <code>node_streams</code> in a
   sorted fashion.
</p>
<hr>
<a name="GtMetaNode"></a>
<h2>Class GtMetaNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Meta nodes correspond to meta
   lines in GFF3 files (i.e., lines which start with  ``<code>##</code>'') which are not
   sequence-region lines. </p>

<hr>
<a name="gt_meta_node_new"></a>

<code>GtGenomeNode*             gt_meta_node_new(const char *meta_directive,
                                          const char *meta_data)</code>
<p>
Return a new <code>GtMetaNode</code> object representing a <code>meta_directive</code> with the
   corresponding <code>meta_data</code>. Please note that the leading ``<code>##</code>'' which
   denotes meta lines in GFF3 files should not be part of the
   <code>meta_directive</code>.
</p>
<hr>
<a name="gt_meta_node_get_directive"></a>

<code>const char*               gt_meta_node_get_directive(const GtMetaNode
                                                    *meta_node)</code>
<p>
Return the meta directive stored in <code>meta_node</code>.
</p>
<hr>
<a name="gt_meta_node_get_data"></a>

<code>const char*               gt_meta_node_get_data(const GtMetaNode *meta_node)</code>
<p>
Return the meta data stored in <code>meta_node</code>.
</p>
<hr>
<a name="gt_meta_node_try_cast"></a>

<code>GtMetaNode*               gt_meta_node_try_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a meta node. If so, a pointer to the
   meta node is returned. If not, NULL is returned. Note that in most cases,
   one should implement a GtNodeVisitor to handle processing of different
   GtGenomeNode types.
</p>
<hr>
<a name="gt_meta_node_cast"></a>

<code>GtMetaNode*               gt_meta_node_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a meta node. If so, a pointer to the
   meta node is returned. If not, an assertion fails.
</p>
<hr>
<a name="GtMutex"></a>
<h2>Class GtMutex</h2>

<p> The <code>GtMutex</code> class represents a simple mutex structure. </p>

<hr>
<a name="gt_mutex_new"></a>

<code>GtMutex*   gt_mutex_new(void)</code>
<p>
Return a new <code>GtMutex*</code> object.
</p>
<hr>
<a name="gt_mutex_delete"></a>

<code>void       gt_mutex_delete(GtMutex *mutex)</code>
<p>
Delete the given <code>mutex</code>.
</p>
<hr>
<a name="gt_mutex_lock"></a>

<code>#define gt_mutex_lock(mutex)</code>
<p>
Lock the given <code>mutex</code>.
</p>
<hr>
<a name="gt_mutex_unlock"></a>

<code>#define gt_mutex_unlock(mutex)</code>
<p>
Unlock the given <code>mutex</code>.
</p>
<hr>
<a name="GtNodeStream"></a>
<h2>Class GtNodeStream</h2>

<p> The <code>GtNodeStream</code> interface. <code>GtNodeStream</code> objects process <code>GtGenomeNode</code>
   objects in a pull-based architecture and can be chained together. </p>

<hr>
<a name="gt_node_stream_ref"></a>

<code>GtNodeStream*  gt_node_stream_ref(GtNodeStream *node_stream)</code>
<p>
Increase the reference count for <code>node_stream</code> and return it.
</p>
<hr>
<a name="gt_node_stream_next"></a>

<code>int            gt_node_stream_next(GtNodeStream *node_stream,
                                  GtGenomeNode **genome_node,
                                  GtError *err)</code>
<p>
Try to get the the next <code>GtGenomeNode</code> from <code>node_stream</code> and store it in
   <code>genome_node</code> (transfers ownership to <code>genome_node</code>).
   If no error occurs, 0 is returned and <code>genome_node</code> contains either the next
   <code>GtGenomeNode</code> or <code>NULL</code>, if the <code>node_stream</code> is exhausted.
   If an error occurs, -1 is returned and <code>err</code> is set accordingly (the status
   of <code>genome_node</code> is undefined, but no ownership transfer occured).
</p>
<hr>
<a name="gt_node_stream_pull"></a>

<code>int            gt_node_stream_pull(GtNodeStream *node_stream, GtError *err)</code>
<p>
Calls <code>gt_node_stream_next()</code> on <code>node_stream</code> repeatedly until the
   <code>node_stream</code> is exhausted (0 is returned) or an error occurs (-1 is returned
   and <code>err</code> is set). All retrieved <code>GtGenomeNode</code>s are deleted automatically
   with calls to <code>gt_genome_node_delete()</code>.
   This method is basically a convenience method which simplifies calls to
   <code>gt_node_stream_next()</code> in a loop where the retrieved <code>GtGenomeNode</code> objects
   are not processed any further.
</p>
<hr>
<a name="gt_node_stream_is_sorted"></a>

<code>bool           gt_node_stream_is_sorted(GtNodeStream *node_stream)</code>
<p>
Return <code>true</code> if <code>node_stream</code> is a sorted stream, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_node_stream_delete"></a>

<code>void           gt_node_stream_delete(GtNodeStream *node_stream)</code>
<p>
Decrease the reference count for <code>node_stream</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtNodeStreamFreeFunc"></a>

<code>void  GtNodeStreamFreeFunc(GtNodeStream*)</code>
<p>
Callback function. Performs the necessary steps to delete
   implementation-specific memory in the stream implementation.
</p>
<hr>
<a name="GtNodeStreamNextFunc"></a>

<code>int   GtNodeStreamNextFunc(GtNodeStream*, GtGenomeNode**, GtError*)</code>
<p>
Callback function. May receive a <code>GtGenomeNode</code> from its predecessor and
   must write a node reference or NULL to the node pointer.
</p>
<hr>
<a name="gt_node_stream_create"></a>

<code>GtNodeStream*       gt_node_stream_create(const GtNodeStreamClass
                                         *node_stream_class,
                                         bool ensure_sorting)</code>
<p>
Create a new object of the given <code>node_stream_class</code>. If <code>ensure_sorting</code> is
   <code>true</code>, it is enforced that all genome node objects pulled from this class
   are sorted. That is, for consecutive nodes <code>a</code> and <code>b</code> obtained from the
   given <code>node_stream_class</code> the return code of <code>gt_genome_node_compare(a,b)</code>
   has to be smaller or equal than 0. If this condition is not met, an assertion
   fails.
</p>
<hr>
<a name="gt_node_stream_cast"></a>

<code>void*               gt_node_stream_cast(const GtNodeStreamClass
                                       *node_stream_class,
                                       GtNodeStream *node_stream)</code>
<p>
Cast <code>node_stream</code> to the given <code>node_stream_class</code>.
   That is, if <code>node_stream</code> is not from the given <code>node_stream_class</code>, an
   assertion will fail.
</p>
<hr>
<a name="GtNodeStreamClass"></a>
<h2>Class GtNodeStreamClass</h2>
<a name="gt_node_stream_class_new"></a>

<code>const
GtNodeStreamClass*  gt_node_stream_class_new(size_t size,
                                            GtNodeStreamFreeFunc free,
                                            GtNodeStreamNextFunc next)</code>
<p>
Create a new node stream class (that is, a class which implements the node
   stream interface). <code>size</code> denotes the size of objects of the new node stream
   class. The optional <code>free</code> method is called once, if an object of the new
   class is deleted. The mandatory <code>next</code> method has to implement the
   <code>gt_node_stream_next()</code> semantic for the new class.
</p>
<hr>
<a name="GtNodeVisitor"></a>
<h2>Class GtNodeVisitor</h2>

<p> The <code>GtNodeVisitor</code> interface, a visitor for <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_node_visitor_visit_comment_node"></a>

<code>int    gt_node_visitor_visit_comment_node(GtNodeVisitor *node_visitor,
                                         GtCommentNode *comment_node,
                                         GtError *err)</code>
<p>
Visit <code>comment_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_feature_node"></a>

<code>int    gt_node_visitor_visit_feature_node(GtNodeVisitor *node_visitor,
                                         GtFeatureNode *feature_node,
                                         GtError *err)</code>
<p>
Visit <code>feature_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_meta_node"></a>

<code>int    gt_node_visitor_visit_meta_node(GtNodeVisitor *node_visitor,
                                      GtMetaNode *meta_node,
                                      GtError *err)</code>
<p>
Visit <code>meta_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_region_node"></a>

<code>int    gt_node_visitor_visit_region_node(GtNodeVisitor *node_visitor,
                                        GtRegionNode *region_node,
                                        GtError *err)</code>
<p>
Visit <code>region_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_sequence_node"></a>

<code>int    gt_node_visitor_visit_sequence_node(GtNodeVisitor *node_visitor,
                                          GtSequenceNode *sequence_node,
                                          GtError *err)</code>
<p>
Visit <code>sequence_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_delete"></a>

<code>void   gt_node_visitor_delete(GtNodeVisitor *node_visitor)</code>
<p>
Delete <code>node_visitor</code>.
</p>
<hr>
<a name="GtORFIterator"></a>
<h2>Class GtORFIterator</h2>

<p> The <code>GtORFIterator</code> class is used to enumerate open reading frames (ORFs)
   in codon streams as delivered by a <code>GtCodonIterator</code> using a translation
   process as defined by a <code>GtTranslator</code>. </p>

<hr>
<a name="gt_orf_iterator_new"></a>

<code>GtORFIterator*       gt_orf_iterator_new(GtCodonIterator *ci,
                                        GtTranslator *translator)</code>
<p>
Return a new <code>GtORFIterator*</code> using the codons delivered by <code>ci</code> and
   translated by <code>translator</code>.
</p>
<hr>
<a name="gt_orf_iterator_next"></a>

<code>GtORFIteratorStatus  gt_orf_iterator_next(GtORFIterator *orf_iterator,
                                         GtRange *orf_rng,
                                         unsigned int *orf_frame,
                                         GtError *err)</code>
<p>
Sets the values of <code>orf_rng.start</code>, <code>orf_rng.end</code> and <code>orf_frame</code> to the
   current reading position of <code>ci</code> if a START/STOP codon is found. The frame
   in which the ORF is located is written to the position pointed to by
   <code>orf_frame</code>. This function returns one of three status codes:
   <code>GT_ORF_ITERATOR_OK</code> if an ORF was detected successfully(START/STOP AA pair),
   <code>GT_ORF_ITERATOR_END</code> if no ORF was detected because the end of the scan
                           region has been reached, or
   <code>GT_ORF_ITERATOR_ERROR</code> if no ORF was detected because an error occurred
                           during sequence access. See <code>err</code> for details.
</p>
<hr>
<a name="gt_orf_iterator_delete"></a>

<code>void                 gt_orf_iterator_delete(GtORFIterator *orf_iterator)</code>
<p>
Delete <code>orf_iterator</code> and frees all associated memory.
</p>
<hr>
<a name="GtOption"></a>
<h2>Class GtOption</h2>

<p> <code>GtOption</code> objects represent command line options (which are used in
   a <code>GtOptionParser</code>).
   Option descriptions are automatically formatted to
   <code>GT_OPTION_PARSER_TERMINAL_WIDTH</code>, but it is possible to embed newlines into
   the descriptions to manually affect the formatting. </p>

<hr>
<a name="gt_option_new_bool"></a>

<code>GtOption*        gt_option_new_bool(const char *option_string,
                                   const char *description,
                                   bool *value, bool default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_double"></a>

<code>GtOption*        gt_option_new_double(const char *option_string,
                                     const char *description, double *value,
                                     double default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_double_min"></a>

<code>GtOption*        gt_option_new_double_min(const char *option_string,
                                         const char *description, double *value,
                                         double default_value,
                                         double minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_double_min_max"></a>

<code>GtOption*        gt_option_new_double_min_max(const char *option_string,
                                             const char *description,
                                             double *value,
                                             double default_value,
                                             double minimum_value,
                                             double maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_probability"></a>

<code>GtOption*        gt_option_new_probability(const char *option_string,
                                          const char *description,
                                          double *value,
                                          double default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at larger or equal than 0.0 and smaller or
  equal than 1.0.
</p>
<hr>
<a name="gt_option_new_int"></a>

<code>GtOption*        gt_option_new_int(const char *option_string,
                                  const char *description,
                                  int *value, int default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_int_min"></a>

<code>GtOption*        gt_option_new_int_min(const char *option_string,
                                      const char *description, int *value,
                                      int default_value, int minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_int_max"></a>

<code>GtOption*        gt_option_new_int_max(const char *option_string,
                                      const char *description, int *value,
                                      int default_value, int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at most have the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_int_min_max"></a>

<code>GtOption*        gt_option_new_int_min_max(const char *option_string,
                                          const char *description,
                                          int *value, int default_value,
                                          int minimum_value, int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_uint"></a>

<code>GtOption*        gt_option_new_uint(const char *option_string,
                                   const char *description,
                                   unsigned int *value,
                                   unsigned int default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_uint_min"></a>

<code>GtOption*        gt_option_new_uint_min(const char *option_string,
                                       const char *description,
                                       unsigned int *value,
                                       unsigned int default_value,
                                       unsigned int minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_uint_max"></a>

<code>GtOption*        gt_option_new_uint_max(const char *option_string,
                                       const char *description,
                                       unsigned int *value,
                                       unsigned int default_value,
                                       unsigned int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at most have the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_uint_min_max"></a>

<code>GtOption*        gt_option_new_uint_min_max(const char *option_string,
                                           const char *description,
                                           unsigned int *value,
                                           unsigned int default_value,
                                           unsigned int minimum_value,
                                           unsigned int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_word"></a>

<code>GtOption*        gt_option_new_word(const char *option_string,
                                   const char *description,
                                   GtWord *value, GtWord default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_uword"></a>

<code>GtOption*        gt_option_new_uword(const char *option_string,
                                    const char *description,
                                    GtUword *value,
                                    GtUword default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_uword_min"></a>

<code>GtOption*        gt_option_new_uword_min(const char *option_string,
                                        const char *description,
                                        GtUword *value,
                                        GtUword default_value,
                                        GtUword minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_uword_min_max"></a>

<code>GtOption*        gt_option_new_uword_min_max(const char *option_string,
                                            const char *description,
                                            GtUword *value,
                                            GtUword default_value,
                                            GtUword minimum_value,
                                            GtUword maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_long"></a>

<code>GtOption*        gt_option_new_long(const char *option_string,
                                   const char *description,
                                   GtWord *value, GtWord default_value)</code>
<p>
Deprecated. Usage identical to <code>gt_option_new_word</code>.
</p>
<hr>
<a name="gt_option_new_ulong"></a>

<code>GtOption*        gt_option_new_ulong(const char *option_string,
                                    const char *description,
                                    GtUword *value,
                                    GtUword default_value)</code>
<p>
Deprecated. Usage identical to <code>gt_option_new_uword</code>.
</p>
<hr>
<a name="gt_option_new_ulong_min"></a>

<code>GtOption*        gt_option_new_ulong_min(const char *option_string,
                                        const char *description,
                                        GtUword *value,
                                        GtUword default_value,
                                        GtUword minimum_value)</code>
<p>
Deprecated. Usage identical to <code>gt_option_new_uword_min</code>.
</p>
<hr>
<a name="gt_option_new_ulong_min_max"></a>

<code>GtOption*        gt_option_new_ulong_min_max(const char *option_string,
                                            const char *description,
                                            GtUword *value,
                                            GtUword default_value,
                                            GtUword minimum_value,
                                            GtUword maximum_value)</code>
<p>
Deprecated. Usage identical to <code>gt_option_new_uword_min_max</code>.
</p>
<hr>
<a name="gt_option_new_range"></a>

<code>GtOption*        gt_option_new_range(const char *option_string,
                                    const char *description,
                                    GtRange *value, GtRange *default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
   If <code>default_value</code> equals <code>NULL</code>, <code>GT_UNDEF_WORD</code> will be used as the default
   start and end point of <code>value</code>.
</p>
<hr>
<a name="gt_option_new_range_min_max"></a>

<code>GtOption*        gt_option_new_range_min_max(const char *option_string,
                                            const char *description,
                                            GtRange *value,
                                            GtRange *default_value,
                                            GtUword minimum_value,
                                            GtUword maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The first argument to this option (which will be used as the start) must at
  least have the <code>minimum_value</code> and the second argument (which will be used as
  the end) at most the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_string"></a>

<code>GtOption*        gt_option_new_string(const char *option_string,
                                     const char *description,
                                     GtStr *value, const char *default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_string_array"></a>

<code>GtOption*        gt_option_new_string_array(const char *option_string,
                                           const char *description,
                                           GtStrArray *value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing are stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_choice"></a>

<code>GtOption*        gt_option_new_choice(const char *option_string,
                                     const char *description, GtStr *value,
                                     const char *default_value,
                                     const char **domain)</code>
<p>
Return a <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code> which allows only arguments given in the <code>NULL</code>-terminated
   <code>domain</code> (<code>default_value</code> must be an entry of <code>domain</code> or <code>NULL</code>).
</p>
<hr>
<a name="gt_option_new_filename"></a>

<code>GtOption*        gt_option_new_filename(const char *option_string,
                                       const char *description,
                                       GtStr *filename)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>. The
   result of the option parsing is stored in the <code>GtStr</code> object <code>filename</code>.
   <code>filename</code> may not be NULL!
</p>
<hr>
<a name="gt_option_new_filename_array"></a>

<code>GtOption*        gt_option_new_filename_array(const char *option_string,
                                             const char *description,
                                             GtStrArray *filename_array)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The results of the option parsing are stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_debug"></a>

<code>GtOption*        gt_option_new_debug(bool *value)</code>
<p>
Return a new debug <code>GtOption</code> object: <code>-debug</code>, "enable debugging output",
   default is <code>false</code>. The result of the option parsing is stored in <code>value</code>
</p>
<hr>
<a name="gt_option_new_verbose"></a>

<code>GtOption*        gt_option_new_verbose(bool *value)</code>
<p>
Return a new verbose <code>GtOption</code> object: <code>-v</code>, "be verbose",
   default is <code>false</code>. The result of the option parsing is stored in <code>value</code>
</p>
<hr>
<a name="gt_option_new_width"></a>

<code>GtOption*        gt_option_new_width(GtUword *value)</code>
<p>
Return a new width <code>GtOption</code> object: <code>-width</code>, "set output width for FASTA
   sequence printing (0 disables formatting)", default is 0.
   The result of the option parsing is stored in <code>value</code>
</p>
<hr>
<a name="gt_option_ref"></a>

<code>GtOption*        gt_option_ref(GtOption *option)</code>
<p>
Increase the reference count for <code>option</code> and return it.
</p>
<hr>
<a name="gt_option_get_name"></a>

<code>const char*      gt_option_get_name(const GtOption * option)</code>
<p>
Return the name of <code>option</code>
</p>
<hr>
<a name="gt_option_is_mandatory"></a>

<code>void             gt_option_is_mandatory(GtOption *option)</code>
<p>
Make <code>option</code> mandatory.
</p>
<hr>
<a name="gt_option_is_mandatory_either"></a>

<code>void             gt_option_is_mandatory_either(GtOption *option_a,
                                              const GtOption *option_b)</code>
<p>
Make it mandatory, that either <code>option_a</code> or <code>option_b</code> is used.
</p>
<hr>
<a name="gt_option_is_mandatory_either_3"></a>

<code>void             gt_option_is_mandatory_either_3(GtOption *option_a,
                                                const GtOption *option_b,
                                                const GtOption *option_c)</code>
<p>
Make it mandatory, that one of the options <code>option_a</code>, <code>option_b</code>, or
   <code>option_c</code> is used.
</p>
<hr>
<a name="gt_option_is_mandatory_either_4"></a>

<code>void             gt_option_is_mandatory_either_4(GtOption *option_a,
                                                const GtOption *option_b,
                                                const GtOption *option_c,
                                                const GtOption *option_d)</code>
<p>
Make it mandatory, that one of the options <code>option_a</code>, <code>option_b</code>, <code>option_c</code>
   or <code>option_d</code> is used.
</p>
<hr>
<a name="gt_option_is_extended_option"></a>

<code>void             gt_option_is_extended_option(GtOption *option)</code>
<p>
Set that <code>option</code> is only shown in the output of <code>-help+</code>.
</p>
<hr>
<a name="gt_option_is_development_option"></a>

<code>void             gt_option_is_development_option(GtOption *option)</code>
<p>
Set that <code>option</code> is only shown in the output of <code>-helpdev</code>.
</p>
<hr>
<a name="gt_option_imply"></a>

<code>void             gt_option_imply(GtOption *option_a, const GtOption *option_b)</code>
<p>
Make <code>option_a</code> imply <code>option_b</code>.
</p>
<hr>
<a name="gt_option_imply_either_2"></a>

<code>void             gt_option_imply_either_2(GtOption *option_a,
                                         const GtOption *option_b,
                                         const GtOption *option_c)</code>
<p>
Make <code>option_a</code> imply either <code>option_b</code> or <code>option_c</code>
</p>
<hr>
<a name="gt_option_imply_either_3"></a>

<code>void             gt_option_imply_either_3(GtOption *option_a,
                                         const GtOption *option_b,
                                         const GtOption *option_c,
                                         const GtOption *option_d)</code>
<p>
Make <code>option_a</code> imply either <code>option_b</code>, <code>option_c</code> or <code>option_d</code>
</p>
<hr>
<a name="gt_option_exclude"></a>

<code>void             gt_option_exclude(GtOption *option_a, GtOption *option_b)</code>
<p>
Set that the options <code>option_a</code> and <code>option_b</code> exclude each other.
</p>
<hr>
<a name="gt_option_hide_default"></a>

<code>void             gt_option_hide_default(GtOption *option)</code>
<p>
Hide the default value of <code>option</code> in <code>-help</code> output.
</p>
<hr>
<a name="gt_option_argument_is_optional"></a>

<code>void             gt_option_argument_is_optional(GtOption *option)</code>
<p>
Set that the argument to <code>option</code> is optional
</p>
<hr>
<a name="gt_option_is_set"></a>

<code>bool             gt_option_is_set(const GtOption *option)</code>
<p>
Return <code>true</code> if <code>option</code> was set, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_option_delete"></a>

<code>void             gt_option_delete(GtOption*)</code>
<p>
Delete <code>option</code>.
</p>
<hr>
<a name="gt_option_parse_spacespec"></a>

<code>int  gt_option_parse_spacespec(GtUword *maximumspace,
                              const char *optname,
                              const GtStr *memlimit,
                              GtError *err)</code>
<p>
Parse the argument to option -memlimit. Could be made into
   a special parser, but I do not know how. SK. 2011-09-19
</p>
<hr>
<a name="GtOptionParser"></a>
<h2>Class GtOptionParser</h2>

<p> <code>GtOptionParser</code> objects can be used to parse command line options. </p>

<hr>
<a name="GT_OPTION_PARSER_TERMINAL_WIDTH"></a>

<code>#define GT_OPTION_PARSER_TERMINAL_WIDTH</code>
<p>
The default terminal width used in the output of the <code>GtOptionParser</code>.
</p>
<hr>
<a name="gt_option_parser_new"></a>

<code>GtOptionParser*  gt_option_parser_new(const char *synopsis,
                                     const char *one_liner)</code>
<p>
Return a new <code>GtOptionParser</code> object. The <code>synopsis</code> should summarize the
   command line arguments and mandatory arguments in a single line.
   The <code>one_liner</code> should describe the program for which the <code>GtOptionParser</code> is
   used in a single line and must have an upper case letter at the start and a
   '.' at the end.
</p>
<hr>
<a name="gt_option_parser_add_option"></a>

<code>void             gt_option_parser_add_option(GtOptionParser *option_parser,
                                            GtOption *option)</code>
<p>
Add <code>option</code> to <code>option_parser</code>. Takes ownership of <code>option</code>.
</p>
<hr>
<a name="gt_option_parser_get_option"></a>

<code>GtOption*        gt_option_parser_get_option(GtOptionParser *option_parser,
                                            const char *option_string)</code>
<p>
Return the <code>GtOption</code> object if an option named <code>option_string</code> is present in
   <code>option_parser</code>, and <code>NULL</code> if no such option exists.
</p>
<hr>
<a name="gt_option_parser_refer_to_manual"></a>

<code>void             gt_option_parser_refer_to_manual(GtOptionParser *option_parser)</code>
<p>
Refer to manual at the end of <code>-help</code> output of <code>opion_parser</code>.
</p>
<hr>
<a name="gt_option_parser_set_comment_func"></a>

<code>void             gt_option_parser_set_comment_func(GtOptionParser *option_parser,
                                                  GtShowCommentFunc
                                                  comment_func,
                                                  void *data)</code>
<p>
Set <code>comment_func</code> in <code>option_parser</code> (<code>data</code> is passed along).
</p>
<hr>
<a name="gt_option_parser_set_version_func"></a>

<code>void             gt_option_parser_set_version_func(GtOptionParser *option_parser,
                                                  GtShowVersionFunc
                                                  version_func)</code>
<p>
Set the version function used by <code>option_parser</code> to <code>version_func</code>.
   This version function takes precedence to the one supplied to
   <code>gt_option_parser_parse()</code>.
</p>
<hr>
<a name="gt_option_parser_set_mail_address"></a>

<code>void             gt_option_parser_set_mail_address(GtOptionParser*,
                                                  const char *mail_address)</code>
<p>
Set the <code>mail_address</code> used in the final "Report bugs to" line of the <code>-help</code>
   output. It should be of the form <code><bill@microsoft.com></code> (email address
   enclosed in one pair of angle brackets).
</p>
<hr>
<a name="gt_option_parser_register_hook"></a>

<code>void             gt_option_parser_register_hook(GtOptionParser *option_parser,
                                               GtOptionParserHookFunc
                                               hook_function,
                                               void *data)</code>
<p>
Register a <code>hook_function</code> with <code>option_parser</code>. All registered hook
   functions are called at the end of <code>gt_option_parser_parse()</code>.
   This allows one to have a module which registers a bunch of options in the
   option parser and automatically performs necessary postprocessing after the
   option parsing has been done via the hook function.
</p>
<hr>
<a name="gt_option_parser_set_min_args"></a>

<code>void             gt_option_parser_set_min_args(GtOptionParser *option_parser,
                                              unsigned int minimum)</code>
<p>
The the <code>minimum</code> number of additional command line arguments <code>option_parser</code>
   must parse in order to succeed.
</p>
<hr>
<a name="gt_option_parser_set_max_args"></a>

<code>void             gt_option_parser_set_max_args(GtOptionParser *option_parser,
                                              unsigned int maximum)</code>
<p>
The the <code>maximum</code> number of additional command line arguments <code>option_parser</code>
   must parse in order to succeed.
</p>
<hr>
<a name="gt_option_parser_set_min_max_args"></a>

<code>void             gt_option_parser_set_min_max_args(GtOptionParser *option_parser,
                                                  unsigned int minimum,
                                                  unsigned int maximum)</code>
<p>
The the <code>minimum</code> and <code>maximum</code> number of additional command line arguments
   <code>option_parser</code> must parse in order to succeed.
</p>
<hr>
<a name="gt_option_parser_parse"></a>

<code>GtOPrval         gt_option_parser_parse(GtOptionParser *option_parser,
                                       int *parsed_args,
                                       int argc, const char **argv,
                                       GtShowVersionFunc version_func,
                                       GtError *err)</code>
<p>
Use <code>option_parser</code> to parse options given in argument vector <code>argv</code> (with
   <code>argc</code> many arguments). The number of parsed arguments is stored in
   <code>parsed_args</code>. <code>version_func</code> is used for the output of option <code>-version</code>.
   In case of error, <code>GT_OPTION_PARSER_ERROR</code> is returned and <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_option_parser_reset"></a>

<code>void             gt_option_parser_reset(GtOptionParser *op)</code>
<p>
Reset all options set in <code>op</code> to the default values specified at
   option parser creation time.
</p>
<hr>
<a name="gt_option_parser_delete"></a>

<code>void             gt_option_parser_delete(GtOptionParser *option_parser)</code>
<p>
Delete <code>option_parser</code>.
</p>
<hr>
<a name="GtOutputFileInfo"></a>
<h2>Class GtOutputFileInfo</h2>

<p> The <code>GtOutputFileInfo</code> class encapsulates output options. </p>

<hr>
<a name="gt_output_file_info_new"></a>

<code>GtOutputFileInfo*  gt_output_file_info_new(void)</code>
<p>
Create a new <code>GtOutputFileInfo</code> object.
</p>
<hr>
<a name="gt_output_file_info_register_options"></a>

<code>void               gt_output_file_info_register_options(
                                            GtOutputFileInfo *output_file_info,
                                            GtOptionParser *option_parser,
                                            GtFile **outfp)</code>
<p>
Registers the options `-o', `-gzip', `-bzip2' and `-force' in
   <code>option_parser</code>. Options chosen during option parsing will be stored in
   <code>output_file_info</code> and the output file will be accessible using <code>*outfp</code>.
   If no option is given, default <code>*outfp</code> will use stdout.
   Caller retains ownership of <code>*outfp</code>.
</p>
<hr>
<a name="gt_output_file_info_delete"></a>

<code>void               gt_output_file_info_delete(
                                            GtOutputFileInfo *output_file_info)</code>
<p>
Deletes <code>output_file_info</code> and frees all associated memory.
</p>
<hr>
<a name="GtPhase"></a>
<h2>Class GtPhase</h2>

<p> This enum type defines the possible phases. The following phases are
   defined: <code>GT_PHASE_ZERO</code>, <code>GT_PHASE_ONE</code>, <code>GT_PHASE_TWO</code>, and
   <code>GT_PHASE_UNDEFINED</code>. </p>

<hr>
<a name="GT_PHASE_CHARS"></a>

<code>#define GT_PHASE_CHARS</code>
<p>
Use this string to map phase enum types to their corresponding character.
</p>
<hr>
<a name="gt_phase_get"></a>

<code>GtPhase  gt_phase_get(char phase_char)</code>
<p>
Map <code>phase_char</code> to the corresponding phase enum type.
   An assertion will fail if <code>phase_char</code> is not a valid one.
</p>
<hr>
<a name="GtQueue"></a>
<h2>Class GtQueue</h2>

<p> <code>GtQueue</code> objects are generic queues which can be used to process objects of
   any type in an First-In-First-Out (FIFO) fashion. </p>

<hr>
<a name="gt_queue_new"></a>

<code>GtQueue*       gt_queue_new(void)</code>
<p>
Return a new <code>GtQueue</code> object.
</p>
<hr>
<a name="gt_queue_add"></a>

<code>void           gt_queue_add(GtQueue *queue, void *elem)</code>
<p>
Add <code>elem</code> to <code>queue</code> (<em>enqueue</em> in computer science terminology).
</p>
<hr>
<a name="gt_queue_get"></a>

<code>void*          gt_queue_get(GtQueue *queue)</code>
<p>
Remove the first element from non-empty <code>queue</code> and return it (<em>dequeue</em> in
   computer science terminology).
</p>
<hr>
<a name="gt_queue_head"></a>

<code>void*          gt_queue_head(GtQueue *queue)</code>
<p>
Return the first element in non-empty <code>queue</code> without removing it.
</p>
<hr>
<a name="gt_queue_remove"></a>

<code>void           gt_queue_remove(GtQueue *queue, void *elem)</code>
<p>
Remove <code>elem</code> from <code>queue</code> (<code>elem</code> has to be in <code>queue</code>).
   Thereby <code>queue</code> is traversed in reverse order, leading to
   O(<code>gt_queue_size(queue)</code>) worst-case running time.
</p>
<hr>
<a name="gt_queue_size"></a>

<code>GtUword  gt_queue_size(const GtQueue *queue)</code>
<p>
Return the number of elements in <code>queue</code>.
</p>
<hr>
<a name="gt_queue_delete"></a>

<code>void           gt_queue_delete(GtQueue *queue)</code>
<p>
Delete <code>queue</code>. Elements contained in <code>queue</code> are not freed!
</p>
<hr>
<a name="GtRDBMySQL"></a>
<h2>Class GtRDBMySQL</h2>

<p> The <code>GtRDBMySQL</code> class implements the <code>GtRDB</code> interface using the
   MySQL client backend. This implementation is only available if
   compiled with the option ``with-mysql=yes''. </p>

<hr>
<a name="gt_rdb_mysql_new"></a>

<code>GtRDB*  gt_rdb_mysql_new(const char *server, unsigned int port,
                        const char *database, const char *username,
                        const char *password, GtError *err)</code>
<p>
Creates a new <code>GtRDBSqlite</code> object from the database accessible on <code>server</code>
   port <code>port</code>, selecting the database <code>database</code> using the credentials given
   by <code>username</code> and <code>password</code>. Returns NULL on error, <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="GtRDBSqlite"></a>
<h2>Class GtRDBSqlite</h2>

<p> The <code>GtRDBSqlite</code> class implements the <code>GtRDB</code> interface using the
   SQLite embedded database backend. This implementation is only available if
   compiled with the option ``with-sqlite=yes''. </p>

<hr>
<a name="gt_rdb_sqlite_new"></a>

<code>GtRDB*  gt_rdb_sqlite_new(const char *dbpath, GtError *err)</code>
<p>
Creates a new <code>GtRDBSqlite</code> object from the database file located at
   <code>dbpath</code>. Returns NULL on error, <code>err</code> is set accordingly.
</p>
<hr>
<a name="GtRDBVisitor"></a>
<h2>Class GtRDBVisitor</h2>

<p> The <code>GtRDBVisitor</code> interface, a visitor for <code>GtRDB</code> objects. </p>

<hr>
<a name="gt_rdb_visitor_visit_sqlite"></a>

<code>int    gt_rdb_visitor_visit_sqlite(GtRDBVisitor *rdbv, GtRDBSqlite *rdbs,
                                  GtError *err)</code>
<p>
Visit a SQLite database <code>rdbs</code> with <code>rdbv</code>. Returns 0 on success,
   a negative value otherwise, and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_rdb_visitor_visit_mysql"></a>

<code>int    gt_rdb_visitor_visit_mysql(GtRDBVisitor *rdbv, GtRDBMySQL *rdbm,
                                 GtError *err)</code>
<p>
Visit a MySQL database <code>rdbm</code> with <code>rdbv</code>. Returns 0 on success,
   a negative value otherwise, and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_rdb_visitor_delete"></a>

<code>void   gt_rdb_visitor_delete(GtRDBVisitor *rdbv)</code>
<p>
Delete <code>rdbv</code>.
</p>
<hr>
<a name="GtRWLock"></a>
<h2>Class GtRWLock</h2>

<p> The <code>GtRWLock</code> class represents a read/write lock. </p>

<hr>
<a name="gt_rwlock_new"></a>

<code>GtRWLock*  gt_rwlock_new(void)</code>
<p>
Return a new <code>GtRWLock*</code> object.
</p>
<hr>
<a name="gt_rwlock_delete"></a>

<code>void       gt_rwlock_delete(GtRWLock *rwlock)</code>
<p>
Delete the given <code>rwlock</code>.
</p>
<hr>
<a name="gt_rwlock_rdlock"></a>

<code>#define gt_rwlock_rdlock(rwlock)</code>
<p>
Acquire a read lock for <code>rwlock</code>.
</p>
<hr>
<a name="gt_rwlock_wrlock"></a>

<code>#define gt_rwlock_wrlock(rwlock)</code>
<p>
Acquire a write lock for <code>rwlock</code>.
</p>
<hr>
<a name="gt_rwlock_unlock"></a>

<code>#define gt_rwlock_unlock(rwlock)</code>
<p>
Unlock the given <code>rwlock</code>.
</p>
<hr>
<a name="GtRange"></a>
<h2>Class GtRange</h2>

<p> The <code>GtRange</code> class is used to represent genomic ranges in <em>GenomeTools</em>.
   Thereby, the <code>start</code> must <strong>always</strong> be smaller or equal than the <code>end</code>. </p>

<hr>
<a name="gt_range_compare"></a>

<code>int      gt_range_compare(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Compare <code>range_a</code> and <code>range_b</code>. Returns 0 if <code>range_a</code> equals <code>range_b</code>, -1
   if <code>range_a</code> starts before <code>range_b</code> or (for equal starts) <code>range_a</code> ends
   before <code>range_b</code>, and 1 else.
</p>
<hr>
<a name="gt_range_compare_with_delta"></a>

<code>int      gt_range_compare_with_delta(const GtRange *range_a,
                                    const GtRange *range_b,
                                    GtUword delta)</code>
<p>
Compare <code>range_a</code> and <code>range_b</code> with given <code>delta</code>.
   Returns 0 if <code>range_a</code> equals <code>range_b</code> modulo <code>delta</code> (i.e., the start and
   end points of <code>range_a</code> and <code>range_b</code> are at most <code>delta</code> bases apart), -1
   if <code>range_a</code> starts before <code>range_b</code> or (for equal starts) <code>range_a</code> ends
   before <code>range_b</code>, and 1 else.
</p>
<hr>
<a name="gt_range_overlap"></a>

<code>bool     gt_range_overlap(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Returns <code>true</code> if <code>range_a</code> and <code>range_b</code> overlap, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_overlap_delta"></a>

<code>bool     gt_range_overlap_delta(const GtRange *range_a,
                               const GtRange *range_b,
                               GtUword delta)</code>
<p>
Returns <code>true</code> if <code>range_a</code> and <code>range_b</code> overlap <strong>at least</strong> <code>delta</code> many
   positions, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_contains"></a>

<code>bool     gt_range_contains(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Returns <code>true</code> if <code>range_b</code> is contained in <code>range_a</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_within"></a>

<code>bool     gt_range_within(const GtRange *range, GtUword point)</code>
<p>
Returns <code>true</code> if <code>point</code> lies within <code>range</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_join"></a>

<code>GtRange  gt_range_join(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Join <code>range_a</code> and <code>range_b</code> and return the result.
</p>
<hr>
<a name="gt_range_offset"></a>

<code>GtRange  gt_range_offset(const GtRange *range, GtWord offset)</code>
<p>
Transform start and end of <code>range</code> by <code>offset</code> and return the result.
</p>
<hr>
<a name="gt_range_length"></a>

<code>GtUword  gt_range_length(const GtRange *range)</code>
<p>
Returns the length of the given <code>range</code>.
</p>
<hr>
<a name="GtReadmode"></a>
<h2>Class GtReadmode</h2>

<p> This enum type defines the possible reamodes, namely <code>GT_READMODE_FORWARD</code>,
   <code>GT_READMODE_REVERSE</code>, <code>GT_READMODE_COMPL</code>, and <code>GT_READMODE_REVCOMPL</code>. </p>

<hr>
<a name="gt_readmode_show"></a>

<code>const char*  gt_readmode_show(GtReadmode readmode)</code>
<p>
Returns the descriptive string for <code>readmode</code>.
</p>
<hr>
<a name="gt_readmode_parse"></a>

<code>int          gt_readmode_parse(const char *string, GtError *err)</code>
<p>
Returns the <code>GtReadmode</code> for the description <code>string</code>, which must be one
   of "fwd","rev","cpl" or "rcl". If <code>string</code> does not equal any of them,
   -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="GtRecMap"></a>
<h2>Class GtRecMap</h2>

<p> A <code>GtRecMap</code> object contains a mapping from a 2D coordinate pair
   which identifies a rectangle in a rendered image to the <code>GtFeatureNode</code> it
  represents. The rectangle is defined by the coordinates of its upper left
  (``northwest'') and lower right (``southeast'') points.</p><p>  <code>GtRecMap</code> objects are created by an <code>GtImageInfo</code> object which is filled
  during the generation of an image by <em>AnnotationSketch</em>. </p>

<hr>
<a name="gt_rec_map_new"></a>

<code>GtRecMap*             gt_rec_map_new(double nw_x, double nw_y, double se_x,
                                    double se_y, GtFeatureNode *f)</code>
<p>
Creates a new <code>GtRecMap</code> for feature <code>f</code> with the given coordinates.
</p>
<hr>
<a name="gt_rec_map_ref"></a>

<code>GtRecMap*             gt_rec_map_ref(GtRecMap *rm)</code>
<p>
Increases the reference count of <code>rm</code>.
</p>
<hr>
<a name="gt_rec_map_get_northwest_x"></a>

<code>double                gt_rec_map_get_northwest_x(const GtRecMap*)</code>
<p>
Retrieve <em>x</em> value of the the upper left point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_northwest_y"></a>

<code>double                gt_rec_map_get_northwest_y(const GtRecMap*)</code>
<p>
Retrieve <em>y</em> value of the the upper left point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_southeast_x"></a>

<code>double                gt_rec_map_get_southeast_x(const GtRecMap*)</code>
<p>
Retrieve <em>x</em> value of the the lower right point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_southeast_y"></a>

<code>double                gt_rec_map_get_southeast_y(const GtRecMap*)</code>
<p>
Retrieve <em>y</em> value of the the lower right point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_genome_feature"></a>

<code>const GtFeatureNode*  gt_rec_map_get_genome_feature(const GtRecMap*)</code>
<p>
Retrieve <code>GtFeatureNode</code> associated with this rectangle.
</p>
<hr>
<a name="gt_rec_map_has_omitted_children"></a>

<code>bool                  gt_rec_map_has_omitted_children(const GtRecMap*)</code>
<p>
Returns <code>true</code> if the rectangle represents a block root whose elements
   have not been drawn due to size restrictions.
</p>
<hr>
<a name="gt_rec_map_delete"></a>

<code>void                  gt_rec_map_delete(GtRecMap*)</code>
<p>
Deletes a <code>GtRecMap</code> and frees all associated memory.
</p>
<hr>
<a name="GtRegionMapping"></a>
<h2>Class GtRegionMapping</h2>

<p> A <code>GtRegionMapping</code> objects maps sequence-regions to the corresponding
   entries of sequence files. </p>

<hr>
<a name="gt_region_mapping_new_mapping"></a>

<code>GtRegionMapping*  gt_region_mapping_new_mapping(GtStr *mapping_filename,
                                               GtError *err)</code>
<p>
Return a new <code>GtRegionMapping</code> object for the mapping file with the given
   <code>mapping_filename</code>. In the case of an error, <code>NULL</code> is returned and <code>err</code> is
   set accordingly.
</p>
<hr>
<a name="gt_region_mapping_new_seqfiles"></a>

<code>GtRegionMapping*  gt_region_mapping_new_seqfiles(GtStrArray *sequence_filenames,
                                                bool matchdesc, bool usedesc)</code>
<p>
Return a new <code>GtRegionMapping</code> object for the sequence files given in
   <code>sequence_filenames</code>. If <code>matchdesc</code> is <code>true</code>, the sequence descriptions
   from the input files are matched for the desired sequence IDs (in GFF3).

   If <code>usedesc</code> is <code>true</code>, the sequence descriptions are used to map the
   sequence IDs (in GFF3) to actual sequence entries. If a description contains
   a sequence range (e.g., III:1000001..2000000), the first part is used as
   sequence ID ('III') and the first range position as offset ('1000001').

   <code>matchdesc</code> and <code>usedesc</code> cannot be <code>true</code> at the same time.
</p>
<hr>
<a name="gt_region_mapping_new_encseq"></a>

<code>GtRegionMapping*  gt_region_mapping_new_encseq(GtEncseq *encseq, bool matchdesc,
                                              bool usedesc)</code>
<p>
Like <code>gt_region_mapping_new_seqfiles()</code>, but using <code>encseq</code> as a sequence
   source.
</p>
<hr>
<a name="gt_region_mapping_new_rawseq"></a>

<code>GtRegionMapping*  gt_region_mapping_new_rawseq(const char *rawseq,
                                              GtUword length, GtUword offset)</code>
<p>
Return a new <code>GtRegionMapping</code> object which maps to the given sequence
   <code>rawseq</code> with the corresponding <code>length</code> and <code>offset</code>.
</p>
<hr>
<a name="gt_region_mapping_ref"></a>

<code>GtRegionMapping*  gt_region_mapping_ref(GtRegionMapping *region_mapping)</code>
<p>
Increase the reference count for <code>region_mapping</code> and return it.
</p>
<hr>
<a name="gt_region_mapping_get_sequence"></a>

<code>int               gt_region_mapping_get_sequence(GtRegionMapping *region_mapping,
                                                char **seq, GtStr *seqid,
                                                GtUword start,
                                                GtUword end,
                                                GtError *err)</code>
<p>
Use <code>region_mapping</code> to extract the sequence from <code>start</code> to <code>end</code> of the
   given sequence ID <code>seqid</code> into a buffer written to <code>seq</code> (the caller is
   responsible to free it).
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_get_sequence_length"></a>

<code>int               gt_region_mapping_get_sequence_length(GtRegionMapping
                                                       *region_mapping,
                                                       GtUword *length,
                                                       GtStr *seqid,
                                                       GtError *err)</code>
<p>
Use <code>region_mapping</code> to retrieve the sequence length of the given
   sequence ID <code>seqid</code> and store the result in <code>length</code>.
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_get_description"></a>

<code>int               gt_region_mapping_get_description(GtRegionMapping
                                                   *region_mapping,
                                                   GtStr *desc,
                                                   GtStr *seqid,
                                                   GtError *err)</code>
<p>
Use <code>region_mapping</code> to get the description of the MD5 sequence ID <code>seqid</code>.
   The description is appended to <code>desc</code>.
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_get_md5_fingerprint"></a>

<code>const char*       gt_region_mapping_get_md5_fingerprint(GtRegionMapping
                                                       *region_mapping,
                                                       GtStr *seqid,
                                                       const GtRange *range,
                                                       GtUword *offset,
                                                       GtError *err)</code>
<p>
Use <code>region_mapping</code> to return the MD5 fingerprint of the sequence with the
   sequence ID <code>seqid</code> and its corresponding <code>range</code>. The offset of the sequence
   is stored in <code>offset</code>.
   In the case of an error, <code>NULL</code> is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_delete"></a>

<code>void              gt_region_mapping_delete(GtRegionMapping *region_mapping)</code>
<p>
Delete <code>region_mapping</code>.
</p>
<hr>
<a name="GtRegionNode"></a>
<h2>Class GtRegionNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Region nodes correspond to the
   <code>##sequence-region</code> lines in GFF3 files.</p>

<hr>
<a name="gt_region_node_new"></a>

<code>GtGenomeNode*  gt_region_node_new(GtStr *seqid, GtUword start,
                                               GtUword end)</code>
<p>
Create a new <code>GtRegionNode*</code> representing sequence with ID <code>seqid</code> from
   base position <code>start</code> to base position <code>end</code> (1-based).
   <code>start</code> has to be smaller or equal than <code>end</code>.
   The <code>GtRegionNode*</code> stores a new reference to <code>seqid</code>, so make sure you do
   not modify the original <code>seqid</code> afterwards!
</p>
<hr>
<a name="gt_region_node_try_cast"></a>

<code>GtRegionNode*  gt_region_node_try_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a region node. If so, a pointer to the
   region node is returned. If not, NULL is returned. Note that in most cases,
   one should implement a GtNodeVisitor to handle processing of different
   GtGenomeNode types.
</p>
<hr>
<a name="gt_region_node_cast"></a>

<code>GtRegionNode*  gt_region_node_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a region node. If so, a pointer to the
   region node is returned. If not, an assertion fails.
</p>
<hr>
<a name="GtScriptWrapperStream"></a>
<h2>Class GtScriptWrapperStream</h2>

<p> Implements the <code>GtScriptWrapperStream</code> interface. This stream is
   only used to store pointers to external callbacks, e.g. written in a
   scripting language. This class does not store any state or logic, relying
   on the developer of the external custom stream class to do so.  </p>

<hr>
<a name="gt_script_wrapper_stream_new"></a>

<code>GtNodeStream*  gt_script_wrapper_stream_new(GtScriptWrapperStreamNextFunc,
                                           GtScriptWrapperStreamFreeFunc)</code>
<p>
Creates a new <code>GtScriptWrapperStream</code> given a next and a free function.
</p>
<hr>
<a name="GtScriptWrapperVisitor"></a>
<h2>Class GtScriptWrapperVisitor</h2>

<p> Implements the <code>GtNodeVisitor</code> interface. </p>

<hr>
<a name="gt_script_wrapper_visitor_new"></a>

<code>GtNodeVisitor*  gt_script_wrapper_visitor_new(
                                         GtScriptWrapperVisitorCommentNodeFunc,
                                         GtScriptWrapperVisitorFeatureNodeFunc,
                                         GtScriptWrapperVisitorRegionNodeFunc,
                                         GtScriptWrapperVisitorSequenceNodeFunc,
                                         GtScriptWrapperVisitorMetaNodeFunc,
                                         GtScriptWrapperVisitorEOFNodeFunc,
                                         GtScriptWrapperVisitorFreeFunc)</code>
<p>
Creates a new <code>GtScriptWrapperVisitor</code> for a number of callback functions.
</p>
<hr>
<a name="GtSelectStream"></a>
<h2>Class GtSelectStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtSelectStream</code> selects certain
   nodes it retrieves from its node source and passes them along. </p>

<hr>
<a name="gt_select_stream_new"></a>

<code>GtNodeStream*  gt_select_stream_new(GtNodeStream *in_stream,
                                   GtStr *seqid,
                                   GtStr *source,
                                   const GtRange *contain_range,
                                   const GtRange *overlap_range,
                                   GtStrand strand,
                                   GtStrand targetstrand,
                                   bool has_CDS,
                                   GtUword max_gene_length,
                                   GtUword max_gene_num,
                                   double min_gene_score,
                                   double max_gene_score,
                                   double min_average_splice_site_prob,
                                   GtUword feature_num,
                                   GtStrArray *select_files,
                                   GtStr *select_logic,
                                   GtError *err)</code>
<p>
Create a <code>GtSelectStream</code> object which selects genome nodes it retrieves from
   its <code>in_stream</code> and passes them along if they meet the criteria defined by
   the other arguments. All comment nodes are selected.
   If <code>seqid</code> is defined, a genome node must have it to be selected.
   If <code>source</code> is defined, a genome node must have it to be selected.
   If <code>contain_range</code> is defined, a genome node must be contained in it to be
   selected.
   If <code>overlap_range</code> is defined, a genome node must overlap it to be selected.
   If <code>strand</code> is defined, a (top-level) genome node must have it to be
   selected.
   If <code>targetstrand</code> is defined, a feature with a target attribute must have
   exactly one of it and its strand must equal <code>targetstrand</code>.
   If <code>had_cds</code> is <code>true</code>, all top-level features are selected which have a
   child with type <em>CDS</em>.
   If <code>max_gene_length</code> is defined, only genes up to the this length are
   selected.
   If <code>max_gene_num</code> is defined, only so many genes are selected.
   If <code>min_gene_score</code> is defined, only genes with at least this score are
   selected.
   If <code>max_gene_score</code> is defined, only genes with at most this score are
   selected.
   If <code>min_average_splice_site_prob</code> is defined, feature nodes which have
   splice sites must have at least this average splice site score to be
   selected.
   If <code>feature_num</code> is defined, just the <code>feature_num</code>th feature node occurring
   in the <code>in_stream</code> is selected.
   If <code>select_files</code> is defined and has at least one entry, the entries are
   evaluated as Lua scripts containing functions taking <code>GtGenomeNodes</code> that
   are evaluated to boolean values to determine selection. <code>select_logic</code>
   can be "OR" or "AND", defining how the results from the select scripts are
   combined.
   Returns a pointer to a new <code>GtSelectStream</code> or NULL on error (<code>err</code> is set
   accordingly).
</p>
<hr>
<a name="gt_select_stream_set_drophandler"></a>

<code>void           gt_select_stream_set_drophandler(GtSelectStream *sstr,
                                               GtSelectNodeFunc fp,
                                               void *data)</code>
<p>
Sets <code>fp</code> as a handler function to be called for every <code>GtGenomeNode</code> not
   selected by <code>sstr</code>. The void pointer <code>data</code> can be used for arbitrary user
   data.
</p>
<hr>
<a name="GtSeqIterator"></a>
<h2>Class GtSeqIterator</h2>
<a name="gt_seq_iterator_set_symbolmap"></a>

<code>void             gt_seq_iterator_set_symbolmap(GtSeqIterator*,
                                              const GtUchar *symbolmap)</code>
<p>
Sets a symbol map for the <code>GtSeqIterator</code>.
   If a <code>symbolmap</code> is given, all read in sequences are transformed with it.
   Set to NULL to disable alphabet transformation.
</p>
<hr>
<a name="gt_seq_iterator_set_sequence_output"></a>

<code>void             gt_seq_iterator_set_sequence_output(GtSeqIterator*, bool)</code>
<p>
If set to <code>true</code>, sequences and descriptions are processed (otherwise
   only the descriptions). By default, sequences are processed.
</p>
<hr>
<a name="gt_seq_iterator_next"></a>

<code>int              gt_seq_iterator_next(GtSeqIterator *seqit,
                                     const GtUchar **sequence,
                                     GtUword *len,
                                     char **description,
                                     GtError *err)</code>
<p>
Get next <code>sequence</code> (of length <code>len</code>) and <code>description</code> from <code>seqit</code>.
   Note that <code>seqit</code> retains ownership of the <code>sequence</code> and <code>description</code>.
   Returns 1 if another sequence could be parsed, 0 if all given sequence
   files are exhausted, And -1 if an error occured (<code>err</code> is set
   accordingly).
</p>
<hr>
<a name="gt_seq_iterator_getcurrentcounter"></a>

<code>const GtUint64*  gt_seq_iterator_getcurrentcounter(GtSeqIterator*,
                                                  GtUint64)</code>
<p>
Returns a pointer to the current total number of read characters.
</p>
<hr>
<a name="gt_seq_iterator_has_qualities"></a>

<code>bool             gt_seq_iterator_has_qualities(GtSeqIterator *seqit)</code>
<p>
Returns TRUE if <code>seqit</code> supports setting of a quality buffer.
</p>
<hr>
<a name="gt_seq_iterator_set_quality_buffer"></a>

<code>void             gt_seq_iterator_set_quality_buffer(GtSeqIterator *seqit,
                                                   const GtUchar **qualities)</code>
<p>
Turns on reporting of sequence qualities to the location
   pointed to by <code>qualities</code>. That pointer will be set to a string containing
   the quality data (which must then be processed into scores).
</p>
<hr>
<a name="gt_seq_iterator_delete"></a>

<code>void             gt_seq_iterator_delete(GtSeqIterator *seqit)</code>
<p>
Deletes <code>seqit</code> and frees associated memory.
</p>
<hr>
<a name="GtSeqIteratorFastQ"></a>
<h2>Class GtSeqIteratorFastQ</h2>
<a name="gt_seq_iterator_fastq_new"></a>

<code>GtSeqIterator*  gt_seq_iterator_fastq_new(const GtStrArray *filenametab,
                                         GtError *err)</code>
<p>
Create a new <code>GtSeqIteratorFastQ</code> for all sequence files in <code>filenametab</code>.
</p>
<hr>
<a name="gt_seq_iterator_fastq_new_colorspace"></a>

<code>GtSeqIterator*  gt_seq_iterator_fastq_new_colorspace(const GtStrArray
                                                    *filenametab,
                                                    GtError *err)</code>
<p>
Create a new <code>GtSeqIteratorFastQ</code> for all sequence files in <code>filenametab</code>
   containing color space reads.
</p>
<hr>
<a name="gt_seq_iterator_fastq_get_file_index"></a>

<code>GtUword   gt_seq_iterator_fastq_get_file_index(GtSeqIteratorFastQ *seqit)</code>
<p>
Returns the number of the file in the file name array which <code>seqit</code> is
   currently reading.
</p>
<hr>
<a name="gt_seq_iterator_fastq_relax_check_of_quality_description"></a>

<code>void            gt_seq_iterator_fastq_relax_check_of_quality_description(
                                                    GtSeqIteratorFastQ *seqit)</code>
<p>
Disable checking if quality description is equal to read description in
   <code>seqit</code> (it should be, but it is not in output of some tools, e.g. Coral).
</p>
<hr>
<a name="GtSeqIteratorSequenceBuffer"></a>
<h2>Class GtSeqIteratorSequenceBuffer</h2>
<a name="gt_seq_iterator_sequence_buffer_new"></a>

<code>GtSeqIterator*  gt_seq_iterator_sequence_buffer_new(const GtStrArray
                                                                   *filenametab,
                                                  GtError *err)</code>
<p>
Create a new <code>GtSeqIterator</code> for all sequence files in <code>filenametab</code>.
   All files have to be of the same format, which will be guessed by examining
   the beginning of the first file. If an error occurs, NULL is returned (see
   the <code>err</code> object for details).
</p>
<hr>
<a name="GtSequenceNode"></a>
<h2>Class GtSequenceNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Sequence nodes correspond to
   singular embedded FASTA sequences in GFF3 files. </p>

<hr>
<a name="gt_sequence_node_new"></a>

<code>GtGenomeNode*             gt_sequence_node_new(const char *description,
                                              GtStr *sequence)</code>
<p>
Create a new <code>GtSequenceNode*</code> representing a FASTA entry with the given
   <code>description</code> and <code>sequence</code>. Takes ownership of <code>sequence</code>.
</p>
<hr>
<a name="gt_sequence_node_get_description"></a>

<code>const char*               gt_sequence_node_get_description(const
                                                          GtSequenceNode
                                                          *sequence_node)</code>
<p>
Return the description of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_get_sequence"></a>

<code>const char*               gt_sequence_node_get_sequence(const GtSequenceNode
                                                       *sequence_node)</code>
<p>
Return the sequence of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_get_sequence_length"></a>

<code>GtUword                   gt_sequence_node_get_sequence_length(const
                                                              GtSequenceNode
                                                              *sequence_node)</code>
<p>
Return the sequence length of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_try_cast"></a>

<code>GtSequenceNode*           gt_sequence_node_try_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a sequence node. If so, a pointer to
   the sequence node is returned. If not, NULL is returned. Note that in most
   cases, one should implement a GtNodeVisitor to handle processing of different
   GtGenomeNode types.
</p>
<hr>
<a name="gt_sequence_node_cast"></a>

<code>GtSequenceNode*           gt_sequence_node_cast(GtGenomeNode *gn)</code>
<p>
Test whether the given genome node is a sequence node. If so, a pointer to
   the sequence node is returned. If not, an assertion fails.
</p>
<hr>
<a name="GtSetSourceVisitor"></a>
<h2>Class GtSetSourceVisitor</h2>

<p> Implements the <code>GtNodeVisitor</code> interface. Used with the <code>GtVisitorStream</code>
   class, a <code>GtSetSourceVisitor</code> resets the source value for <code>GtFeatureNode</code>
   objects. </p>

<hr>
<a name="gt_set_source_visitor_new"></a>

<code>GtNodeVisitor*  gt_set_source_visitor_new(GtStr *newsource)</code>
<p>
Create a node visitor object which will reset the source value of all
   <code>GtFeatureNode</code> objects it processes to <code>newsource</code>.
</p>
<hr>
<a name="GtSortStream"></a>
<h2>Class GtSortStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtSortStream</code> sorts the
   <code>GtGenomeNode</code> objects it retrieves from its node source. </p>

<hr>
<a name="gt_sort_stream_new"></a>

<code>GtNodeStream*  gt_sort_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtSortStream*</code> which sorts the genome nodes it retrieves from
   <code>in_stream</code> and returns them unmodified, but in sorted order.
</p>
<hr>
<a name="GtSplitter"></a>
<h2>Class GtSplitter</h2>

<p> The <code>GtSplitter</code> class defines objects which can split given strings into
   tokens delimited by a given character, allowing for convenient access to
   each token. </p>

<hr>
<a name="gt_splitter_new"></a>

<code>GtSplitter*    gt_splitter_new(void)</code>
<p>
Create a new <code>GtSplitter</code> object.
</p>
<hr>
<a name="gt_splitter_split"></a>

<code>void           gt_splitter_split(GtSplitter *splitter, char *string,
                                GtUword length, char delimiter)</code>
<p>
Use <code>splitter</code> to split <code>string</code> of given <code>length</code> into tokens delimited by
   <code>delimiter</code>. Note that <code>string</code> is modified in the splitting process!
</p>
<hr>
<a name="gt_splitter_get_tokens"></a>

<code>char**         gt_splitter_get_tokens(GtSplitter *splitter)</code>
<p>
Return all tokens split by <code>splitter</code> in an array.
</p>
<hr>
<a name="gt_splitter_get_token"></a>

<code>char*          gt_splitter_get_token(GtSplitter *splitter,
                                    GtUword token_num)</code>
<p>
Return token with number <code>token_num</code> from <code>splitter</code>.
</p>
<hr>
<a name="gt_splitter_reset"></a>

<code>void           gt_splitter_reset(GtSplitter *splitter)</code>
<p>
Reset the <code>splitter</code>.
</p>
<hr>
<a name="gt_splitter_size"></a>

<code>GtUword  gt_splitter_size(GtSplitter *splitter)</code>
<p>
Return the number of tokens in <code>splitter</code>.
</p>
<hr>
<a name="gt_splitter_delete"></a>

<code>void           gt_splitter_delete(GtSplitter *splitter)</code>
<p>
Delete the <code>splitter</code>.
</p>
<hr>
<a name="GtStatStream"></a>
<h2>Class GtStatStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtStatStream</code> gathers statistics
   about the <code>GtGenomeNode</code> objects it retrieves from its node source and passes
   them along unmodified. </p>

<hr>
<a name="gt_stat_stream_new"></a>

<code>GtNodeStream*  gt_stat_stream_new(GtNodeStream *in_stream,
                                 bool gene_length_distribution,
                                 bool gene_score_distribution,
                                 bool exon_length_distribution,
                                 bool exon_number_distribution,
                                 bool intron_length_distribution,
                                 bool cds_length_distribution,
                                 bool used_sources)</code>
<p>
Create a <code>GtStatStream</code> object which gathers statistics about the
   <code>GtGenomeNode</code> objects it retrieves from its <code>in_stream</code> and returns them
   unmodified. Besides the basic statistics, statistics about the following
   distributions can be gathered, if the corresponding argument equals <code>true</code>:
   <code>gene_length_distribution</code>, <code>gene_score_distribution</code>,
   <code>exon_length_distribution</code>, <code>exon_number_distribution</code>,
   <code>intron_length_distribution</code>, <code>cds_length_distribution</code>.

   If <code>used_sources</code> equals <code>true</code>, it is recorded which source tags have been
   encountered.
</p>
<hr>
<a name="gt_stat_stream_show_stats"></a>

<code>void           gt_stat_stream_show_stats(GtStatStream *stat_stream,
                                        GtFile *outfp)</code>
<p>
Write the statistics gathered by <code>stat_stream</code> to <code>outfp</code>.
</p>
<hr>
<a name="GtStr"></a>
<h2>Class GtStr</h2>

<p> Objects of the <code>GtStr</code> class are strings which grow on demand. </p>

<hr>
<a name="gt_str_new"></a>

<code>GtStr*   gt_str_new(void)</code>
<p>
Return an empty <code>GtStr</code> object.
</p>
<hr>
<a name="gt_str_new_cstr"></a>

<code>GtStr*   gt_str_new_cstr(const char *cstr)</code>
<p>
Return a new <code>GtStr</code> object whose content is set to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_clone"></a>

<code>GtStr*   gt_str_clone(const GtStr *str)</code>
<p>
Return a clone of <code>str</code>.
</p>
<hr>
<a name="gt_str_ref"></a>

<code>GtStr*   gt_str_ref(GtStr *str)</code>
<p>
Increase the reference count for <code>str</code> and return it.
   If <code>str</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<a name="gt_str_get"></a>

<code>char*    gt_str_get(const GtStr *str)</code>
<p>
Return the content of <code>str</code>.  Never returns NULL, and the content is always
   <code>\0</code>-terminated
</p>
<hr>
<a name="gt_str_set"></a>

<code>void     gt_str_set(GtStr *str, const char *cstr)</code>
<p>
Set the content of <code>str</code> to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_append_str"></a>

<code>void     gt_str_append_str(GtStr *dest, const GtStr *src)</code>
<p>
Append the string <code>src</code> to <code>dest</code>.
</p>
<hr>
<a name="gt_str_append_cstr"></a>

<code>void     gt_str_append_cstr(GtStr *str, const char *cstr)</code>
<p>
Append the <code>\0</code>-terminated <code>cstr</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_cstr_nt"></a>

<code>void     gt_str_append_cstr_nt(GtStr *str, const char *cstr, GtUword length)</code>
<p>
Append the (not necessarily <code>\0</code>-terminated) <code>cstr</code> with given <code>length</code> to
   <code>str</code>.
</p>
<hr>
<a name="gt_str_append_char"></a>

<code>void     gt_str_append_char(GtStr *str, char c)</code>
<p>
Append character <code>c</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_double"></a>

<code>void     gt_str_append_double(GtStr *str, double d, int precision)</code>
<p>
Append double <code>d</code> to <code>str</code> with given <code>precision</code>.
</p>
<hr>
<a name="gt_str_append_ulong"></a>

<code>void     gt_str_append_ulong(GtStr *str, GtUword ulong)</code>
<p>
Append <code>ulong</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_int"></a>

<code>void     gt_str_append_int(GtStr *str, int intval)</code>
<p>
Append <code>intval</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_uint"></a>

<code>void     gt_str_append_uint(GtStr *str, unsigned int uint)</code>
<p>
Append <code>uint</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_set_length"></a>

<code>void     gt_str_set_length(GtStr *str, GtUword length)</code>
<p>
Set length of <code>str</code> to <code>length</code>. <code>length</code> must be smaller or equal than
   <code>gt_str_length(str)</code>.
</p>
<hr>
<a name="gt_str_reset"></a>

<code>void     gt_str_reset(GtStr *str)</code>
<p>
Reset <code>str</code> to length 0.
</p>
<hr>
<a name="gt_str_cmp"></a>

<code>int      gt_str_cmp(const GtStr *str1, const GtStr *str2)</code>
<p>
Compare <code>str1</code> and <code>str2</code> and return the result (similar to <code>strcmp(3)</code>).
</p>
<hr>
<a name="gt_str_length"></a>

<code>GtUword  gt_str_length(const GtStr *str)</code>
<p>
Return the length of <code>str</code>. If <code>str</code> is <code>NULL</code>, 0 is returned.
</p>
<hr>
<a name="gt_str_delete"></a>

<code>void     gt_str_delete(GtStr *str)</code>
<p>
Decrease the reference count for <code>str</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GtStrArray"></a>
<h2>Class GtStrArray</h2>

<p> <code>GtStrArray*</code> objects are arrays of string which grow on demand. </p>

<hr>
<a name="gt_str_array_new"></a>

<code>GtStrArray*    gt_str_array_new(void)</code>
<p>
Return a new <code>GtStrArray</code> object.
</p>
<hr>
<a name="gt_str_array_ref"></a>

<code>GtStrArray*    gt_str_array_ref(GtStrArray*)</code>
<p>
Increases the reference to a GtStrArray.
</p>
<hr>
<a name="gt_str_array_add_cstr"></a>

<code>void           gt_str_array_add_cstr(GtStrArray *str_array, const char *cstr)</code>
<p>
Add <code>cstr</code> to <code>str_array</code>. Thereby, an internal copy of <code>cstr</code> is created.
</p>
<hr>
<a name="gt_str_array_add_cstr_nt"></a>

<code>void           gt_str_array_add_cstr_nt(GtStrArray *str_array, const char *cstr,
                                       GtUword length)</code>
<p>
Add the non <code>\0</code>-terminated <code>cstr</code> with given <code>length</code> to <code>str_array</code>.
   Thereby, an internal copy of <code>cstr</code> is created.
</p>
<hr>
<a name="gt_str_array_add"></a>

<code>void           gt_str_array_add(GtStrArray *str_array, const GtStr *str)</code>
<p>
Add <code>str</code> to <code>str_array</code>. Thereby, an internal copy of <code>str</code> is created.
</p>
<hr>
<a name="gt_str_array_get"></a>

<code>const char*    gt_str_array_get(const GtStrArray *str_array,
                               GtUword strnum)</code>
<p>
Return pointer to internal string with number <code>strnum</code> of <code>str_array</code>.
   <code>strnum</code> must be smaller than <code>gt_str_array_size(str_array)</code>.
</p>
<hr>
<a name="gt_str_array_set_cstr"></a>

<code>void           gt_str_array_set_cstr(GtStrArray *str_array, GtUword strnum,
                                    const char *cstr)</code>
<p>
Set the string with number <code>strnum</code> in <code>str_array</code> to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_array_set"></a>

<code>void           gt_str_array_set(GtStrArray *str_array, GtUword strnum,
                               const GtStr *str)</code>
<p>
Set the string with number <code>strnum</code> in <code>str_array</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_array_set_size"></a>

<code>void           gt_str_array_set_size(GtStrArray *str_array, GtUword size)</code>
<p>
Set the size of <code>str_array</code> to <code>size</code>. <code>size</code> must be smaller or equal than
   <code>gt_str_array_size(str_array)</code>.
</p>
<hr>
<a name="gt_str_array_reset"></a>

<code>void           gt_str_array_reset(GtStrArray *str_array)</code>
<p>
Set the size of <code>str_array</code> to 0.
</p>
<hr>
<a name="gt_str_array_size"></a>

<code>GtUword  gt_str_array_size(const GtStrArray *str_array)</code>
<p>
Return the number of strings stored in <code>str_array</code>.
</p>
<hr>
<a name="gt_str_array_delete"></a>

<code>void           gt_str_array_delete(GtStrArray *str_array)</code>
<p>
Delete <code>str_array</code>.
</p>
<hr>
<a name="GtStrand"></a>
<h2>Class GtStrand</h2>

<p> This enum type defines the possible strands. The following strands are
   defined: <code>GT_STRAND_FORWARD</code>, <code>GT_STRAND_REVERSE</code>, <code>GT_STRAND_BOTH</code>, and
   <code>GT_STRAND_UNKNOWN</code>. </p>

<hr>
<a name="GT_STRAND_CHARS"></a>

<code>#define GT_STRAND_CHARS</code>
<p>
Use this string to map strand enum types to their corresponding character.
</p>
<hr>
<a name="gt_strand_get"></a>

<code>GtStrand  gt_strand_get(char strand_char)</code>
<p>
Map <code>strand_char</code> to the corresponding strand enum type.
   Returns <code>GT_NUM_OF_STRAND_TYPES</code> if <code>strand_char</code> is not a valid one.
</p>
<hr>
<a name="GtStyle"></a>
<h2>Class GtStyle</h2>

<p> Objects of the <code>GtStyle</code> class hold <em>AnnotationSketch</em> style information
   like colors, margins, collapsing options, and others. The class provides
   methods to set values of various types. Each value is organized into
   a <em>section</em> and is identified by a <em>key</em>. That is, a <em>section</em>, <em>key</em>
   pair must uniquely identify a value. </p>

<hr>
<a name="gt_style_new"></a>

<code>GtStyle*            gt_style_new(GtError*)</code>
<p>
Creates a new <code>GtStyle</code> object.
</p>
<hr>
<a name="gt_style_ref"></a>

<code>GtStyle*            gt_style_ref(GtStyle*)</code>
<p>
Increments the reference count of the given <code>GtStyle</code>.
</p>
<hr>
<a name="gt_style_unsafe_mode"></a>

<code>void                gt_style_unsafe_mode(GtStyle*)</code>
<p>
Enables unsafe mode (``io'' and ``os'' libraries loaded).
</p>
<hr>
<a name="gt_style_safe_mode"></a>

<code>void                gt_style_safe_mode(GtStyle*)</code>
<p>
Enables safe mode (``io'' and ``os'' libraries not accessible).
</p>
<hr>
<a name="gt_style_is_unsafe"></a>

<code>bool                gt_style_is_unsafe(GtStyle *sty)</code>
<p>
Returns true if <code>sty</code> is in unsafe mode.
</p>
<hr>
<a name="gt_style_clone"></a>

<code>GtStyle*            gt_style_clone(const GtStyle*, GtError*)</code>
<p>
Creates a independent (``deep'') copy of the given <code>GtStyle</code> object.
</p>
<hr>
<a name="gt_style_load_file"></a>

<code>int                 gt_style_load_file(GtStyle*, const char *filename, GtError*)</code>
<p>
Loads and executes Lua style file with given <code>filename</code>.
   This file must define a global table called <em>style</em>.
</p>
<hr>
<a name="gt_style_load_str"></a>

<code>int                 gt_style_load_str(GtStyle*, GtStr *instr, GtError*)</code>
<p>
Loads and executes Lua style code from the given <code>GtStr</code> <code>instr</code>.
   This code must define a global table called <em>style</em>.
</p>
<hr>
<a name="gt_style_to_str"></a>

<code>int                 gt_style_to_str(const GtStyle*, GtStr *outstr, GtError*)</code>
<p>
Generates Lua code which represents the given <code>GtStyle</code> object and
   writes it into the <code>GtStr</code> object <code>outstr</code>.
</p>
<hr>
<a name="gt_style_reload"></a>

<code>void                gt_style_reload(GtStyle*)</code>
<p>
Reloads the Lua style file.
</p>
<hr>
<a name="gt_style_set_color"></a>

<code>void                gt_style_set_color(GtStyle*, const char *section,
                                      const char *key, const GtColor *color)</code>
<p>
Sets a color value in the <code>GtStyle</code> for section <code>section</code> and <code>key</code> to a
   certain <code>color</code>.
</p>
<hr>
<a name="gt_style_get_color"></a>

<code>GtStyleQueryStatus  gt_style_get_color(const GtStyle *style, const char *section,
                                      const char *key, GtColor *result,
                                      GtFeatureNode *fn, GtError *err)</code>
<p>
Retrieves a color value from <code>style</code> for key <code>key</code> in section <code>section</code>.
   The color is written to the location pointed to by <code>result</code>. Optionally, a
   feature node pointer <code>fn</code> can be specified for handling in node-specific
   callbacks.
   Because color definitions can be functions, <code>gt_style_get_color()</code> can fail
   at runtime. In this case, this function returns GT_STYLE_QUERY_ERROR and
   <code>err</code> is set accordingly.
   If the color was not specified in <code>style</code>, a grey default color
   is written to <code>result</code> and GT_STYLE_QUERY_NOT_SET is returned so the caller
   can provide a custom default.
   In case of successful retrieval of an existing color, GT_STYLE_QUERY_OK
   is returned.
</p>
<hr>
<a name="gt_style_get_color_with_track"></a>

<code>GtStyleQueryStatus  gt_style_get_color_with_track(const GtStyle *style,
                                                 const char *section,
                                                 const char *key,
                                                 GtColor *result,
                                                 GtFeatureNode *fn,
                                                 const GtStr *track_id,
                                                 GtError *err)</code>
<p>
Identical to <code>gt_style_get_color()</code>, except that it also takes a <code>track_id</code>
   which is passed to a potential callback function in the style file.
</p>
<hr>
<a name="gt_style_set_str"></a>

<code>void                gt_style_set_str(GtStyle*, const char *section,
                                    const char *key, GtStr *value)</code>
<p>
Set string with key <code>key</code> in <code>section</code> to <code>value</code>.
</p>
<hr>
<a name="gt_style_get_str"></a>

<code>GtStyleQueryStatus  gt_style_get_str(const GtStyle *style, const char *section,
                                    const char *key, GtStr *result,
                                    GtFeatureNode *fn, GtError *err)</code>
<p>
Retrieves a string value from <code>style</code> for key <code>key</code> in section <code>section</code>.
   The string is written to the <code>GtStr</code> object <code>result</code>, overwriting its prior
   contents. Optionally, a feature node pointer <code>fn</code> can be specified for
   handling in node-specific callbacks.
   Because color definitions can be functions, <code>gt_style_get_str()</code> can fail at
   runtime. In this case, this function returns GT_STYLE_QUERY_ERROR and <code>err</code>
   is set accordingly.
   If the string was not specified in <code>style</code>, <code>result</code> is left untouched and
   GT_STYLE_QUERY_NOT_SET is returned so the caller can handle this case.
   In case of successful retrieval of an existing string, GT_STYLE_QUERY_OK
   is returned.
</p>
<hr>
<a name="gt_style_get_str_with_track"></a>

<code>GtStyleQueryStatus  gt_style_get_str_with_track(const GtStyle *style,
                                               const char *section,
                                               const char *key,
                                               GtStr *result,
                                               GtFeatureNode *fn,
                                               const GtStr *track_id,
                                               GtError *err)</code>
<p>
Identical to <code>gt_style_get_str()</code>, except that it also takes a <code>track_id</code>
   which is passed to a potential callback function in the style file.
</p>
<hr>
<a name="gt_style_set_num"></a>

<code>void                gt_style_set_num(GtStyle*, const char *section,
                                    const char *key, double number)</code>
<p>
Set numeric value of key <code>key</code> in <code>section</code> to <code>number</code>.
</p>
<hr>
<a name="gt_style_get_num"></a>

<code>GtStyleQueryStatus  gt_style_get_num(const GtStyle *style, const char *section,
                                    const char *key, double *result,
                                    GtFeatureNode *fn, GtError *err)</code>
<p>
Retrieves a numeric value from <code>style</code> for key <code>key</code> in section <code>section</code>.
   The value is written to the location pointed to by <code>result</code>. Optionally, a
   feature node pointer <code>fn</code> can be specified for handling in node-specific
   callbacks.
   Because the definitions can be functions, <code>gt_style_get_num()</code> can fail at
   runtime. In this case, this function returns GT_STYLE_QUERY_ERROR and <code>err</code>
   is set accordingly.
   If the number was not specified in <code>style</code>, <code>result</code> is left untouched and
   GT_STYLE_QUERY_NOT_SET is returned so the caller can handle this case.
   In case of successful retrieval of an existing number, GT_STYLE_QUERY_OK
   is returned.
</p>
<hr>
<a name="gt_style_get_num_with_track"></a>

<code>GtStyleQueryStatus  gt_style_get_num_with_track(const GtStyle *style,
                                               const char *section,
                                               const char *key,
                                               double *result,
                                               GtFeatureNode *fn,
                                               const GtStr *track_id,
                                               GtError *err)</code>
<p>
Identical to <code>gt_style_get_num()</code>, except that it also takes a <code>track_id</code>
   which is passed to a potential callback function in the style file.
</p>
<hr>
<a name="gt_style_set_bool"></a>

<code>void                gt_style_set_bool(GtStyle*, const char *section,
                                     const char *key, bool val)</code>
<p>
Set boolean value of key <code>key</code> in <code>section</code> to <code>val</code>.
</p>
<hr>
<a name="gt_style_get_bool"></a>

<code>GtStyleQueryStatus  gt_style_get_bool(const GtStyle *style, const char *section,
                                     const char *key, bool *result,
                                     GtFeatureNode *fn, GtError *err)</code>
<p>
Retrieves a boolean value from <code>style</code> for key <code>key</code> in section <code>section</code>.
   The value is written to the location pointed to by <code>result</code>. Optionally, a
   feature node pointer <code>fn</code> can be specified for handling in node-specific
   callbacks.
   Because the definitions can be functions, <code>gt_style_get_bool()</code> can fail at
   runtime. In this case, this function returns GT_STYLE_QUERY_ERROR and <code>err</code>
   is set accordingly.
   If the value was not specified in <code>style</code>, <code>result</code> is left untouched and
   GT_STYLE_QUERY_NOT_SET is returned so the caller can handle this case.
   In case of successful retrieval of an existing boolean, GT_STYLE_QUERY_OK
   is returned.
</p>
<hr>
<a name="gt_style_get_bool_with_track"></a>

<code>GtStyleQueryStatus  gt_style_get_bool_with_track(const GtStyle *style,
                                                const char *section,
                                                const char *key,
                                                bool *result,
                                                GtFeatureNode *fn,
                                                const GtStr *track_id,
                                                GtError *err)</code>
<p>
Identical to <code>gt_style_get_bool()</code>, except that it also takes a <code>track_id</code>
   which is passed to a potential callback function in the style file.
</p>
<hr>
<a name="gt_style_unset"></a>

<code>void                gt_style_unset(GtStyle*, const char *section,
                                  const char *key)</code>
<p>
Unset value of key <code>key</code> in <code>section</code>.
</p>
<hr>
<a name="gt_style_delete"></a>

<code>void                gt_style_delete(GtStyle *style)</code>
<p>
Deletes this <code>style</code>.
</p>
<hr>
<a name="GtTagValueMap"></a>
<h2>Class GtTagValueMap</h2>

<p> A very simple tag/value map absolutely optimized for space (i.e., memory
   consumption) on the cost of time. Basically, each read/write access costs
   O(n) time, whereas n denotes the accumulated length of all tags and values
   contained in the map. Tags and values cannot have length 0.</p><p>   The implementation as a char* shines through (also to save one additional
   memory allocation), therefore the usage is a little bit different compared
   to other <em>GenomeTools</em> classes.
   See the implementation of <code>gt_tag_value_map_example()</code> for an ussage
   example. </p>

<hr>
<a name="GtTagValueMapIteratorFunc"></a>

<code>void  GtTagValueMapIteratorFunc(const char *tag, const char *value,
                                          void *data)</code>
<p>
Iterator function used to iterate over tag/value maps. A <code>tag</code>/<code>value</code> pair
   and user <code>data</code> are given as arguments.
</p>
<hr>
<a name="gt_tag_value_map_new"></a>

<code>GtTagValueMap  gt_tag_value_map_new(const char *tag, const char *value)</code>
<p>
Return a new <code>GtTagValueMap</code> object which stores the given <code>tag</code>/<code>value</code>
   pair.
</p>
<hr>
<a name="gt_tag_value_map_add"></a>

<code>void           gt_tag_value_map_add(GtTagValueMap *tag_value_map,
                                   const char *tag,
                                   const char *value)</code>
<p>
Add <code>tag</code>/<code>value</code> pair to <code>tag_value_map</code>. <code>tag_value_map</code> must not contain
   the given <code>tag</code> already!
</p>
<hr>
<a name="gt_tag_value_map_set"></a>

<code>void           gt_tag_value_map_set(GtTagValueMap *tag_value_map,
                                   const char *tag, const char *value)</code>
<p>
Set the given <code>tag</code> in <code>tag_value_map</code> to <code>value</code>.
</p>
<hr>
<a name="gt_tag_value_map_get"></a>

<code>const char*    gt_tag_value_map_get(const GtTagValueMap tag_value_map,
                                   const char *tag)</code>
<p>
Return value corresponding to <code>tag</code> from <code>tag_value_map</code>. If <code>tag_value_map</code>
   does not contain such a value, <code>NULL</code> is returned.
</p>
<hr>
<a name="gt_tag_value_map_remove"></a>

<code>void           gt_tag_value_map_remove(GtTagValueMap *tag_value_map,
                                      const char *tag)</code>
<p>
Removes the given <code>tag</code> from <code>tag_value_map</code>. <code>tag_value_map</code> must contain
   the given <code>tag</code> already!
</p>
<hr>
<a name="gt_tag_value_map_foreach"></a>

<code>void           gt_tag_value_map_foreach(const GtTagValueMap tag_value_map,
                                       GtTagValueMapIteratorFunc iterator_func,
                                       void *data)</code>
<p>
Apply <code>iterator_func</code> to each tag/value pair contained in <code>tag_value_map</code> and
   pass <code>data</code> along.
</p>
<hr>
<a name="gt_tag_value_map_example"></a>

<code>int            gt_tag_value_map_example(GtError *err)</code>
<p>
Implements an example useage of a tag/value map.
</p>
<hr>
<a name="gt_tag_value_map_delete"></a>

<code>void           gt_tag_value_map_delete(GtTagValueMap tag_value_map)</code>
<p>
Delete <code>tag_value_map</code>.
</p>
<hr>
<a name="GtTextWidthCalculator"></a>
<h2>Class GtTextWidthCalculator</h2>

<p> The GtTextWidthCalculator interface answers queries w.r.t.
   text width in a specific drawing backend. This interface is needed to do
   proper line breaking in a <code>GtLayout</code> even if there is no <code>GtCanvas</code> or
   <code>GtGraphics</code> created yet. </p>

<hr>
<a name="gt_text_width_calculator_ref"></a>

<code>GtTextWidthCalculator*  gt_text_width_calculator_ref(GtTextWidthCalculator*)</code>
<p>
Increases the reference count of the <code>GtTextWidthCalculator</code>.
</p>
<hr>
<a name="gt_text_width_calculator_get_text_width"></a>

<code>double                  gt_text_width_calculator_get_text_width(
                                                    GtTextWidthCalculator*,
                                                    const char *text,
                                                    GtError *err)</code>
<p>
Requests the width of <code>text</code> from the <code>GtTextWidthCalculator</code>.
   If the returned value is negative, an error occurred. Otherwise,
   a positive double value is returned.
</p>
<hr>
<a name="gt_text_width_calculator_delete"></a>

<code>void                    gt_text_width_calculator_delete(GtTextWidthCalculator*)</code>
<p>
Deletes a <code>GtTextWidthCalculator</code> instance.
</p>
<hr>
<a name="GtTextWidthCalculatorCairo"></a>
<h2>Class GtTextWidthCalculatorCairo</h2>

<p> Implements the GtTextWidthCalculator interface with Cairo as the drawing
   backend. If text width is to be calculated with regard to a specific
   transformation etc. which is in effect in a <code>cairo_t</code> and which should be
   used later via a <code>GtCanvasCairoContext</code>, create a
   <code>GtTextWidthCalculatorCairo</code> object and pass it to the <code>GtLayout</code> via
   <code>gt_layout_new_with_twc()</code>. </p>

<hr>
<a name="gt_text_width_calculator_cairo_new"></a>

<code>GtTextWidthCalculator*  gt_text_width_calculator_cairo_new(cairo_t*, GtStyle*,
                                                          GtError*)</code>
<p>
Creates a new <code>GtTextWidthCalculatorCairo</code> object for the given context
   using the text size options given in the <code>GtStyle</code>. If the <code>GtStyle</code> is NULL,
   the current font settings in the <code>cairo_t</code> will be used for all text
   width calculations.
</p>
<hr>
<a name="GtThread"></a>
<h2>Class GtThread</h2>

<p> The <code>GtThread</code> class represents a handle to a single thread of execution. </p>

<hr>
<a name="GtThreadFunc"></a>

<code>void*  GtThreadFunc(void *data)</code>
<p>
A function to be multithreaded.
</p>
<hr>
<a name="gt_thread_new"></a>

<code>GtThread*  gt_thread_new(GtThreadFunc function, void *data, GtError *err)</code>
<p>
Create a new thread which executes the given <code>function</code> (with <code>data</code> passed
   to it). Returns a <code>GtThread*</code> handle to the newly created thread, if
   successful. Returns NULL and sets <code>err</code> accordingly upon failure.
</p>
<hr>
<a name="gt_thread_delete"></a>

<code>void       gt_thread_delete(GtThread *thread)</code>
<p>
Delete the given <code>thread</code> handle. Does not stop the thread itself!
</p>
<hr>
<a name="gt_thread_join"></a>

<code>void       gt_thread_join(GtThread *thread)</code>
<p>
Wait for <code>thread</code> to terminate before continuing execution of the current
   thread.
</p>
<hr>
<a name="GtTimer"></a>
<h2>Class GtTimer</h2>

<p> The <code>GtTimer</code> class encapsulates a timer which can be used for run-time
   measurements. </p>

<hr>
<a name="gt_timer_new"></a>

<code>GtTimer*  gt_timer_new(void)</code>
<p>
Return a new <code>GtTimer</code> object.
</p>
<hr>
<a name="gt_timer_new_with_progress_description"></a>

<code>GtTimer*  gt_timer_new_with_progress_description(const char* description)</code>
<p>
Return a new <code>GtTimer</code> object with the first <code>description</code>.
</p>
<hr>
<a name="gt_timer_start"></a>

<code>void      gt_timer_start(GtTimer *timer)</code>
<p>
Start the time measurement on <code>timer</code>.
</p>
<hr>
<a name="gt_timer_stop"></a>

<code>void      gt_timer_stop(GtTimer *timer)</code>
<p>
Stop the time measurement on <code>timer</code>.
</p>
<hr>
<a name="gt_timer_show"></a>

<code>void      gt_timer_show(GtTimer *timer, FILE *fp)</code>
<p>
Output the current state of <code>timer</code> in the format
   ""GT_WD".%06lds real "GT_WD"s user "GT_WD"s system" to file
   pointer <code>fp</code> (see <code>gt_timer_show_formatted</code>).
   The timer is then stopped.
</p>
<hr>
<a name="gt_timer_show_formatted"></a>

<code>void      gt_timer_show_formatted(GtTimer *timer, const char *fmt, FILE *fp)</code>
<p>
Output the current state of <code>timer</code> in a user-defined format given by <code>fmt</code>.
   <code>fmt</code> must be a format string for four "GT_WD" numbers, which are filled
   with: elapsed seconds, elapsed microseconds, used usertime in seconds, system
   time in seconds. The output is written to <code>fp</code>. The timer is then stopped.
</p>
<hr>
<a name="gt_timer_show_progress"></a>

<code>void      gt_timer_show_progress(GtTimer *timer, const char *desc, FILE *fp)</code>
<p>
Output the current state of <code>timer</code> on <code>fp</code> since the last call of
   <code>gt_timer_show_progress()</code> or the last start of <code>timer</code>, along with the
   current description. The timer is not stopped, but updated with <code>desc</code> to be
   the next description.
</p>
<hr>
<a name="gt_timer_show_progress_formatted"></a>

<code>void      gt_timer_show_progress_formatted(GtTimer *timer, FILE *fp,
                                          const char *desc, ...)</code>
<p>
Like <code>gt_timer_show_progress()</code>, but allows one to format the description in
   a <code>printf()</code>-like fashion.
</p>
<hr>
<a name="gt_timer_show_progress_va"></a>

<code>void      gt_timer_show_progress_va(GtTimer *timer, FILE *fp, const char *desc,
                                   va_list ap)</code>
<p>
Like <code>gt_timer_show_progress()</code>, but allows one to format the description in
   a <code>vprintf()</code>-like fashion using a va_list argument <code>ap</code>.
</p>
<hr>
<a name="gt_timer_show_progress_final"></a>

<code>void      gt_timer_show_progress_final(GtTimer *timer, FILE *fp)</code>
<p>
Output the overall time measured with <code>timer</code> from start to now on <code>fp</code>.
</p>
<hr>
<a name="gt_timer_show_cpu_time_by_progress"></a>

<code>void      gt_timer_show_cpu_time_by_progress(GtTimer *timer)</code>
<p>
Show also user and sys time in output of
   <code>gt_timer_show_progress[_final]()</code>.
</p>
<hr>
<a name="gt_timer_omit_last_stage"></a>

<code>void      gt_timer_omit_last_stage(GtTimer *timer)</code>
<p>
Hide output of last stage time in <code>gt_timer_show_progress_final()</code>.
</p>
<hr>
<a name="gt_timer_delete"></a>

<code>void      gt_timer_delete(GtTimer *timer)</code>
<p>
Delete <code>timer</code>.
</p>
<hr>
<a name="GtTool"></a>
<h2>Class GtTool</h2>

<p> The <code>GtTool</code> class encapsulates a single <em>GenomeTools</em> tool. Can also be
   used in external applications based on <code>libgenometools</code>. </p>

<hr>
<a name="GtToolArgumentsNew"></a>

<code>void*            GtToolArgumentsNew(void)</code>
<p>
Callback function. Must return memory to be used as a storage space
   for tool arguments.
</p>
<hr>
<a name="GtToolArgumentsDelete"></a>

<code>void             GtToolArgumentsDelete(void *tool_arguments)</code>
<p>
Callback function. Must free up all memory reserved by the
   <code>GtToolArgumentsNew</code> function in <code>tool_arguments</code>.
</p>
<hr>
<a name="GtToolOptionParserNew"></a>

<code>GtOptionParser*  GtToolOptionParserNew(void *tool_arguments)</code>
<p>
Callback function. Must return a new <code>GtOptionParser</code> filling
   <code>tool_arguments</code> with content.
</p>
<hr>
<a name="GtToolArgumentsCheck"></a>

<code>int              GtToolArgumentsCheck(int rest_argc,
                                                void *tool_arguments,
                                                GtError *err)</code>
<p>
Callback function. Checks the validity of <code>tool_arguments</code> when <code>rest_argc</code>
   additional parameters are given to the tool command line.
   Must return zero if checks are successful, and a negative value otherwise.
   In that case <code>err</code> should be set accordingly.
</p>
<hr>
<a name="GtToolRunner"></a>

<code>int              GtToolRunner(int argc, const char **argv,
                                        int parsed_args, void *tool_arguments,
                                        GtError*)</code>
<p>
Callback function. Acts as a main entry point for the tool logic.
   Parameters <code>argc</code> and <code>argv</code> are similar to a regular <code>main()</code> function.
   The <code>parsed_args</code> parameter gives the number of parameters already parsed
   by the option parser before additional parameters start. Use <code>tool_arguments</code>
   to access options set by the option parser and write errors to <code>err</code>.
   This function should return the error status of the tool (i.e. 0 for
   success). If the return value is not equal to 0, errors written to <code>err</code>
   will be printed on stderr.
</p>
<hr>
<a name="GtToolConstructor"></a>

<code>GtTool*          GtToolConstructor(void)</code>
<p>
Returns a new self-contained <code>GtTool</code>.
</p>
<hr>
<a name="gt_tool_new"></a>

<code>GtTool*  gt_tool_new(GtToolArgumentsNew tool_arguments_new,
                    GtToolArgumentsDelete tool_arguments_delete,
                    GtToolOptionParserNew tool_option_parser_new,
                    GtToolArgumentsCheck tool_arguments_check,
                    GtToolRunner tool_runner)</code>
<p>
Create a new tool object, with
   a tool argument constructor <code>gt_tool_arguments_new</code> (optional),
   a tool argument destructor <code>gt_tool_arguments_delete</code> (optional).
   a tool option parser constructor <code>gt_tool_option_parser_new</code> (required),
   a tool argument checker <code>gt_tool_arguments_check</code> (optional),
   a tool runner <code>gt_tool_runner</code> (required), and
   <code>tool_arguments_new</code> and <code>tool_arguments_delete</code> imply each other.
   Returns a new GtTool object.
</p>
<hr>
<a name="gt_tool_run"></a>

<code>int      gt_tool_run(GtTool*, int argc, const char **argv, GtError *err)</code>
<p>
Run the given <code>tool</code> as follows:
   1. Create a tool arguments object, if necessary.
   2. Create a new option parser and pass the tool arguments along.
   3. Parse the options (<code>argc</code> and <code>argv</code>) with the created option parser.
      Return upon error, continue otherwise.
   4. Check the tool arguments, if necessary.
      Return upon error, continue otherwise.
   5. Run the actual tool with the given arguments (the tool arguments object
      is passed along).
   6. Delete the tool arguments object, if one was created.
      Returns -1 and sets <code>err</code> on error, returns 0 otherwise.
</p>
<hr>
<a name="gt_tool_delete"></a>

<code>void     gt_tool_delete(GtTool*)</code>
<p>
Delete the given <code>tool</code>.
</p>
<hr>
<a name="GtToolbox"></a>
<h2>Class GtToolbox</h2>

<p> The <code>GtToolbox</code> class groups several tools into one and can be used to
   structure <em>GenomeTools</em> into sensible sets of subtools. </p>

<hr>
<a name="gt_toolbox_new"></a>

<code>GtToolbox*  gt_toolbox_new(void)</code>
<p>
Return a new empty <code>GtToolbox</code>.
</p>
<hr>
<a name="gt_toolbox_add_tool"></a>

<code>void        gt_toolbox_add_tool(GtToolbox *toolbox, const char *toolname,
                               GtTool *tool)</code>
<p>
Add <code>tool</code> with name <code>toolname</code> to <code>toolbox</code>. Takes ownership of <code>tool</code>.
</p>
<hr>
<a name="gt_toolbox_add_hidden_tool"></a>

<code>void        gt_toolbox_add_hidden_tool(GtToolbox *toolbox, const char *toolname,
                                      GtTool *tool)</code>
<p>
Add (hidden) <code>tool</code> with name <code>toolname</code> to <code>toolbox</code>. Hidden tools are not
   shown in the output of <code>gt_toolbox_show()</code>. Takes ownership of <code>tool</code>.
</p>
<hr>
<a name="gt_toolbox_get_tool"></a>

<code>GtTool*     gt_toolbox_get_tool(GtToolbox *toolbox, const char *toolname)</code>
<p>
Get <code>GtTool</code> with name <code>toolname</code> from <code>toolbox</code>. Returns NULL if tool does
   not exist in <code>toolbox</code>.
</p>
<hr>
<a name="gt_toolbox_show"></a>

<code>int         gt_toolbox_show(const char *progname, void *toolbox, GtError*)</code>
<p>
Show all tools in <code>toolbox</code> except the hidden ones. Intended to be used
   as an argument to <code>gt_option_parser_set_comment_func()</code>.
</p>
<hr>
<a name="gt_toolbox_delete"></a>

<code>void        gt_toolbox_delete(GtToolbox *toolbox)</code>
<p>
Deletes <code>toolbox</code>.
</p>
<hr>
<a name="GtTransTable"></a>
<h2>Class GtTransTable</h2>
<a name="gt_trans_table_get_scheme_descriptions"></a>

<code>GtStrArray*    gt_trans_table_get_scheme_descriptions(void)</code>
<p>
Returns a <code>GtStrArray</code> of translation scheme descriptions, each of the
   format "%d: %s" where the number is the translation scheme number (usable in
   <code>gt_translator_set_translation_scheme()</code> and the string is the scheme
   name.
</p>
<hr>
<a name="gt_trans_table_new"></a>

<code>GtTransTable*  gt_trans_table_new(unsigned int scheme, GtError *err)</code>
<p>
Returns a translation table as given by <code>scheme</code> which refers to the numbers
   as reported by <code>gt_translator_get_translation_table_descriptions()</code> or the
   list given at the NCBI web site
   <em>http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</em>.
   Returns NULL if an error occurred, see <code>err</code> for details.
</p>
<hr>
<a name="gt_trans_table_new_standard"></a>

<code>GtTransTable*  gt_trans_table_new_standard(GtError *err)</code>
<p>
Returns the standard translation table.
</p>
<hr>
<a name="gt_trans_table_description"></a>

<code>const char*    gt_trans_table_description(const GtTransTable *tt)</code>
<p>
Returns the description of <code>tt</code>.
</p>
<hr>
<a name="gt_trans_table_translate_codon"></a>

<code>int            gt_trans_table_translate_codon(const GtTransTable *tt,
                                             char c1, char c2, char c3,
                                             char *amino, GtError *err)</code>
<p>
Writes the translation for the codon <code>c1</code>,<code>c2</code>,<code>c3</code> to the position pointed
   to by <code>amino</code>. The current translation scheme set in <code>translator</code> is used.
   Returns a negative value if an error occurred, see <code>err</code> for details.
   Otherwise, 0 is returned.
</p>
<hr>
<a name="gt_trans_table_delete"></a>

<code>void           gt_trans_table_delete(GtTransTable *tt)</code>
<p>
Deletes <code>tt</code>.
</p>
<hr>
<a name="GtTranslator"></a>
<h2>Class GtTranslator</h2>

<p> The <code>GtTranslator</code> can be used to  produce 3-frame translations of DNA
   sequences via an iterator interface. </p>

<hr>
<a name="gt_translator_new_with_table"></a>

<code>GtTranslator*       gt_translator_new_with_table(GtTransTable *tt,
                                                GtCodonIterator *ci)</code>
<p>
Creates a new <code>GtTranslator</code>, starting its translation at the current
   position of <code>ci</code>. The current reading frame is also taken from the state of
   <code>ci</code>. The translation table <code>tt</code> is used.
</p>
<hr>
<a name="gt_translator_new"></a>

<code>GtTranslator*       gt_translator_new(GtCodonIterator *ci)</code>
<p>
Creates a new <code>GtTranslator</code>, starting its translation at the current
   position of <code>ci</code>. The current reading frame is also taken from the state of
   <code>ci</code>. The standard translation table is used.
</p>
<hr>
<a name="gt_translator_set_codon_iterator"></a>

<code>void                gt_translator_set_codon_iterator(GtTranslator *translator,
                                                    GtCodonIterator *ci)</code>
<p>
Reinitializes <code>translator</code> with the position and frame status as given in
   <code>ci</code>.
</p>
<hr>
<a name="gt_translator_set_translation_table"></a>

<code>void                gt_translator_set_translation_table(GtTranslator *translator,
                                                       GtTransTable *tt)</code>
<p>
Selects the translation scheme in <code>translator</code> to the one identified by
   translation table <code>tt</code>.
</p>
<hr>
<a name="gt_translator_next"></a>

<code>GtTranslatorStatus  gt_translator_next(GtTranslator *translator,
                                      char *translated,
                                      unsigned int *frame,
                                      GtError *err)</code>
<p>
Returns the translation of the next codon. The currently translated
   character is put in <code>translated</code> while the current reading frame is put in
   <code>frame</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to translate has been reached,
   GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_startcodon"></a>

<code>GtTranslatorStatus  gt_translator_find_startcodon(GtTranslator *translator,
                                                 GtUword *pos,
                                                 GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which is a start codon according to the selected translation
   scheme in <code>translator</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding a
   start codon, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_stopcodon"></a>

<code>GtTranslatorStatus  gt_translator_find_stopcodon(GtTranslator *translator,
                                                GtUword *pos,
                                                GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which is a stop codon according to the selected translation
   scheme in <code>translator</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding a
   stop codon, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_codon"></a>

<code>GtTranslatorStatus  gt_translator_find_codon(GtTranslator *translator,
                                            GtStrArray *codons,
                                            GtUword *pos,
                                            GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which belongs to the set of codons specified in <code>codons</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding
   one of the codons, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_delete"></a>

<code>void                gt_translator_delete(GtTranslator *translator)</code>
<p>
Delete <code>translator</code>.
</p>
<hr>
<a name="GtTypeChecker"></a>
<h2>Class GtTypeChecker</h2>

<p> The <code>GtTypeChecker</code> interface, allows one to check the validity of (genome
   feature) types. </p>

<hr>
<a name="gt_type_checker_ref"></a>

<code>GtTypeChecker*  gt_type_checker_ref(GtTypeChecker *type_checker)</code>
<p>
Increase the reference count for <code>type_checker</code> and return it.
</p>
<hr>
<a name="gt_type_checker_description"></a>

<code>const char*     gt_type_checker_description(GtTypeChecker *type_checker)</code>
<p>
Return description of <code>type_checker</code>.
</p>
<hr>
<a name="gt_type_checker_is_valid"></a>

<code>bool            gt_type_checker_is_valid(GtTypeChecker *type_checker,
                                        const char *type)</code>
<p>
Return <code>true</code> if <code>type</code> is a valid type for the given <code>type_checker</code>, <code>false</code>
   otherwise.
</p>
<hr>
<a name="gt_type_checker_is_partof"></a>

<code>bool            gt_type_checker_is_partof(GtTypeChecker *type_checker,
                                         const char *parent_type,
                                         const char *child_type)</code>
<p>
Return <code>true</code> if <code>child_type</code> is partof <code>parent_type</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_type_checker_is_a"></a>

<code>bool            gt_type_checker_is_a(GtTypeChecker *type_checker,
                                    const char *parent_type,
                                    const char *child_type)</code>
<p>
Return <code>true</code> if <code>child_type</code> is a <code>parent_type</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_type_checker_delete"></a>

<code>void            gt_type_checker_delete(GtTypeChecker *type_checker)</code>
<p>
Decrease the reference count for <code>type_checker</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtTypeCheckerOBO"></a>
<h2>Class GtTypeCheckerOBO</h2>

<p> Implements the <code>GtTypeChecker</code> interface with types from an OBO file. </p>

<hr>
<a name="gt_type_checker_obo_new"></a>

<code>GtTypeChecker*  gt_type_checker_obo_new(const char *obo_file_path, GtError *err)</code>
<p>
Create a new <code>GtTypeChecker*</code> for OBO file with given <code>obo_file_path</code>.
   If the OBO file cannot be parsed correctly, <code>NULL</code> is returned and <code>err</code> is
   set correspondingly.
</p>
<hr>
<a name="GtUniqStream"></a>
<h2>Class GtUniqStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtUniqStream</code> filters out
   repeated features it retrieves from its node source. </p>

<hr>
<a name="gt_uniq_stream_new"></a>

<code>GtNodeStream*  gt_uniq_stream_new(GtNodeStream*)</code>
<p>
Create a <code>GtUniqStream</code> object which filters out repeated feature node graphs
   it retrieves from the sorted <code>in_stream</code> and return all other nodes.  Two
   feature node graphs are considered to be <em>repeated</em> if they have the same
   depth-first traversal and each corresponding feature node pair is similar
   according to the <code>gt_feature_node_is_similar()</code> method. For such a repeated
   feature node graph the one with the higher score (of the top-level feature)
   is kept. If only one of the feature node graphs has a defined score, this one
   is kept.
</p>
<hr>
<a name="GtVisitorStream"></a>
<h2>Class GtVisitorStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_visitor_stream_new"></a>

<code>GtNodeStream*  gt_visitor_stream_new(GtNodeStream *in_stream,
                                    GtNodeVisitor *node_visitor)</code>
<p>
Create a new <code>GtVisitorStream*</code>, takes ownership of <code>node_visitor</code>.
   This stream applies <code>node_visitor</code> to each node which passes through it.
   Can be used to implement all streams with such a functionality.
</p>
<hr>
<a name="GtXRFChecker"></a>
<h2>Class GtXRFChecker</h2>

<p> The <code>GtXRFChecker</code> interface, allows one to check the validity of
   Dbxref and Ontology_type attributes. </p>

<hr>
<a name="gt_xrf_checker_new"></a>

<code>GtXRFChecker*  gt_xrf_checker_new(const char *file_path, GtError *err)</code>
<p>
Create a new <code>GtXRFChecker</code> from the definitions found in <code>file_path</code>.
   Returns NULL on error, and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_xrf_checker_ref"></a>

<code>GtXRFChecker*  gt_xrf_checker_ref(GtXRFChecker *xrf_checker)</code>
<p>
Increase reference count for <code>xrf_checker</code>
</p>
<hr>
<a name="gt_xrf_checker_is_valid"></a>

<code>bool           gt_xrf_checker_is_valid(GtXRFChecker *xrf_checker,
                                      const char *value, GtError *err)</code>
<p>
Return <code>true</code> if <code>value</code> is valid for the given <code>xrf_checker</code>,
   <code>false</code> otherwise. In case of <code>value</code> being invalid, <code>err</code> is
   set accordingly.
</p>
<hr>
<a name="gt_xrf_checker_delete"></a>

<code>void           gt_xrf_checker_delete(GtXRFChecker *xrf_checker)</code>
<p>
Decrease the reference count for <code>xrf_checker</code> or delete it.
</p>
<hr>
<a name="Array2dim"></a>
<h2>Module Array2dim</h2>
<a name="gt_array2dim_malloc"></a>

<code>#define gt_array2dim_malloc(ARRAY2DIM, ROWS, COLUMNS)</code>
<p>
Allocates a new 2-dimensional array with dimensions <code>ROWS</code> x <code>COLUMNS</code> and
   assigns a pointer to the newly allocated space to <code>ARRAY2DIM</code>.
   The size of each element is determined automatically from the type of the
   <code>ARRAY2DIM</code> pointer.
</p>
<hr>
<a name="gt_array2dim_calloc"></a>

<code>#define gt_array2dim_calloc(ARRAY2DIM, ROWS, COLUMNS)</code>
<p>
Allocates a new 2-dimensional array with dimensions <code>ROWS</code> x <code>COLUMNS</code> and
   assigns a pointer to the newly allocated space to <code>ARRAY2DIM</code>.
   The allocated space is initialized to be filled with zeroes.
   The size of each element is determined automatically from the type of the
   <code>ARRAY2DIM</code> pointer.
</p>
<hr>
<a name="gt_array2dim_example"></a>

<code>int      gt_array2dim_example(GtError*)</code>
<p>
An example for usage of the <code>Array2dim</code> module.
</p>
<hr>
<a name="gt_array2dim_delete"></a>

<code>#define gt_array2dim_delete(ARRAY2DIM)</code>
<p>
Frees the space allocated for the 2-dimensional array pointed to by
   <code>ARRAY2DIM</code>.
</p>
<hr>
<a name="Assert"></a>
<h2>Module Assert</h2>
<a name="gt_assert"></a>

<code>#define gt_assert(expression)</code>
<p>
The <code>gt_assert()</code> macro tests the given <code>expression</code> and if it is false, the
   calling process is terminated. A diagnostic message is written to <code>stderr</code>
   and the <code>exit(3)</code> function is called (with error code 2 as argument),
   effectively terminating the program.
   If <code>expression</code> is true, the <code>gt_assert()</code> macro does nothing.
</p>
<hr>
<a name="Bsearch"></a>
<h2>Module Bsearch</h2>
<a name="gt_bsearch_data"></a>

<code>void*  gt_bsearch_data(const void *key, const void *base, size_t nmemb,
                      size_t size, GtCompareWithData, void *data)</code>
<p>
Similar interface to <code>bsearch(3)</code>, except that the <code>GtCompareWithData</code>
   function gets an additional <code>data</code> pointer.
</p>
<hr>
<a name="gt_bsearch_all"></a>

<code>void   gt_bsearch_all(GtArray *members, const void *key, const void *base,
                     size_t nmemb, size_t size, GtCompareWithData, void *data)</code>
<p>
Similar interface to <code>gt_bsearch_data()</code>, except that all members which
   compare as equal are stored in the <code>members</code> array. The order in which the
   elements are added is undefined.
</p>
<hr>
<a name="gt_bsearch_all_mark"></a>

<code>void   gt_bsearch_all_mark(GtArray *members, const void *key, const void *base,
                          size_t nmemb, size_t size, GtCompareWithData,
                          void *data, GtBittab*)</code>
<p>
Similar interface to <code>gt_bsearch_all()</code>. Additionally, if a bittab is given
   (which must be of size <code>nmemb</code>), the bits corresponding to the found
   elements are marked (i.e., set).
</p>
<hr>
<a name="BytePopcount"></a>
<h2>Module BytePopcount</h2>
<a name="gt_byte_popcount[256]"></a>
<code>extern const unsigned char  gt_byte_popcount[256]</code>
<p>
Lookup table containing the popcount (number of set bits). Entry at <code>i</code>
   equals popcount(<code>i</code>).
</p>
<hr>
<a name="ByteSelect"></a>
<h2>Module ByteSelect</h2>
<a name="gt_byte_select[2048]"></a>
<code>extern const unsigned char  gt_byte_select[2048]</code>
<p>
Contains 256 * 8 select values, Entry at index 256 * <code>j</code> + <code>i</code> equals the
   position of the (<code>j</code> + 1)-th set bit in byte <code>i</code>. Positions lie in the range
   [0..7]. Returns 8 if byte <code>i</code> contains less than <code>j</code> set bits.
</p>
<hr>
<a name="Countingsort"></a>
<h2>Module Countingsort</h2>
<a name="gt_countingsort"></a>

<code>void           gt_countingsort(void *out, const void *in, size_t elem_size,
                              GtUword size, GtUword max_elemvalue,
                              void *data, GtGetElemvalue get_elemvalue)</code>
<p>
Sort the array of elements pointed to by <code>in</code> containing <code>size</code> many elements
   of size <code>elem_size</code> and store the result in the array <code>out</code> of the same size.
   <code>max_elemvalue</code> denotes the maximum value an element can have.
   <code>get_elemvalue</code> should return an integer value for the given element <code>elem</code>.

   Implements the counting sort algorithm.
   For a description see for example page 175 to page 177 of the book:

   T.H. Cormen, C.E. Leiserson and R.L. Rivest. <em>Introduction to Algorithms</em>.
   MIT Press: Cambridge, MA, 1990.
</p>
<hr>
<a name="gt_countingsort_get_max"></a>

<code>GtUword  gt_countingsort_get_max(const void *in, size_t elem_size,
                                      GtUword size, void *data,
                                      GtGetElemvalue get_elemvalue)</code>
<p>
If <code>max_elemvalue</code> is not known, it can be determined with this function.
</p>
<hr>
<a name="Cstr"></a>
<h2>Module Cstr</h2>
<a name="gt_cstr_dup"></a>

<code>char*    gt_cstr_dup(const char *cstr)</code>
<p>
Creates a duplicate of string <code>cstr</code> using the <em>GenomeTools</em> memory
   allocator.
</p>
<hr>
<a name="gt_cstr_split"></a>

<code>char**   gt_cstr_split(const char *cstr, char sep)</code>
<p>
Splits the \0-terminated <code>cstr</code> at all positions where <code>sep</code> occurs and
   returns a C string array in which each element is a separate string between
   the occurrences of <code>sep</code>. The string array is terminated by NULL. The caller
   is responsible to free the result.
</p>
<hr>
<a name="gt_cstr_dup_nt"></a>

<code>char*    gt_cstr_dup_nt(const char *cstr, GtUword length)</code>
<p>
Creates a duplicate of string <code>cstr</code> using the <em>GenomeTools</em> memory
   allocator. The string needs not be \0-terminated, instead its <code>length</code> must
   be given.
</p>
<hr>
<a name="gt_cstr_rep"></a>

<code>void     gt_cstr_rep(char *cstr, char f, char t)</code>
<p>
Replace each occurence of <code>f</code> in <code>cstr</code> to <code>t</code>.
</p>
<hr>
<a name="gt_cstr_show"></a>

<code>void     gt_cstr_show(const char *cstr, GtUword length, FILE *outfp)</code>
<p>
Outputs the first <code>length</code> characters of the string <code>cstr</code> to file pointer
   <code>outfp</code>.
</p>
<hr>
<a name="gt_cstr_length_up_to_char"></a>

<code>GtUword  gt_cstr_length_up_to_char(const char *cstr, char c)</code>
<p>
Returns the length of the prefix of <code>cstr</code> ending just before <code>c</code>, if <code>cstr</code>
   does not contain <code>c</code>, strlen(cstr) is returned.
</p>
<hr>
<a name="gt_cstr_rtrim"></a>

<code>char*    gt_cstr_rtrim(char* cstr, char remove)</code>
<p>
Removes all occurrences of <code>remove</code> from the right end of <code>cstr</code>.
</p>
<hr>
<a name="Endianess"></a>
<h2>Module Endianess</h2>
<a name="gt_is_little_endian"></a>

<code>bool  gt_is_little_endian(void)</code>
<p>
Returns <code>true</code> if host CPU is little-endian, <code>false</code> otherwise.
</p>
<hr>
<a name="FASTA"></a>
<h2>Module FASTA</h2>
<a name="gt_fasta_show_entry"></a>

<code>void  gt_fasta_show_entry(const char *description, const char *sequence,
                         GtUword sequence_length, GtUword width, GtFile *outfp)</code>
<p>
Print a fasta entry with optional <code>description</code> and mandatory <code>sequence</code> to
   <code>outfp</code>. If <code>width</code> is != 0 the sequence is formatted accordingly.
</p>
<hr>
<a name="Fileutils"></a>
<h2>Module Fileutils</h2>
<a name="gt_file_suffix"></a>

<code>const char*  gt_file_suffix(const char *path)</code>
<p>
Returns the suffix of <code>path</code>, if there is any. Returns "" otherwise.
   The suffix is the part after and including the last '.' but after the last
   '/' (or '\' on Windows). Except if <code>path</code> ends with ".gz" or ".bz2", then the
   suffix is the part after and including the second last '.'.
</p>
<hr>
<a name="gt_file_exists"></a>

<code>bool         gt_file_exists(const char *path)</code>
<p>
Returns true if the file with the given <code>path</code> exists, false otherwise.
</p>
<hr>
<a name="gt_file_exists_with_suffix"></a>

<code>bool         gt_file_exists_with_suffix(const char *path, const char *suffix)</code>
<p>
Returns true if the file with the name composed of the concatenation of
   <code>path</code> and <code>suffix</code> exists, false otherwise.
</p>
<hr>
<a name="gt_file_is_newer"></a>

<code>bool         gt_file_is_newer(const char *a, const char *b)</code>
<p>
Returns true if the file with path <code>a</code> has a later modification time than the
   file with path <code>b</code>, false otherwise.
</p>
<hr>
<a name="gt_file_number_of_lines"></a>

<code>GtUword      gt_file_number_of_lines(const char*)</code>
<p>
Returns the number of lines in a file.
</p>
<hr>
<a name="gt_file_dirname"></a>

<code>void         gt_file_dirname(GtStr *path, const char *file)</code>
<p>
Set <code>path</code> to the dirname of <code>file</code>, if it has one, to "" otherwise.
</p>
<hr>
<a name="gt_file_find_in_path"></a>

<code>int          gt_file_find_in_path(GtStr *path, const char *file, GtError*)</code>
<p>
Find <code>file</code> in $PATH, if it has no dirname; set <code>path</code> to dirname otherwise.
   Sets <code>path</code> to the empty string if <code>file</code> could not be found in $PATH.
</p>
<hr>
<a name="gt_file_find_in_env"></a>

<code>int          gt_file_find_in_env(GtStr *path, const char *file, const char *env,
                                GtError*)</code>
<p>
Find  <code>file</code> in the ':'-separated directory list (on Windows ';'-separated)
   specified in environment variable $<code>env</code>, if it has no dirname; set <code>path</code> to
   dirname otherwise. Sets <code>path</code> to the empty string if <code>file</code> could not be
   found in $<code>env</code>.
</p>
<hr>
<a name="gt_file_estimate_size"></a>

<code>off_t        gt_file_estimate_size(const char *file)</code>
<p>
Return the (estimated) size of <code>file</code>. If <code>file</code> is uncompressed, the exact
   size is returned. If <code>file</code> is compressed, an estimation which assumes that
   <code>file</code> contains a DNA sequence is returned.
</p>
<hr>
<a name="gt_files_estimate_total_size"></a>

<code>off_t        gt_files_estimate_total_size(const GtStrArray *filenames)</code>
<p>
Return the (estimated) total size of all files given in <code>filenames</code>.
   Uses <code>gt_file_estimate_size()</code>.
</p>
<hr>
<a name="gt_files_guess_if_protein_sequences"></a>

<code>int          gt_files_guess_if_protein_sequences(const GtStrArray *filenames,
                                                GtError *err)</code>
<p>
Guesse if the sequences contained in the files given in <code>filenames</code> are
   protein sequences. Returns 1 if the guess is that the files contain protein
   sequences. Returns 0 if the guess is that the files contain DNA sequences.
   Returns -1 if an error occurs while reading the files (<code>err</code> is set
   accordingly).
</p>
<hr>
<a name="gt_file_find_exec_in_path"></a>

<code>int          gt_file_find_exec_in_path(GtStr *path, const char *file,
                                      GtError *err)</code>
<p>
Find regular executable <code>file</code> in $PATH, if it has no dirname; set <code>path</code> to
   dirname otherwise. Sets <code>path</code> to the empty string if regular executable
   <code>file</code> could not be found in $PATH.
</p>
<hr>
<a name="gt_file_size"></a>

<code>off_t        gt_file_size(const char *file)</code>
<p>
Return the size of <code>file</code> in bytes. <code>file</code> must exist.
</p>
<hr>
<a name="gt_file_size_with_suffix"></a>

<code>off_t        gt_file_size_with_suffix(const char *path, const char *suffix)</code>
<p>
Returns the size of the file whose name is composed of the
  concatenation of <code>path</code> and <code>suffix</code>. <code>file</code> must exist.
</p>
<hr>
<a name="FunctionPointer"></a>
<h2>Module FunctionPointer</h2>
<a name="GtCompare"></a>

<code>int   GtCompare(const void *a, const void *b)</code>
<p>
Functions of this type return less than 0 if <code>a</code> is <em>smaller</em> than <code>b</code>,
   0 if <code>a</code> is <em>equal</em> to <code>b</code>, and greater 0 if <code>a</code> is <em>larger</em> than <code>b</code>.
   Thereby, the operators <em>smaller</em>, <em>equal</em>, and <em>larger</em> are
   implementation dependent.
   Do not count on these functions to return -1, 0, or 1!
</p>
<hr>
<a name="GtCompareWithData"></a>

<code>int   GtCompareWithData(const void*, const void*, void *data)</code>
<p>
Similar to <code>GtCompare</code>, but with an additional <code>data</code> pointer.
</p>
<hr>
<a name="GtFree"></a>

<code>void  GtFree(void*)</code>
<p>
The generic free function pointer type.
</p>
<hr>
<a name="Grep"></a>
<h2>Module Grep</h2>
<a name="gt_grep"></a>

<code>int  gt_grep(bool *match, const char *pattern, const char *line, GtError*)</code>
<p>
Set <code>match</code> to <code>true</code> if <code>pattern</code> matches <code>line</code>, to <code>false</code> otherwise.
</p>
<hr>
<a name="gt_grep_nt"></a>

<code>int  gt_grep_nt(bool *match, const char *pattern, const char *line, size_t len,
               GtError *err)</code>
<p>
Set <code>match</code> to <code>true</code> if <code>pattern</code> matches <code>line</code> up to <code>len</code>, to <code>false</code>
   otherwise.
</p>
<hr>
<a name="Init"></a>
<h2>Module Init</h2>
<a name="gt_lib_init"></a>

<code>void  gt_lib_init(void)</code>
<p>
Initialize this <em>GenomeTools</em> library instance.
   This has to be called before the library is used!
</p>
<hr>
<a name="gt_lib_reg_atexit_func"></a>

<code>void  gt_lib_reg_atexit_func(void)</code>
<p>
Registers exit function which calls <code>gt_lib_clean()</code> at exit.
</p>
<hr>
<a name="gt_lib_clean"></a>

<code>int   gt_lib_clean(void)</code>
<p>
Returns 0 if no memory map, file pointer, or memory has been leaked and a
   value != 0 otherwise.
</p>
<hr>
<a name="Log"></a>
<h2>Module Log</h2>
<a name="gt_log_enable"></a>

<code>void  gt_log_enable(void)</code>
<p>
Enable logging.
</p>
<hr>
<a name="gt_log_enabled"></a>

<code>bool  gt_log_enabled(void)</code>
<p>
Returns true if logging is enabled, false otherwise
</p>
<hr>
<a name="gt_log_log"></a>

<code>void   gt_log_log(const char *format, ...)</code>
<p>
Prints the log message obtained from format and following parameters
   according if logging is enabled. The logging output is prefixed with the
   string "debug: " and finished by a newline.
</p>
<hr>
<a name="gt_log_vlog"></a>

<code>void   gt_log_vlog(const char *format, va_list)</code>
<p>
Prints the log message obtained from format and following parameter according
   to if logging is enabled analog to <code>gt_log_log()</code>. But in contrast to
   <code>gt_log_log()</code> <code>gt_log_vlog()</code> does not accept individual arguments but a single
   va_list argument instead.
</p>
<hr>
<a name="gt_log_fp"></a>

<code>FILE*  gt_log_fp(void)</code>
<p>
Return logging file pointer.
</p>
<hr>
<a name="gt_log_set_fp"></a>

<code>void   gt_log_set_fp(FILE *fp)</code>
<p>
Set logging file pointer to <code>fp</code>.
</p>
<hr>
<a name="MD5Fingerprint"></a>
<h2>Module MD5Fingerprint</h2>
<a name="gt_md5_fingerprint"></a>

<code>char*  gt_md5_fingerprint(const char *sequence, GtUword seqlen)</code>
<p>
Returns an MD5 fingerprint of <code>sequence</code> with length <code>seqlen</code> transformed to
   upper case letters (with toupper(3)).
   It is the responsibility of the caller to free the returned string.
</p>
<hr>
<a name="MemoryAllocation"></a>
<h2>Module MemoryAllocation</h2>
<a name="gt_malloc"></a>

<code>#define gt_malloc(size)</code>
<p>
Allocate <strong>uninitialized</strong> space for an object whose size is specified by
   <code>size</code> and return it.
   Besides the fact that it never returns <code>NULL</code> analog to <code>malloc(3)</code>.
</p>
<hr>
<a name="gt_calloc"></a>

<code>#define gt_calloc(nmemb, size)</code>
<p>
Allocate contiguous space for an array of <code>nmemb</code> objects, each of whose size
   is <code>size</code>.  The space is initialized to zero.
   Besides the fact that it never returns <code>NULL</code> analog to <code>calloc(3)</code>.
</p>
<hr>
<a name="gt_realloc"></a>

<code>#define gt_realloc(ptr, size)</code>
<p>
Change the size of the object pointed to by <code>ptr</code> to <code>size</code> bytes and return
   a pointer to the (possibly moved) object.
   Besides the fact that it never returns <code>NULL</code> analog to <code>realloc(3)</code>.
</p>
<hr>
<a name="gt_free"></a>

<code>#define gt_free(ptr)</code>
<p>
Free the space pointed to by <code>ptr</code>. If <code>ptr</code> equals <code>NULL</code>, no action occurs.
   Analog to <code>free(3)</code>.
</p>
<hr>
<a name="gt_free_func"></a>

<code>void           gt_free_func(void *ptr)</code>
<p>
Analog to <code>gt_free()</code>, but usable as a function pointer.
</p>
<hr>
<a name="Msort"></a>
<h2>Module Msort</h2>
<a name="gt_msort"></a>

<code>void  gt_msort(void *base, size_t nmemb, size_t size, GtCompare compar)</code>
<p>
Sorts an array of <code>nmemb</code> elements, each of size <code>size</code>, according to compare
   function <code>compar</code>. Uses the merge sort algorithm, the interface equals
   <code>qsort(3)</code>.
</p>
<hr>
<a name="gt_msort_r"></a>

<code>void  gt_msort_r(void *base, size_t nmemb, size_t size, void *comparinfo,
                GtCompareWithData compar)</code>
<p>
Identical to <code>gt_msort()</code> except that the compare function is of
   <code>GtCompareWithData</code> type accepting <code>comparinfo</code> as arbitrary data.
</p>
<hr>
<a name="Multithread"></a>
<h2>Module Multithread</h2>
<a name="gt_multithread"></a>

<code>int        gt_multithread(GtThreadFunc function, void *data, GtError *err)</code>
<p>
Execute <code>function</code> (with <code>data</code> passed to it) in <code>gt_jobs</code> many parallel
   threads, if threading is enabled. Otherwise <code>function</code> is executed <code>gt_jobs</code>
   many times sequentially. <code>gt_jobs</code> is a global <code>unsigned int</code> variable.
</p>
<hr>
<a name="POSIX"></a>
<h2>Module POSIX</h2>
<a name="gt_basename"></a>

<code>char*  gt_basename(const char *path)</code>
<p>
This module implements the function <code>gt_basename()</code> according to the
  specifications in
  http://www.unix-systems.org/onlinepubs/7908799/xsh/basename.html
  and
  http://www.opengroup.org/onlinepubs/009695399/

  <code>gt_basename()</code> is equivalent to the function basename(3) which
  is available on most unix systems, but in different libraries and
  with slightly different functionality.

  <code>gt_basename()</code> takes the pathname pointed to by <code>path</code> and returns a pointer to
  the final component of the pathname, deleting any trailing '/' characters.

  If <code>path</code> consists entirely of the '/' character,  then <code>gt_basename()</code> returns
  a pointer to the string "/".

  On Windows '\' is used instead of '/'.

  If <code>path</code> is a null pointer or points to an empty string, <code>gt_basename()</code>
  returns a pointer to the string ".".

  See the implementation of <code>gt_basename_unit_test()</code> for additional examples.

  The caller is responsible for freeing the received pointer!
</p>
<hr>
<a name="Parseutils"></a>
<h2>Module Parseutils</h2>
<a name="gt_parse_int"></a>

<code>int  gt_parse_int(int *out, const char *nptr)</code>
<p>
Parse integer from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_uint"></a>

<code>int  gt_parse_uint(unsigned int *out, const char *nptr)</code>
<p>
Parse unsigned integer from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_long"></a>

<code>int  gt_parse_long(GtWord *out, const char *nptr)</code>
<p>
Parse long from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_ulong"></a>

<code>int  gt_parse_ulong(GtUword *out, const char *nptr)</code>
<p>
Parse GtUword from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_double"></a>

<code>int  gt_parse_double(double *out, const char *nptr)</code>
<p>
Parse double from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_range"></a>

<code>int  gt_parse_range(GtRange *rng, const char *start, const char *end,
                   unsigned int line_number, const char *filename, GtError*)</code>
<p>
Parse a range given by <code>start</code> and <code>end</code>, writing the result into <code>rng</code>.
   Enforces that <code>start</code> is smaller or equal than <code>end</code>. Give <code>filename</code> and
   <code>line_number</code> for error reporting. Returns 0 upon success and -1 upon
   failure.
</p>
<hr>
<a name="gt_parse_range_tidy"></a>

<code>int  gt_parse_range_tidy(GtRange *rng, const char *start, const char *end,
                        unsigned int line_number, const char *filename,
                        GtError*)</code>
<p>
Like <code>gt_parse_range</code>, but issues a warning if <code>start</code> is larger then <code>end</code>
   and swaps both values. It also issues a warning, if <code>start</code> and/or <code>end</code> is
   not-positive and sets the corresponding value to 1.
</p>
<hr>
<a name="Qsort"></a>
<h2>Module Qsort</h2>
<a name="gt_qsort_r"></a>

<code>void  gt_qsort_r(void *a, size_t n, size_t es, void *data,
                GtCompareWithData cmp)</code>
<p>
Like <code>qsort(3)</code>, but allows an additional <code>data</code> pointer passed to the
   <code>GtCompareWithData</code> comparison function <code>cmp</code>.
</p>
<hr>
<a name="Reverse"></a>
<h2>Module Reverse</h2>
<a name="gt_reverse_complement"></a>

<code>int  gt_reverse_complement(char *dna_seq, GtUword seqlen, GtError*)</code>
<p>
Reverse <code>dna_seq</code> of length <code>seqlen</code> in place.
</p>
<hr>
<a name="Strcmp"></a>
<h2>Module Strcmp</h2>
<a name="gt_strcmp"></a>

<code>int  gt_strcmp(const char *s1, const char *s2)</code>
<p>
Returns 0 if <code>s1</code> == <code>s2</code>, otherwise the equivalent of <code>strcmp(s1,s2)</code>.
   Useful as a performance improvement in some cases (for example, to compare
   symbols).
</p>
<hr>
<a name="Symbol"></a>
<h2>Module Symbol</h2>
<a name="gt_symbol"></a>

<code>const char*  gt_symbol(const char *cstr)</code>
<p>
Return a symbol (a canonical representation) for <code>cstr</code>. An advantage of
   symbols is that they can be compared for equality by a simple pointer
   comparison, rather than using <code>strcmp()</code> (as it is done in <code>gt_strcmp()</code>).
   Furthermore, a symbol is stored only once in memory for equal <code>cstr</code>s, but
   keep in mind that this memory can never be freed safely during the lifetime
   of the calling program. Therefore, it should only be used for a small set of
   <code>cstr</code>s.
</p>
<hr>
<a name="Threads"></a>
<h2>Module Threads</h2>
<a name="gt_jobs"></a>
<code>extern unsigned int  gt_jobs</code>
<p>
Number of parallel threads to be used.
</p>
<hr>
<a name="Undef"></a>
<h2>Module Undef</h2>
<a name="GT_UNDEF_BOOL"></a>

<code>#define GT_UNDEF_BOOL</code>
<p>
The undefined <code>bool</code> value.
</p>
<hr>
<a name="GT_UNDEF_CHAR"></a>

<code>#define GT_UNDEF_CHAR</code>
<p>
The undefined <code>char</code> value.
</p>
<hr>
<a name="GT_UNDEF_DOUBLE"></a>

<code>#define GT_UNDEF_DOUBLE</code>
<p>
The undefined <code>double</code> value.
</p>
<hr>
<a name="GT_UNDEF_FLOAT"></a>

<code>#define GT_UNDEF_FLOAT</code>
<p>
The undefined <code>float</code> value.
</p>
<hr>
<a name="GT_UNDEF_INT"></a>

<code>#define GT_UNDEF_INT</code>
<p>
The undefined <code>int</code> value.
</p>
<hr>
<a name="GT_UNDEF_WORD"></a>

<code>#define GT_UNDEF_WORD</code>
<p>
The undefined <code>GtWord</code> value.
</p>
<hr>
<a name="GT_UNDEF_LONG"></a>

<code>#define GT_UNDEF_LONG</code>
<p>
The undefined <code>long</code> value. deprecated
</p>
<hr>
<a name="GT_UNDEF_UCHAR"></a>

<code>#define GT_UNDEF_UCHAR</code>
<p>
The undefined <code>unsigned char</code> value.
</p>
<hr>
<a name="GT_UNDEF_UINT"></a>

<code>#define GT_UNDEF_UINT</code>
<p>
The undefined <code>unsigned int</code> value.
</p>
<hr>
<a name="GT_UNDEF_UWORD"></a>

<code>#define GT_UNDEF_UWORD</code>
<p>
The undefined <code>GtUword</code> value.
</p>
<hr>
<a name="GT_UNDEF_ULONG"></a>

<code>#define GT_UNDEF_ULONG</code>
<p>
The undefined <code>unsigned long</code> value. deprecated
</p>
<hr>
<a name="Unused"></a>
<h2>Module Unused</h2>
<a name="GT_UNUSED"></a>

<code>#define GT_UNUSED</code>
<p>
Unused function arguments should be annotated with this macro to get rid of
   compiler warnings.
</p>
<hr>
<a name="Version"></a>
<h2>Module Version</h2>
<a name="gt_version_check"></a>

<code>const char*  gt_version_check(unsigned int required_major,
                             unsigned int required_minor,
                             unsigned int required_micro)</code>
<p>
Check that the <em>GenomeTools</em> library in use is compatible with the given
   version. Generally you would pass in the constants <code>GT_MAJOR_VERSION</code>,
   <code>GT_MINOR_VERSION</code>, and <code>GT_MICRO_VERSION</code> as the three arguments to this
   function.

   Returns <code>NULL</code> if the <em>GenomeTools</em> library is compatible with the given
   version, or a string describing the version mismatch, if the library is not
   compatible.
</p>
<hr>
<a name="gt_version"></a>

<code>const char*  gt_version(void)</code>
<p>
Return the version of the <em>GenomeTools</em> library in use as a string.
</p>
<hr>
<a name="Warning"></a>
<h2>Module Warning</h2>
<a name="GtWarningHandler"></a>

<code>void  GtWarningHandler(void *data, const char *format, va_list ap)</code>
<p>
Handler type used to process warnings.
</p>
<hr>
<a name="gt_warning"></a>

<code>void  gt_warning(const char *format, ...)</code>
<p>
Print a warning according to <code>format</code> and <code>...</code>, if a handler is set.
</p>
<hr>
<a name="gt_warning_disable"></a>

<code>void  gt_warning_disable(void)</code>
<p>
Disable that warnings are shown. That is, subsequent <code>gt_warning()</code> calls
   have no effect.
</p>
<hr>
<a name="gt_warning_set_handler"></a>

<code>void  gt_warning_set_handler(GtWarningHandler warn_handler, void *data)</code>
<p>
Set <code>warn_handler</code> to handle all warnings issued with <code>gt_warning()</code>.
   The <code>data</code> is passed to <code>warning_handler</code> on each invocation.
</p>
<hr>
<a name="gt_warning_default_handler"></a>

<code>void  gt_warning_default_handler(void *data, const char *format, va_list ap)</code>
<p>
The default warning handler which prints on <code>stderr</code>.
   "warning: " is prepended and a newline is appended to the message defined by
   <code>format</code> and <code>ap</code>. Does not use <code>data</code>.
</p>
<hr>
<a name="gt_warning_get_handler"></a>

<code>GtWarningHandler  gt_warning_get_handler(void)</code>
<p>
Return currently used <code>GtWarningHandler</code>.
</p>
<hr>
<a name="gt_warning_get_data"></a>

<code>void*  gt_warning_get_data(void)</code>
<p>
Return currently used <code>data</code> which is passed to the currently used
   <code>GtWarningHandler</code>.
</p>
<hr>
<a name="XANSI"></a>
<h2>Module XANSI</h2>
<a name="gt_xatexit"></a>

<code>void    gt_xatexit(void (*function)</code>
<p>
Similar to <code>atexit(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfclose"></a>

<code>void    gt_xfclose(FILE*)</code>
<p>
Similar to <code>fclose(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfflush"></a>

<code>void    gt_xfflush(FILE*)</code>
<p>
Similar to <code>fflush(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgetc"></a>

<code>int     gt_xfgetc(FILE*)</code>
<p>
Similar to <code>fgetc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgets"></a>

<code>char*   gt_xfgets(char *s, int size, FILE *stream)</code>
<p>
Similar to <code>fgets(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgetpos"></a>

<code>void    gt_xfgetpos(FILE*, fpos_t*)</code>
<p>
Similar to <code>fgetpos(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfopen"></a>

<code>FILE*   gt_xfopen(const char *path, const char *mode)</code>
<p>
Similar to <code>fopen(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfputc"></a>

<code>void    gt_xfputc(int, FILE*)</code>
<p>
Similar to <code>fputc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfputs"></a>

<code>void    gt_xfputs(const char*, FILE*)</code>
<p>
Similar to <code>fputs(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfread"></a>

<code>size_t  gt_xfread(void *ptr, size_t size, size_t nmemb, FILE *fp)</code>
<p>
Similar to <code>fread(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfread_one"></a>

<code>#define gt_xfread_one(ptr, fp)</code>
<p>
Shortcut to <code>gt_xfread()</code> which reads a single element of data (of size
   <code>sizeof (*ptr)</code>) from <code>fp</code> and stores the result in <code>ptr</code>.
</p>
<hr>
<a name="gt_xfseek"></a>

<code>void    gt_xfseek(FILE*, GtWord offset, int whence)</code>
<p>
Similar to <code>fseek(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfsetpos"></a>

<code>void    gt_xfsetpos(FILE*, const fpos_t*)</code>
<p>
Similar to <code>fsetpos(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfwrite"></a>

<code>void    gt_xfwrite(const void *ptr, size_t size, size_t nmemb, FILE *fp)</code>
<p>
Similar to <code>fwrite(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfwrite_one"></a>

<code>#define gt_xfwrite_one(ptr, fp)</code>
<p>
Shortcut to <code>gt_xfwrite()</code> which writes a single element of data (of size
   <code>sizeof (*ptr)</code>) from <code>ptr</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_xputchar"></a>

<code>void    gt_xputchar(int)</code>
<p>
Similar to <code>putchar(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xputs"></a>

<code>void    gt_xputs(const char*)</code>
<p>
Similar to <code>puts(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xremove"></a>

<code>void    gt_xremove(const char*)</code>
<p>
Similar to <code>remove(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xungetc"></a>

<code>void    gt_xungetc(int, FILE*)</code>
<p>
Similar to <code>ungetc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xvfprintf"></a>

<code>void    gt_xvfprintf(FILE *stream, const char *format, va_list ap)</code>
<p>
Similar to <code>vfprintf(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xvsnprintf"></a>

<code>int     gt_xvsnprintf(char *str, size_t size, const char *format, va_list ap)</code>
<p>
Similar to <code>vsnprintf(3)</code>, terminates on error.
</p>
<hr>
<a name="Index"></a>
<h2>Index</h2>

  <a href="#GT_OPTION_PARSER_TERMINAL_WIDTH"><code>GT_OPTION_PARSER_TERMINAL_WIDTH</code></a><br>

  <a href="#GT_PHASE_CHARS"><code>GT_PHASE_CHARS</code></a><br>

  <a href="#GT_STRAND_CHARS"><code>GT_STRAND_CHARS</code></a><br>

  <a href="#GT_UNDEF_BOOL"><code>GT_UNDEF_BOOL</code></a><br>

  <a href="#GT_UNDEF_CHAR"><code>GT_UNDEF_CHAR</code></a><br>

  <a href="#GT_UNDEF_DOUBLE"><code>GT_UNDEF_DOUBLE</code></a><br>

  <a href="#GT_UNDEF_FLOAT"><code>GT_UNDEF_FLOAT</code></a><br>

  <a href="#GT_UNDEF_INT"><code>GT_UNDEF_INT</code></a><br>

  <a href="#GT_UNDEF_LONG"><code>GT_UNDEF_LONG</code></a><br>

  <a href="#GT_UNDEF_UCHAR"><code>GT_UNDEF_UCHAR</code></a><br>

  <a href="#GT_UNDEF_UINT"><code>GT_UNDEF_UINT</code></a><br>

  <a href="#GT_UNDEF_ULONG"><code>GT_UNDEF_ULONG</code></a><br>

  <a href="#GT_UNDEF_UWORD"><code>GT_UNDEF_UWORD</code></a><br>

  <a href="#GT_UNDEF_WORD"><code>GT_UNDEF_WORD</code></a><br>

  <a href="#GT_UNUSED"><code>GT_UNUSED</code></a><br>

  <a href="#GtCompare"><code>GtCompare</code></a><br>

  <a href="#GtCompareWithData"><code>GtCompareWithData</code></a><br>

  <a href="#GtDiscDistriIterFunc"><code>GtDiscDistriIterFunc</code></a><br>

  <a href="#GtFeatureNodeAttributeIterFunc"><code>GtFeatureNodeAttributeIterFunc</code></a><br>

  <a href="#GtFree"><code>GtFree</code></a><br>

  <a href="#GtHashmapVisitFunc"><code>GtHashmapVisitFunc</code></a><br>

  <a href="#GtNodeStreamFreeFunc"><code>GtNodeStreamFreeFunc</code></a><br>

  <a href="#GtNodeStreamNextFunc"><code>GtNodeStreamNextFunc</code></a><br>

  <a href="#GtTagValueMapIteratorFunc"><code>GtTagValueMapIteratorFunc</code></a><br>

  <a href="#GtThreadFunc"><code>GtThreadFunc</code></a><br>

  <a href="#GtToolArgumentsCheck"><code>GtToolArgumentsCheck</code></a><br>

  <a href="#GtToolArgumentsDelete"><code>GtToolArgumentsDelete</code></a><br>

  <a href="#GtToolArgumentsNew"><code>GtToolArgumentsNew</code></a><br>

  <a href="#GtToolConstructor"><code>GtToolConstructor</code></a><br>

  <a href="#GtToolOptionParserNew"><code>GtToolOptionParserNew</code></a><br>

  <a href="#GtToolRunner"><code>GtToolRunner</code></a><br>

  <a href="#GtTrackOrderingFunc"><code>GtTrackOrderingFunc</code></a><br>

  <a href="#GtTrackSelectorFunc"><code>GtTrackSelectorFunc</code></a><br>

  <a href="#GtWarningHandler"><code>GtWarningHandler</code></a><br>

  <a href="#gt_add_introns_stream_new"><code>gt_add_introns_stream_new</code></a><br>

  <a href="#gt_alphabet_add_mapping"><code>gt_alphabet_add_mapping</code></a><br>

  <a href="#gt_alphabet_add_wildcard"><code>gt_alphabet_add_wildcard</code></a><br>

  <a href="#gt_alphabet_bits_per_symbol"><code>gt_alphabet_bits_per_symbol</code></a><br>

  <a href="#gt_alphabet_characters"><code>gt_alphabet_characters</code></a><br>

  <a href="#gt_alphabet_clone"><code>gt_alphabet_clone</code></a><br>

  <a href="#gt_alphabet_decode"><code>gt_alphabet_decode</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_cstr"><code>gt_alphabet_decode_seq_to_cstr</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_fp"><code>gt_alphabet_decode_seq_to_fp</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_str"><code>gt_alphabet_decode_seq_to_str</code></a><br>

  <a href="#gt_alphabet_delete"><code>gt_alphabet_delete</code></a><br>

  <a href="#gt_alphabet_echo_pretty_symbol"><code>gt_alphabet_echo_pretty_symbol</code></a><br>

  <a href="#gt_alphabet_encode"><code>gt_alphabet_encode</code></a><br>

  <a href="#gt_alphabet_encode_seq"><code>gt_alphabet_encode_seq</code></a><br>

  <a href="#gt_alphabet_equals"><code>gt_alphabet_equals</code></a><br>

  <a href="#gt_alphabet_guess"><code>gt_alphabet_guess</code></a><br>

  <a href="#gt_alphabet_is_dna"><code>gt_alphabet_is_dna</code></a><br>

  <a href="#gt_alphabet_is_protein"><code>gt_alphabet_is_protein</code></a><br>

  <a href="#gt_alphabet_new_dna"><code>gt_alphabet_new_dna</code></a><br>

  <a href="#gt_alphabet_new_empty"><code>gt_alphabet_new_empty</code></a><br>

  <a href="#gt_alphabet_new_from_file"><code>gt_alphabet_new_from_file</code></a><br>

  <a href="#gt_alphabet_new_from_file_no_suffix"><code>gt_alphabet_new_from_file_no_suffix</code></a><br>

  <a href="#gt_alphabet_new_from_sequence"><code>gt_alphabet_new_from_sequence</code></a><br>

  <a href="#gt_alphabet_new_from_string"><code>gt_alphabet_new_from_string</code></a><br>

  <a href="#gt_alphabet_new_protein"><code>gt_alphabet_new_protein</code></a><br>

  <a href="#gt_alphabet_num_of_chars"><code>gt_alphabet_num_of_chars</code></a><br>

  <a href="#gt_alphabet_output"><code>gt_alphabet_output</code></a><br>

  <a href="#gt_alphabet_pretty_symbol"><code>gt_alphabet_pretty_symbol</code></a><br>

  <a href="#gt_alphabet_ref"><code>gt_alphabet_ref</code></a><br>

  <a href="#gt_alphabet_size"><code>gt_alphabet_size</code></a><br>

  <a href="#gt_alphabet_symbolmap"><code>gt_alphabet_symbolmap</code></a><br>

  <a href="#gt_alphabet_to_file"><code>gt_alphabet_to_file</code></a><br>

  <a href="#gt_alphabet_to_str"><code>gt_alphabet_to_str</code></a><br>

  <a href="#gt_alphabet_valid_input"><code>gt_alphabet_valid_input</code></a><br>

  <a href="#gt_alphabet_wildcard_show"><code>gt_alphabet_wildcard_show</code></a><br>

  <a href="#gt_anno_db_gfflike_new"><code>gt_anno_db_gfflike_new</code></a><br>

  <a href="#gt_anno_db_schema_delete"><code>gt_anno_db_schema_delete</code></a><br>

  <a href="#gt_anno_db_schema_get_feature_index"><code>gt_anno_db_schema_get_feature_index</code></a><br>

  <a href="#gt_array2dim_calloc"><code>gt_array2dim_calloc</code></a><br>

  <a href="#gt_array2dim_delete"><code>gt_array2dim_delete</code></a><br>

  <a href="#gt_array2dim_example"><code>gt_array2dim_example</code></a><br>

  <a href="#gt_array2dim_malloc"><code>gt_array2dim_malloc</code></a><br>

  <a href="#gt_array_add"><code>gt_array_add</code></a><br>

  <a href="#gt_array_add_array"><code>gt_array_add_array</code></a><br>

  <a href="#gt_array_add_elem"><code>gt_array_add_elem</code></a><br>

  <a href="#gt_array_clone"><code>gt_array_clone</code></a><br>

  <a href="#gt_array_cmp"><code>gt_array_cmp</code></a><br>

  <a href="#gt_array_delete"><code>gt_array_delete</code></a><br>

  <a href="#gt_array_elem_size"><code>gt_array_elem_size</code></a><br>

  <a href="#gt_array_get"><code>gt_array_get</code></a><br>

  <a href="#gt_array_get_first"><code>gt_array_get_first</code></a><br>

  <a href="#gt_array_get_last"><code>gt_array_get_last</code></a><br>

  <a href="#gt_array_get_space"><code>gt_array_get_space</code></a><br>

  <a href="#gt_array_in_stream_new"><code>gt_array_in_stream_new</code></a><br>

  <a href="#gt_array_new"><code>gt_array_new</code></a><br>

  <a href="#gt_array_out_stream_all_new"><code>gt_array_out_stream_all_new</code></a><br>

  <a href="#gt_array_out_stream_new"><code>gt_array_out_stream_new</code></a><br>

  <a href="#gt_array_pop"><code>gt_array_pop</code></a><br>

  <a href="#gt_array_ref"><code>gt_array_ref</code></a><br>

  <a href="#gt_array_rem"><code>gt_array_rem</code></a><br>

  <a href="#gt_array_rem_span"><code>gt_array_rem_span</code></a><br>

  <a href="#gt_array_reset"><code>gt_array_reset</code></a><br>

  <a href="#gt_array_reverse"><code>gt_array_reverse</code></a><br>

  <a href="#gt_array_set_size"><code>gt_array_set_size</code></a><br>

  <a href="#gt_array_size"><code>gt_array_size</code></a><br>

  <a href="#gt_array_sort"><code>gt_array_sort</code></a><br>

  <a href="#gt_array_sort_stable"><code>gt_array_sort_stable</code></a><br>

  <a href="#gt_array_sort_stable_with_data"><code>gt_array_sort_stable_with_data</code></a><br>

  <a href="#gt_array_sort_with_data"><code>gt_array_sort_with_data</code></a><br>

  <a href="#gt_assert"><code>gt_assert</code></a><br>

  <a href="#gt_basename"><code>gt_basename</code></a><br>

  <a href="#gt_bed_in_stream_new"><code>gt_bed_in_stream_new</code></a><br>

  <a href="#gt_bed_in_stream_set_block_type"><code>gt_bed_in_stream_set_block_type</code></a><br>

  <a href="#gt_bed_in_stream_set_feature_type"><code>gt_bed_in_stream_set_feature_type</code></a><br>

  <a href="#gt_bed_in_stream_set_thick_feature_type"><code>gt_bed_in_stream_set_thick_feature_type</code></a><br>

  <a href="#gt_bittab_and"><code>gt_bittab_and</code></a><br>

  <a href="#gt_bittab_and_equal"><code>gt_bittab_and_equal</code></a><br>

  <a href="#gt_bittab_bit_is_set"><code>gt_bittab_bit_is_set</code></a><br>

  <a href="#gt_bittab_cmp"><code>gt_bittab_cmp</code></a><br>

  <a href="#gt_bittab_complement"><code>gt_bittab_complement</code></a><br>

  <a href="#gt_bittab_count_set_bits"><code>gt_bittab_count_set_bits</code></a><br>

  <a href="#gt_bittab_delete"><code>gt_bittab_delete</code></a><br>

  <a href="#gt_bittab_equal"><code>gt_bittab_equal</code></a><br>

  <a href="#gt_bittab_get_all_bitnums"><code>gt_bittab_get_all_bitnums</code></a><br>

  <a href="#gt_bittab_get_first_bitnum"><code>gt_bittab_get_first_bitnum</code></a><br>

  <a href="#gt_bittab_get_last_bitnum"><code>gt_bittab_get_last_bitnum</code></a><br>

  <a href="#gt_bittab_get_next_bitnum"><code>gt_bittab_get_next_bitnum</code></a><br>

  <a href="#gt_bittab_nand"><code>gt_bittab_nand</code></a><br>

  <a href="#gt_bittab_new"><code>gt_bittab_new</code></a><br>

  <a href="#gt_bittab_or"><code>gt_bittab_or</code></a><br>

  <a href="#gt_bittab_or_equal"><code>gt_bittab_or_equal</code></a><br>

  <a href="#gt_bittab_set_bit"><code>gt_bittab_set_bit</code></a><br>

  <a href="#gt_bittab_shift_left_equal"><code>gt_bittab_shift_left_equal</code></a><br>

  <a href="#gt_bittab_shift_right_equal"><code>gt_bittab_shift_right_equal</code></a><br>

  <a href="#gt_bittab_show"><code>gt_bittab_show</code></a><br>

  <a href="#gt_bittab_size"><code>gt_bittab_size</code></a><br>

  <a href="#gt_bittab_unset"><code>gt_bittab_unset</code></a><br>

  <a href="#gt_bittab_unset_bit"><code>gt_bittab_unset_bit</code></a><br>

  <a href="#gt_block_caption_is_visible"><code>gt_block_caption_is_visible</code></a><br>

  <a href="#gt_block_clone"><code>gt_block_clone</code></a><br>

  <a href="#gt_block_delete"><code>gt_block_delete</code></a><br>

  <a href="#gt_block_get_caption"><code>gt_block_get_caption</code></a><br>

  <a href="#gt_block_get_range"><code>gt_block_get_range</code></a><br>

  <a href="#gt_block_get_range_ptr"><code>gt_block_get_range_ptr</code></a><br>

  <a href="#gt_block_get_size"><code>gt_block_get_size</code></a><br>

  <a href="#gt_block_get_strand"><code>gt_block_get_strand</code></a><br>

  <a href="#gt_block_get_top_level_feature"><code>gt_block_get_top_level_feature</code></a><br>

  <a href="#gt_block_get_type"><code>gt_block_get_type</code></a><br>

  <a href="#gt_block_has_only_one_fullsize_element"><code>gt_block_has_only_one_fullsize_element</code></a><br>

  <a href="#gt_block_merge"><code>gt_block_merge</code></a><br>

  <a href="#gt_block_new"><code>gt_block_new</code></a><br>

  <a href="#gt_block_new_from_node"><code>gt_block_new_from_node</code></a><br>

  <a href="#gt_block_ref"><code>gt_block_ref</code></a><br>

  <a href="#gt_block_set_caption"><code>gt_block_set_caption</code></a><br>

  <a href="#gt_block_set_caption_visibility"><code>gt_block_set_caption_visibility</code></a><br>

  <a href="#gt_block_set_strand"><code>gt_block_set_strand</code></a><br>

  <a href="#gt_bsearch_all"><code>gt_bsearch_all</code></a><br>

  <a href="#gt_bsearch_all_mark"><code>gt_bsearch_all_mark</code></a><br>

  <a href="#gt_bsearch_data"><code>gt_bsearch_data</code></a><br>

  <a href="#gt_byte_popcount[256]"><code>gt_byte_popcount[256]</code></a><br>

  <a href="#gt_byte_select[2048]"><code>gt_byte_select[2048]</code></a><br>

  <a href="#gt_calloc"><code>gt_calloc</code></a><br>

  <a href="#gt_canvas_cairo_context_new"><code>gt_canvas_cairo_context_new</code></a><br>

  <a href="#gt_canvas_cairo_file_new"><code>gt_canvas_cairo_file_new</code></a><br>

  <a href="#gt_canvas_cairo_file_to_file"><code>gt_canvas_cairo_file_to_file</code></a><br>

  <a href="#gt_canvas_cairo_file_to_stream"><code>gt_canvas_cairo_file_to_stream</code></a><br>

  <a href="#gt_canvas_delete"><code>gt_canvas_delete</code></a><br>

  <a href="#gt_canvas_get_height"><code>gt_canvas_get_height</code></a><br>

  <a href="#gt_cds_stream_new"><code>gt_cds_stream_new</code></a><br>

  <a href="#gt_check_boundaries_visitor_new"><code>gt_check_boundaries_visitor_new</code></a><br>

  <a href="#gt_codon_iterator_current_position"><code>gt_codon_iterator_current_position</code></a><br>

  <a href="#gt_codon_iterator_delete"><code>gt_codon_iterator_delete</code></a><br>

  <a href="#gt_codon_iterator_encseq_new"><code>gt_codon_iterator_encseq_new</code></a><br>

  <a href="#gt_codon_iterator_encseq_new_with_readmode"><code>gt_codon_iterator_encseq_new_with_readmode</code></a><br>

  <a href="#gt_codon_iterator_length"><code>gt_codon_iterator_length</code></a><br>

  <a href="#gt_codon_iterator_next"><code>gt_codon_iterator_next</code></a><br>

  <a href="#gt_codon_iterator_rewind"><code>gt_codon_iterator_rewind</code></a><br>

  <a href="#gt_codon_iterator_simple_new"><code>gt_codon_iterator_simple_new</code></a><br>

  <a href="#gt_color_delete"><code>gt_color_delete</code></a><br>

  <a href="#gt_color_equals"><code>gt_color_equals</code></a><br>

  <a href="#gt_color_new"><code>gt_color_new</code></a><br>

  <a href="#gt_color_set"><code>gt_color_set</code></a><br>

  <a href="#gt_comment_node_cast"><code>gt_comment_node_cast</code></a><br>

  <a href="#gt_comment_node_get_comment"><code>gt_comment_node_get_comment</code></a><br>

  <a href="#gt_comment_node_new"><code>gt_comment_node_new</code></a><br>

  <a href="#gt_comment_node_try_cast"><code>gt_comment_node_try_cast</code></a><br>

  <a href="#gt_countingsort"><code>gt_countingsort</code></a><br>

  <a href="#gt_countingsort_get_max"><code>gt_countingsort_get_max</code></a><br>

  <a href="#gt_csa_stream_new"><code>gt_csa_stream_new</code></a><br>

  <a href="#gt_cstr_dup"><code>gt_cstr_dup</code></a><br>

  <a href="#gt_cstr_dup_nt"><code>gt_cstr_dup_nt</code></a><br>

  <a href="#gt_cstr_length_up_to_char"><code>gt_cstr_length_up_to_char</code></a><br>

  <a href="#gt_cstr_rep"><code>gt_cstr_rep</code></a><br>

  <a href="#gt_cstr_rtrim"><code>gt_cstr_rtrim</code></a><br>

  <a href="#gt_cstr_show"><code>gt_cstr_show</code></a><br>

  <a href="#gt_cstr_split"><code>gt_cstr_split</code></a><br>

  <a href="#gt_cstr_table_add"><code>gt_cstr_table_add</code></a><br>

  <a href="#gt_cstr_table_delete"><code>gt_cstr_table_delete</code></a><br>

  <a href="#gt_cstr_table_get"><code>gt_cstr_table_get</code></a><br>

  <a href="#gt_cstr_table_get_all"><code>gt_cstr_table_get_all</code></a><br>

  <a href="#gt_cstr_table_new"><code>gt_cstr_table_new</code></a><br>

  <a href="#gt_cstr_table_remove"><code>gt_cstr_table_remove</code></a><br>

  <a href="#gt_cstr_table_reset"><code>gt_cstr_table_reset</code></a><br>

  <a href="#gt_custom_track_delete"><code>gt_custom_track_delete</code></a><br>

  <a href="#gt_custom_track_gc_content_new"><code>gt_custom_track_gc_content_new</code></a><br>

  <a href="#gt_custom_track_ref"><code>gt_custom_track_ref</code></a><br>

  <a href="#gt_custom_track_script_wrapper_new"><code>gt_custom_track_script_wrapper_new</code></a><br>

  <a href="#gt_diagram_add_custom_track"><code>gt_diagram_add_custom_track</code></a><br>

  <a href="#gt_diagram_delete"><code>gt_diagram_delete</code></a><br>

  <a href="#gt_diagram_get_range"><code>gt_diagram_get_range</code></a><br>

  <a href="#gt_diagram_new"><code>gt_diagram_new</code></a><br>

  <a href="#gt_diagram_new_from_array"><code>gt_diagram_new_from_array</code></a><br>

  <a href="#gt_diagram_reset_track_selector_func"><code>gt_diagram_reset_track_selector_func</code></a><br>

  <a href="#gt_diagram_set_track_selector_func"><code>gt_diagram_set_track_selector_func</code></a><br>

  <a href="#gt_disc_distri_add"><code>gt_disc_distri_add</code></a><br>

  <a href="#gt_disc_distri_add_multi"><code>gt_disc_distri_add_multi</code></a><br>

  <a href="#gt_disc_distri_foreach"><code>gt_disc_distri_foreach</code></a><br>

  <a href="#gt_disc_distri_foreach_in_reverse_order"><code>gt_disc_distri_foreach_in_reverse_order</code></a><br>

  <a href="#gt_disc_distri_get"><code>gt_disc_distri_get</code></a><br>

  <a href="#gt_disc_distri_new"><code>gt_disc_distri_new</code></a><br>

  <a href="#gt_disc_distri_show"><code>gt_disc_distri_show</code></a><br>

  <a href="#gt_dlist_add"><code>gt_dlist_add</code></a><br>

  <a href="#gt_dlist_delete"><code>gt_dlist_delete</code></a><br>

  <a href="#gt_dlist_example"><code>gt_dlist_example</code></a><br>

  <a href="#gt_dlist_find"><code>gt_dlist_find</code></a><br>

  <a href="#gt_dlist_first"><code>gt_dlist_first</code></a><br>

  <a href="#gt_dlist_last"><code>gt_dlist_last</code></a><br>

  <a href="#gt_dlist_new"><code>gt_dlist_new</code></a><br>

  <a href="#gt_dlist_new_with_data"><code>gt_dlist_new_with_data</code></a><br>

  <a href="#gt_dlist_remove"><code>gt_dlist_remove</code></a><br>

  <a href="#gt_dlist_size"><code>gt_dlist_size</code></a><br>

  <a href="#gt_dlistelem_get_data"><code>gt_dlistelem_get_data</code></a><br>

  <a href="#gt_dlistelem_next"><code>gt_dlistelem_next</code></a><br>

  <a href="#gt_dlistelem_previous"><code>gt_dlistelem_previous</code></a><br>

  <a href="#gt_dup_feature_stream_new"><code>gt_dup_feature_stream_new</code></a><br>

  <a href="#gt_encseq_alphabet"><code>gt_encseq_alphabet</code></a><br>

  <a href="#gt_encseq_builder_add_cstr"><code>gt_encseq_builder_add_cstr</code></a><br>

  <a href="#gt_encseq_builder_add_encoded"><code>gt_encseq_builder_add_encoded</code></a><br>

  <a href="#gt_encseq_builder_add_encoded_own"><code>gt_encseq_builder_add_encoded_own</code></a><br>

  <a href="#gt_encseq_builder_add_multiple_encoded"><code>gt_encseq_builder_add_multiple_encoded</code></a><br>

  <a href="#gt_encseq_builder_add_str"><code>gt_encseq_builder_add_str</code></a><br>

  <a href="#gt_encseq_builder_build"><code>gt_encseq_builder_build</code></a><br>

  <a href="#gt_encseq_builder_create_des_tab"><code>gt_encseq_builder_create_des_tab</code></a><br>

  <a href="#gt_encseq_builder_create_esq_tab"><code>gt_encseq_builder_create_esq_tab</code></a><br>

  <a href="#gt_encseq_builder_create_sds_tab"><code>gt_encseq_builder_create_sds_tab</code></a><br>

  <a href="#gt_encseq_builder_create_ssp_tab"><code>gt_encseq_builder_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_builder_delete"><code>gt_encseq_builder_delete</code></a><br>

  <a href="#gt_encseq_builder_disable_description_support"><code>gt_encseq_builder_disable_description_support</code></a><br>

  <a href="#gt_encseq_builder_disable_multiseq_support"><code>gt_encseq_builder_disable_multiseq_support</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_des_tab"><code>gt_encseq_builder_do_not_create_des_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_esq_tab"><code>gt_encseq_builder_do_not_create_esq_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_sds_tab"><code>gt_encseq_builder_do_not_create_sds_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_ssp_tab"><code>gt_encseq_builder_do_not_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_builder_enable_description_support"><code>gt_encseq_builder_enable_description_support</code></a><br>

  <a href="#gt_encseq_builder_enable_multiseq_support"><code>gt_encseq_builder_enable_multiseq_support</code></a><br>

  <a href="#gt_encseq_builder_new"><code>gt_encseq_builder_new</code></a><br>

  <a href="#gt_encseq_builder_reset"><code>gt_encseq_builder_reset</code></a><br>

  <a href="#gt_encseq_builder_set_logger"><code>gt_encseq_builder_set_logger</code></a><br>

  <a href="#gt_encseq_create_reader_with_readmode"><code>gt_encseq_create_reader_with_readmode</code></a><br>

  <a href="#gt_encseq_delete"><code>gt_encseq_delete</code></a><br>

  <a href="#gt_encseq_description"><code>gt_encseq_description</code></a><br>

  <a href="#gt_encseq_effective_filelength"><code>gt_encseq_effective_filelength</code></a><br>

  <a href="#gt_encseq_encoder_are_descs_clipped"><code>gt_encseq_encoder_are_descs_clipped</code></a><br>

  <a href="#gt_encseq_encoder_clip_desc"><code>gt_encseq_encoder_clip_desc</code></a><br>

  <a href="#gt_encseq_encoder_create_des_tab"><code>gt_encseq_encoder_create_des_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_md5_tab"><code>gt_encseq_encoder_create_md5_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_sds_tab"><code>gt_encseq_encoder_create_sds_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_ssp_tab"><code>gt_encseq_encoder_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_encoder_delete"><code>gt_encseq_encoder_delete</code></a><br>

  <a href="#gt_encseq_encoder_des_tab_requested"><code>gt_encseq_encoder_des_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_disable_description_support"><code>gt_encseq_encoder_disable_description_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_lossless_support"><code>gt_encseq_encoder_disable_lossless_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_md5_support"><code>gt_encseq_encoder_disable_md5_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_multiseq_support"><code>gt_encseq_encoder_disable_multiseq_support</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_des_tab"><code>gt_encseq_encoder_do_not_create_des_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_md5_tab"><code>gt_encseq_encoder_do_not_create_md5_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_sds_tab"><code>gt_encseq_encoder_do_not_create_sds_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_ssp_tab"><code>gt_encseq_encoder_do_not_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_encoder_enable_description_support"><code>gt_encseq_encoder_enable_description_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_lossless_support"><code>gt_encseq_encoder_enable_lossless_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_md5_support"><code>gt_encseq_encoder_enable_md5_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_multiseq_support"><code>gt_encseq_encoder_enable_multiseq_support</code></a><br>

  <a href="#gt_encseq_encoder_encode"><code>gt_encseq_encoder_encode</code></a><br>

  <a href="#gt_encseq_encoder_get_timer"><code>gt_encseq_encoder_get_timer</code></a><br>

  <a href="#gt_encseq_encoder_is_input_dna"><code>gt_encseq_encoder_is_input_dna</code></a><br>

  <a href="#gt_encseq_encoder_is_input_protein"><code>gt_encseq_encoder_is_input_protein</code></a><br>

  <a href="#gt_encseq_encoder_md5_tab_requested"><code>gt_encseq_encoder_md5_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_new"><code>gt_encseq_encoder_new</code></a><br>

  <a href="#gt_encseq_encoder_representation"><code>gt_encseq_encoder_representation</code></a><br>

  <a href="#gt_encseq_encoder_sds_tab_requested"><code>gt_encseq_encoder_sds_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_set_input_dna"><code>gt_encseq_encoder_set_input_dna</code></a><br>

  <a href="#gt_encseq_encoder_set_input_protein"><code>gt_encseq_encoder_set_input_protein</code></a><br>

  <a href="#gt_encseq_encoder_set_logger"><code>gt_encseq_encoder_set_logger</code></a><br>

  <a href="#gt_encseq_encoder_set_timer"><code>gt_encseq_encoder_set_timer</code></a><br>

  <a href="#gt_encseq_encoder_ssp_tab_requested"><code>gt_encseq_encoder_ssp_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_symbolmap_file"><code>gt_encseq_encoder_symbolmap_file</code></a><br>

  <a href="#gt_encseq_encoder_use_representation"><code>gt_encseq_encoder_use_representation</code></a><br>

  <a href="#gt_encseq_encoder_use_symbolmap_file"><code>gt_encseq_encoder_use_symbolmap_file</code></a><br>

  <a href="#gt_encseq_extract_decoded"><code>gt_encseq_extract_decoded</code></a><br>

  <a href="#gt_encseq_extract_encoded"><code>gt_encseq_extract_encoded</code></a><br>

  <a href="#gt_encseq_filenames"><code>gt_encseq_filenames</code></a><br>

  <a href="#gt_encseq_filenum"><code>gt_encseq_filenum</code></a><br>

  <a href="#gt_encseq_filenum_first_seqnum"><code>gt_encseq_filenum_first_seqnum</code></a><br>

  <a href="#gt_encseq_filestartpos"><code>gt_encseq_filestartpos</code></a><br>

  <a href="#gt_encseq_get_decoded_char"><code>gt_encseq_get_decoded_char</code></a><br>

  <a href="#gt_encseq_get_encoded_char"><code>gt_encseq_get_encoded_char</code></a><br>

  <a href="#gt_encseq_has_description_support"><code>gt_encseq_has_description_support</code></a><br>

  <a href="#gt_encseq_has_md5_support"><code>gt_encseq_has_md5_support</code></a><br>

  <a href="#gt_encseq_has_multiseq_support"><code>gt_encseq_has_multiseq_support</code></a><br>

  <a href="#gt_encseq_indexname"><code>gt_encseq_indexname</code></a><br>

  <a href="#gt_encseq_is_64_bit"><code>gt_encseq_is_64_bit</code></a><br>

  <a href="#gt_encseq_is_mirrored"><code>gt_encseq_is_mirrored</code></a><br>

  <a href="#gt_encseq_loader_delete"><code>gt_encseq_loader_delete</code></a><br>

  <a href="#gt_encseq_loader_des_tab_required"><code>gt_encseq_loader_des_tab_required</code></a><br>

  <a href="#gt_encseq_loader_disable_autosupport"><code>gt_encseq_loader_disable_autosupport</code></a><br>

  <a href="#gt_encseq_loader_do_not_mirror"><code>gt_encseq_loader_do_not_mirror</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_des_tab"><code>gt_encseq_loader_do_not_require_des_tab</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_sds_tab"><code>gt_encseq_loader_do_not_require_sds_tab</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_ssp_tab"><code>gt_encseq_loader_do_not_require_ssp_tab</code></a><br>

  <a href="#gt_encseq_loader_drop_description_support"><code>gt_encseq_loader_drop_description_support</code></a><br>

  <a href="#gt_encseq_loader_drop_lossless_support"><code>gt_encseq_loader_drop_lossless_support</code></a><br>

  <a href="#gt_encseq_loader_drop_md5_support"><code>gt_encseq_loader_drop_md5_support</code></a><br>

  <a href="#gt_encseq_loader_drop_multiseq_support"><code>gt_encseq_loader_drop_multiseq_support</code></a><br>

  <a href="#gt_encseq_loader_enable_autosupport"><code>gt_encseq_loader_enable_autosupport</code></a><br>

  <a href="#gt_encseq_loader_load"><code>gt_encseq_loader_load</code></a><br>

  <a href="#gt_encseq_loader_mirror"><code>gt_encseq_loader_mirror</code></a><br>

  <a href="#gt_encseq_loader_new"><code>gt_encseq_loader_new</code></a><br>

  <a href="#gt_encseq_loader_require_des_tab"><code>gt_encseq_loader_require_des_tab</code></a><br>

  <a href="#gt_encseq_loader_require_description_support"><code>gt_encseq_loader_require_description_support</code></a><br>

  <a href="#gt_encseq_loader_require_lossless_support"><code>gt_encseq_loader_require_lossless_support</code></a><br>

  <a href="#gt_encseq_loader_require_md5_support"><code>gt_encseq_loader_require_md5_support</code></a><br>

  <a href="#gt_encseq_loader_require_multiseq_support"><code>gt_encseq_loader_require_multiseq_support</code></a><br>

  <a href="#gt_encseq_loader_require_sds_tab"><code>gt_encseq_loader_require_sds_tab</code></a><br>

  <a href="#gt_encseq_loader_require_ssp_tab"><code>gt_encseq_loader_require_ssp_tab</code></a><br>

  <a href="#gt_encseq_loader_sds_tab_required"><code>gt_encseq_loader_sds_tab_required</code></a><br>

  <a href="#gt_encseq_loader_set_logger"><code>gt_encseq_loader_set_logger</code></a><br>

  <a href="#gt_encseq_loader_ssp_tab_required"><code>gt_encseq_loader_ssp_tab_required</code></a><br>

  <a href="#gt_encseq_max_seq_length"><code>gt_encseq_max_seq_length</code></a><br>

  <a href="#gt_encseq_min_seq_length"><code>gt_encseq_min_seq_length</code></a><br>

  <a href="#gt_encseq_mirror"><code>gt_encseq_mirror</code></a><br>

  <a href="#gt_encseq_num_of_files"><code>gt_encseq_num_of_files</code></a><br>

  <a href="#gt_encseq_num_of_sequences"><code>gt_encseq_num_of_sequences</code></a><br>

  <a href="#gt_encseq_position_is_separator"><code>gt_encseq_position_is_separator</code></a><br>

  <a href="#gt_encseq_reader_delete"><code>gt_encseq_reader_delete</code></a><br>

  <a href="#gt_encseq_reader_next_decoded_char"><code>gt_encseq_reader_next_decoded_char</code></a><br>

  <a href="#gt_encseq_reader_next_encoded_char"><code>gt_encseq_reader_next_encoded_char</code></a><br>

  <a href="#gt_encseq_reader_reinit_with_readmode"><code>gt_encseq_reader_reinit_with_readmode</code></a><br>

  <a href="#gt_encseq_ref"><code>gt_encseq_ref</code></a><br>

  <a href="#gt_encseq_seqlength"><code>gt_encseq_seqlength</code></a><br>

  <a href="#gt_encseq_seqnum"><code>gt_encseq_seqnum</code></a><br>

  <a href="#gt_encseq_seqstartpos"><code>gt_encseq_seqstartpos</code></a><br>

  <a href="#gt_encseq_total_length"><code>gt_encseq_total_length</code></a><br>

  <a href="#gt_encseq_unmirror"><code>gt_encseq_unmirror</code></a><br>

  <a href="#gt_encseq_version"><code>gt_encseq_version</code></a><br>

  <a href="#gt_eof_node_new"><code>gt_eof_node_new</code></a><br>

  <a href="#gt_eof_node_try_cast"><code>gt_eof_node_try_cast</code></a><br>

  <a href="#gt_error_check"><code>gt_error_check</code></a><br>

  <a href="#gt_error_delete"><code>gt_error_delete</code></a><br>

  <a href="#gt_error_get"><code>gt_error_get</code></a><br>

  <a href="#gt_error_is_set"><code>gt_error_is_set</code></a><br>

  <a href="#gt_error_new"><code>gt_error_new</code></a><br>

  <a href="#gt_error_set"><code>gt_error_set</code></a><br>

  <a href="#gt_error_set_nonvariadic"><code>gt_error_set_nonvariadic</code></a><br>

  <a href="#gt_error_unset"><code>gt_error_unset</code></a><br>

  <a href="#gt_error_vset"><code>gt_error_vset</code></a><br>

  <a href="#gt_extract_feature_stream_new"><code>gt_extract_feature_stream_new</code></a><br>

  <a href="#gt_fasta_show_entry"><code>gt_fasta_show_entry</code></a><br>

  <a href="#gt_feature_in_stream_new"><code>gt_feature_in_stream_new</code></a><br>

  <a href="#gt_feature_in_stream_use_orig_ranges"><code>gt_feature_in_stream_use_orig_ranges</code></a><br>

  <a href="#gt_feature_index_add_feature_node"><code>gt_feature_index_add_feature_node</code></a><br>

  <a href="#gt_feature_index_add_gff3file"><code>gt_feature_index_add_gff3file</code></a><br>

  <a href="#gt_feature_index_add_region_node"><code>gt_feature_index_add_region_node</code></a><br>

  <a href="#gt_feature_index_delete"><code>gt_feature_index_delete</code></a><br>

  <a href="#gt_feature_index_get_features_for_range"><code>gt_feature_index_get_features_for_range</code></a><br>

  <a href="#gt_feature_index_get_features_for_seqid"><code>gt_feature_index_get_features_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_first_seqid"><code>gt_feature_index_get_first_seqid</code></a><br>

  <a href="#gt_feature_index_get_orig_range_for_seqid"><code>gt_feature_index_get_orig_range_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_range_for_seqid"><code>gt_feature_index_get_range_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_seqids"><code>gt_feature_index_get_seqids</code></a><br>

  <a href="#gt_feature_index_gfflike_get_all_features"><code>gt_feature_index_gfflike_get_all_features</code></a><br>

  <a href="#gt_feature_index_has_seqid"><code>gt_feature_index_has_seqid</code></a><br>

  <a href="#gt_feature_index_memory_get_node_by_ptr"><code>gt_feature_index_memory_get_node_by_ptr</code></a><br>

  <a href="#gt_feature_index_memory_new"><code>gt_feature_index_memory_new</code></a><br>

  <a href="#gt_feature_index_remove_node"><code>gt_feature_index_remove_node</code></a><br>

  <a href="#gt_feature_index_save"><code>gt_feature_index_save</code></a><br>

  <a href="#gt_feature_node_add_attribute"><code>gt_feature_node_add_attribute</code></a><br>

  <a href="#gt_feature_node_add_child"><code>gt_feature_node_add_child</code></a><br>

  <a href="#gt_feature_node_cast"><code>gt_feature_node_cast</code></a><br>

  <a href="#gt_feature_node_contains_marked"><code>gt_feature_node_contains_marked</code></a><br>

  <a href="#gt_feature_node_foreach_attribute"><code>gt_feature_node_foreach_attribute</code></a><br>

  <a href="#gt_feature_node_get_attribute"><code>gt_feature_node_get_attribute</code></a><br>

  <a href="#gt_feature_node_get_attribute_list"><code>gt_feature_node_get_attribute_list</code></a><br>

  <a href="#gt_feature_node_get_multi_representative"><code>gt_feature_node_get_multi_representative</code></a><br>

  <a href="#gt_feature_node_get_phase"><code>gt_feature_node_get_phase</code></a><br>

  <a href="#gt_feature_node_get_score"><code>gt_feature_node_get_score</code></a><br>

  <a href="#gt_feature_node_get_source"><code>gt_feature_node_get_source</code></a><br>

  <a href="#gt_feature_node_get_strand"><code>gt_feature_node_get_strand</code></a><br>

  <a href="#gt_feature_node_get_type"><code>gt_feature_node_get_type</code></a><br>

  <a href="#gt_feature_node_has_source"><code>gt_feature_node_has_source</code></a><br>

  <a href="#gt_feature_node_has_type"><code>gt_feature_node_has_type</code></a><br>

  <a href="#gt_feature_node_is_marked"><code>gt_feature_node_is_marked</code></a><br>

  <a href="#gt_feature_node_is_multi"><code>gt_feature_node_is_multi</code></a><br>

  <a href="#gt_feature_node_is_pseudo"><code>gt_feature_node_is_pseudo</code></a><br>

  <a href="#gt_feature_node_is_similar"><code>gt_feature_node_is_similar</code></a><br>

  <a href="#gt_feature_node_iterator_delete"><code>gt_feature_node_iterator_delete</code></a><br>

  <a href="#gt_feature_node_iterator_new"><code>gt_feature_node_iterator_new</code></a><br>

  <a href="#gt_feature_node_iterator_new_direct"><code>gt_feature_node_iterator_new_direct</code></a><br>

  <a href="#gt_feature_node_iterator_next"><code>gt_feature_node_iterator_next</code></a><br>

  <a href="#gt_feature_node_make_multi_representative"><code>gt_feature_node_make_multi_representative</code></a><br>

  <a href="#gt_feature_node_mark"><code>gt_feature_node_mark</code></a><br>

  <a href="#gt_feature_node_new"><code>gt_feature_node_new</code></a><br>

  <a href="#gt_feature_node_new_pseudo"><code>gt_feature_node_new_pseudo</code></a><br>

  <a href="#gt_feature_node_new_pseudo_template"><code>gt_feature_node_new_pseudo_template</code></a><br>

  <a href="#gt_feature_node_new_standard_gene"><code>gt_feature_node_new_standard_gene</code></a><br>

  <a href="#gt_feature_node_number_of_children"><code>gt_feature_node_number_of_children</code></a><br>

  <a href="#gt_feature_node_number_of_children_of_type"><code>gt_feature_node_number_of_children_of_type</code></a><br>

  <a href="#gt_feature_node_remove_attribute"><code>gt_feature_node_remove_attribute</code></a><br>

  <a href="#gt_feature_node_remove_leaf"><code>gt_feature_node_remove_leaf</code></a><br>

  <a href="#gt_feature_node_score_is_defined"><code>gt_feature_node_score_is_defined</code></a><br>

  <a href="#gt_feature_node_set_attribute"><code>gt_feature_node_set_attribute</code></a><br>

  <a href="#gt_feature_node_set_multi_representative"><code>gt_feature_node_set_multi_representative</code></a><br>

  <a href="#gt_feature_node_set_phase"><code>gt_feature_node_set_phase</code></a><br>

  <a href="#gt_feature_node_set_score"><code>gt_feature_node_set_score</code></a><br>

  <a href="#gt_feature_node_set_source"><code>gt_feature_node_set_source</code></a><br>

  <a href="#gt_feature_node_set_strand"><code>gt_feature_node_set_strand</code></a><br>

  <a href="#gt_feature_node_set_type"><code>gt_feature_node_set_type</code></a><br>

  <a href="#gt_feature_node_try_cast"><code>gt_feature_node_try_cast</code></a><br>

  <a href="#gt_feature_node_unmark"><code>gt_feature_node_unmark</code></a><br>

  <a href="#gt_feature_node_unset_multi"><code>gt_feature_node_unset_multi</code></a><br>

  <a href="#gt_feature_node_unset_score"><code>gt_feature_node_unset_score</code></a><br>

  <a href="#gt_feature_out_stream_new"><code>gt_feature_out_stream_new</code></a><br>

  <a href="#gt_feature_stream_new"><code>gt_feature_stream_new</code></a><br>

  <a href="#gt_file_delete"><code>gt_file_delete</code></a><br>

  <a href="#gt_file_delete_without_handle"><code>gt_file_delete_without_handle</code></a><br>

  <a href="#gt_file_dirname"><code>gt_file_dirname</code></a><br>

  <a href="#gt_file_estimate_size"><code>gt_file_estimate_size</code></a><br>

  <a href="#gt_file_exists"><code>gt_file_exists</code></a><br>

  <a href="#gt_file_exists_with_suffix"><code>gt_file_exists_with_suffix</code></a><br>

  <a href="#gt_file_find_exec_in_path"><code>gt_file_find_exec_in_path</code></a><br>

  <a href="#gt_file_find_in_env"><code>gt_file_find_in_env</code></a><br>

  <a href="#gt_file_find_in_path"><code>gt_file_find_in_path</code></a><br>

  <a href="#gt_file_is_newer"><code>gt_file_is_newer</code></a><br>

  <a href="#gt_file_new"><code>gt_file_new</code></a><br>

  <a href="#gt_file_new_from_fileptr"><code>gt_file_new_from_fileptr</code></a><br>

  <a href="#gt_file_number_of_lines"><code>gt_file_number_of_lines</code></a><br>

  <a href="#gt_file_size"><code>gt_file_size</code></a><br>

  <a href="#gt_file_size_with_suffix"><code>gt_file_size_with_suffix</code></a><br>

  <a href="#gt_file_suffix"><code>gt_file_suffix</code></a><br>

  <a href="#gt_file_xfgetc"><code>gt_file_xfgetc</code></a><br>

  <a href="#gt_file_xfputc"><code>gt_file_xfputc</code></a><br>

  <a href="#gt_file_xfputs"><code>gt_file_xfputs</code></a><br>

  <a href="#gt_file_xprintf"><code>gt_file_xprintf</code></a><br>

  <a href="#gt_file_xread"><code>gt_file_xread</code></a><br>

  <a href="#gt_file_xrewind"><code>gt_file_xrewind</code></a><br>

  <a href="#gt_file_xwrite"><code>gt_file_xwrite</code></a><br>

  <a href="#gt_files_estimate_total_size"><code>gt_files_estimate_total_size</code></a><br>

  <a href="#gt_files_guess_if_protein_sequences"><code>gt_files_guess_if_protein_sequences</code></a><br>

  <a href="#gt_free"><code>gt_free</code></a><br>

  <a href="#gt_free_func"><code>gt_free_func</code></a><br>

  <a href="#gt_genome_node_accept"><code>gt_genome_node_accept</code></a><br>

  <a href="#gt_genome_node_add_user_data"><code>gt_genome_node_add_user_data</code></a><br>

  <a href="#gt_genome_node_cmp"><code>gt_genome_node_cmp</code></a><br>

  <a href="#gt_genome_node_delete"><code>gt_genome_node_delete</code></a><br>

  <a href="#gt_genome_node_get_end"><code>gt_genome_node_get_end</code></a><br>

  <a href="#gt_genome_node_get_filename"><code>gt_genome_node_get_filename</code></a><br>

  <a href="#gt_genome_node_get_length"><code>gt_genome_node_get_length</code></a><br>

  <a href="#gt_genome_node_get_line_number"><code>gt_genome_node_get_line_number</code></a><br>

  <a href="#gt_genome_node_get_range"><code>gt_genome_node_get_range</code></a><br>

  <a href="#gt_genome_node_get_seqid"><code>gt_genome_node_get_seqid</code></a><br>

  <a href="#gt_genome_node_get_start"><code>gt_genome_node_get_start</code></a><br>

  <a href="#gt_genome_node_get_user_data"><code>gt_genome_node_get_user_data</code></a><br>

  <a href="#gt_genome_node_ref"><code>gt_genome_node_ref</code></a><br>

  <a href="#gt_genome_node_release_user_data"><code>gt_genome_node_release_user_data</code></a><br>

  <a href="#gt_genome_node_set_range"><code>gt_genome_node_set_range</code></a><br>

  <a href="#gt_genome_nodes_sort"><code>gt_genome_nodes_sort</code></a><br>

  <a href="#gt_genome_nodes_sort_stable"><code>gt_genome_nodes_sort_stable</code></a><br>

  <a href="#gt_gff3_in_stream_check_id_attributes"><code>gt_gff3_in_stream_check_id_attributes</code></a><br>

  <a href="#gt_gff3_in_stream_enable_strict_mode"><code>gt_gff3_in_stream_enable_strict_mode</code></a><br>

  <a href="#gt_gff3_in_stream_enable_tidy_mode"><code>gt_gff3_in_stream_enable_tidy_mode</code></a><br>

  <a href="#gt_gff3_in_stream_get_used_types"><code>gt_gff3_in_stream_get_used_types</code></a><br>

  <a href="#gt_gff3_in_stream_new_sorted"><code>gt_gff3_in_stream_new_sorted</code></a><br>

  <a href="#gt_gff3_in_stream_new_unsorted"><code>gt_gff3_in_stream_new_unsorted</code></a><br>

  <a href="#gt_gff3_in_stream_set_type_checker"><code>gt_gff3_in_stream_set_type_checker</code></a><br>

  <a href="#gt_gff3_in_stream_show_progress_bar"><code>gt_gff3_in_stream_show_progress_bar</code></a><br>

  <a href="#gt_gff3_out_stream_new"><code>gt_gff3_out_stream_new</code></a><br>

  <a href="#gt_gff3_out_stream_retain_id_attributes"><code>gt_gff3_out_stream_retain_id_attributes</code></a><br>

  <a href="#gt_gff3_out_stream_set_fasta_width"><code>gt_gff3_out_stream_set_fasta_width</code></a><br>

  <a href="#gt_gff3_parser_check_id_attributes"><code>gt_gff3_parser_check_id_attributes</code></a><br>

  <a href="#gt_gff3_parser_check_region_boundaries"><code>gt_gff3_parser_check_region_boundaries</code></a><br>

  <a href="#gt_gff3_parser_delete"><code>gt_gff3_parser_delete</code></a><br>

  <a href="#gt_gff3_parser_do_not_check_region_boundaries"><code>gt_gff3_parser_do_not_check_region_boundaries</code></a><br>

  <a href="#gt_gff3_parser_enable_tidy_mode"><code>gt_gff3_parser_enable_tidy_mode</code></a><br>

  <a href="#gt_gff3_parser_new"><code>gt_gff3_parser_new</code></a><br>

  <a href="#gt_gff3_parser_parse_genome_nodes"><code>gt_gff3_parser_parse_genome_nodes</code></a><br>

  <a href="#gt_gff3_parser_reset"><code>gt_gff3_parser_reset</code></a><br>

  <a href="#gt_gff3_parser_set_offset"><code>gt_gff3_parser_set_offset</code></a><br>

  <a href="#gt_gff3_parser_set_type_checker"><code>gt_gff3_parser_set_type_checker</code></a><br>

  <a href="#gt_gff3_parser_set_xrf_checker"><code>gt_gff3_parser_set_xrf_checker</code></a><br>

  <a href="#gt_gff3_visitor_new"><code>gt_gff3_visitor_new</code></a><br>

  <a href="#gt_gff3_visitor_retain_id_attributes"><code>gt_gff3_visitor_retain_id_attributes</code></a><br>

  <a href="#gt_gff3_visitor_set_fasta_width"><code>gt_gff3_visitor_set_fasta_width</code></a><br>

  <a href="#gt_graphics_cairo_draw_curve_data"><code>gt_graphics_cairo_draw_curve_data</code></a><br>

  <a href="#gt_graphics_cairo_new"><code>gt_graphics_cairo_new</code></a><br>

  <a href="#gt_graphics_cairo_new_from_context"><code>gt_graphics_cairo_new_from_context</code></a><br>

  <a href="#gt_graphics_delete"><code>gt_graphics_delete</code></a><br>

  <a href="#gt_graphics_draw_arrowhead"><code>gt_graphics_draw_arrowhead</code></a><br>

  <a href="#gt_graphics_draw_box"><code>gt_graphics_draw_box</code></a><br>

  <a href="#gt_graphics_draw_caret"><code>gt_graphics_draw_caret</code></a><br>

  <a href="#gt_graphics_draw_colored_text"><code>gt_graphics_draw_colored_text</code></a><br>

  <a href="#gt_graphics_draw_curve_data"><code>gt_graphics_draw_curve_data</code></a><br>

  <a href="#gt_graphics_draw_dashes"><code>gt_graphics_draw_dashes</code></a><br>

  <a href="#gt_graphics_draw_horizontal_line"><code>gt_graphics_draw_horizontal_line</code></a><br>

  <a href="#gt_graphics_draw_line"><code>gt_graphics_draw_line</code></a><br>

  <a href="#gt_graphics_draw_rectangle"><code>gt_graphics_draw_rectangle</code></a><br>

  <a href="#gt_graphics_draw_text"><code>gt_graphics_draw_text</code></a><br>

  <a href="#gt_graphics_draw_text_centered"><code>gt_graphics_draw_text_centered</code></a><br>

  <a href="#gt_graphics_draw_text_clip"><code>gt_graphics_draw_text_clip</code></a><br>

  <a href="#gt_graphics_draw_text_left"><code>gt_graphics_draw_text_left</code></a><br>

  <a href="#gt_graphics_draw_text_right"><code>gt_graphics_draw_text_right</code></a><br>

  <a href="#gt_graphics_draw_vertical_line"><code>gt_graphics_draw_vertical_line</code></a><br>

  <a href="#gt_graphics_get_image_height"><code>gt_graphics_get_image_height</code></a><br>

  <a href="#gt_graphics_get_image_width"><code>gt_graphics_get_image_width</code></a><br>

  <a href="#gt_graphics_get_text_height"><code>gt_graphics_get_text_height</code></a><br>

  <a href="#gt_graphics_get_text_width"><code>gt_graphics_get_text_width</code></a><br>

  <a href="#gt_graphics_get_xmargins"><code>gt_graphics_get_xmargins</code></a><br>

  <a href="#gt_graphics_get_ymargins"><code>gt_graphics_get_ymargins</code></a><br>

  <a href="#gt_graphics_save_to_file"><code>gt_graphics_save_to_file</code></a><br>

  <a href="#gt_graphics_save_to_stream"><code>gt_graphics_save_to_stream</code></a><br>

  <a href="#gt_graphics_set_background_color"><code>gt_graphics_set_background_color</code></a><br>

  <a href="#gt_graphics_set_font"><code>gt_graphics_set_font</code></a><br>

  <a href="#gt_graphics_set_margins"><code>gt_graphics_set_margins</code></a><br>

  <a href="#gt_grep"><code>gt_grep</code></a><br>

  <a href="#gt_grep_nt"><code>gt_grep_nt</code></a><br>

  <a href="#gt_gtf_in_stream_new"><code>gt_gtf_in_stream_new</code></a><br>

  <a href="#gt_gtf_out_stream_new"><code>gt_gtf_out_stream_new</code></a><br>

  <a href="#gt_hashmap_add"><code>gt_hashmap_add</code></a><br>

  <a href="#gt_hashmap_delete"><code>gt_hashmap_delete</code></a><br>

  <a href="#gt_hashmap_foreach"><code>gt_hashmap_foreach</code></a><br>

  <a href="#gt_hashmap_foreach_in_key_order"><code>gt_hashmap_foreach_in_key_order</code></a><br>

  <a href="#gt_hashmap_foreach_ordered"><code>gt_hashmap_foreach_ordered</code></a><br>

  <a href="#gt_hashmap_get"><code>gt_hashmap_get</code></a><br>

  <a href="#gt_hashmap_new"><code>gt_hashmap_new</code></a><br>

  <a href="#gt_hashmap_ref"><code>gt_hashmap_ref</code></a><br>

  <a href="#gt_hashmap_remove"><code>gt_hashmap_remove</code></a><br>

  <a href="#gt_hashmap_reset"><code>gt_hashmap_reset</code></a><br>

  <a href="#gt_id_to_md5_stream_new"><code>gt_id_to_md5_stream_new</code></a><br>

  <a href="#gt_image_info_delete"><code>gt_image_info_delete</code></a><br>

  <a href="#gt_image_info_get_height"><code>gt_image_info_get_height</code></a><br>

  <a href="#gt_image_info_get_rec_map"><code>gt_image_info_get_rec_map</code></a><br>

  <a href="#gt_image_info_new"><code>gt_image_info_new</code></a><br>

  <a href="#gt_image_info_num_of_rec_maps"><code>gt_image_info_num_of_rec_maps</code></a><br>

  <a href="#gt_inter_feature_stream_new"><code>gt_inter_feature_stream_new</code></a><br>

  <a href="#gt_interval_tree_delete"><code>gt_interval_tree_delete</code></a><br>

  <a href="#gt_interval_tree_find_all_overlapping"><code>gt_interval_tree_find_all_overlapping</code></a><br>

  <a href="#gt_interval_tree_find_first_overlapping"><code>gt_interval_tree_find_first_overlapping</code></a><br>

  <a href="#gt_interval_tree_insert"><code>gt_interval_tree_insert</code></a><br>

  <a href="#gt_interval_tree_iterate_overlapping"><code>gt_interval_tree_iterate_overlapping</code></a><br>

  <a href="#gt_interval_tree_new"><code>gt_interval_tree_new</code></a><br>

  <a href="#gt_interval_tree_node_get_data"><code>gt_interval_tree_node_get_data</code></a><br>

  <a href="#gt_interval_tree_node_new"><code>gt_interval_tree_node_new</code></a><br>

  <a href="#gt_interval_tree_remove"><code>gt_interval_tree_remove</code></a><br>

  <a href="#gt_interval_tree_size"><code>gt_interval_tree_size</code></a><br>

  <a href="#gt_interval_tree_traverse"><code>gt_interval_tree_traverse</code></a><br>

  <a href="#gt_is_little_endian"><code>gt_is_little_endian</code></a><br>

  <a href="#gt_jobs"><code>gt_jobs</code></a><br>

  <a href="#gt_layout_delete"><code>gt_layout_delete</code></a><br>

  <a href="#gt_layout_get_height"><code>gt_layout_get_height</code></a><br>

  <a href="#gt_layout_new"><code>gt_layout_new</code></a><br>

  <a href="#gt_layout_new_with_twc"><code>gt_layout_new_with_twc</code></a><br>

  <a href="#gt_layout_set_track_ordering_func"><code>gt_layout_set_track_ordering_func</code></a><br>

  <a href="#gt_layout_sketch"><code>gt_layout_sketch</code></a><br>

  <a href="#gt_lib_clean"><code>gt_lib_clean</code></a><br>

  <a href="#gt_lib_init"><code>gt_lib_init</code></a><br>

  <a href="#gt_lib_reg_atexit_func"><code>gt_lib_reg_atexit_func</code></a><br>

  <a href="#gt_log_enable"><code>gt_log_enable</code></a><br>

  <a href="#gt_log_enabled"><code>gt_log_enabled</code></a><br>

  <a href="#gt_log_fp"><code>gt_log_fp</code></a><br>

  <a href="#gt_log_log"><code>gt_log_log</code></a><br>

  <a href="#gt_log_set_fp"><code>gt_log_set_fp</code></a><br>

  <a href="#gt_log_vlog"><code>gt_log_vlog</code></a><br>

  <a href="#gt_logger_delete"><code>gt_logger_delete</code></a><br>

  <a href="#gt_logger_disable"><code>gt_logger_disable</code></a><br>

  <a href="#gt_logger_enable"><code>gt_logger_enable</code></a><br>

  <a href="#gt_logger_enabled"><code>gt_logger_enabled</code></a><br>

  <a href="#gt_logger_log"><code>gt_logger_log</code></a><br>

  <a href="#gt_logger_log_force"><code>gt_logger_log_force</code></a><br>

  <a href="#gt_logger_log_va"><code>gt_logger_log_va</code></a><br>

  <a href="#gt_logger_log_va_force"><code>gt_logger_log_va_force</code></a><br>

  <a href="#gt_logger_new"><code>gt_logger_new</code></a><br>

  <a href="#gt_logger_set_target"><code>gt_logger_set_target</code></a><br>

  <a href="#gt_logger_target"><code>gt_logger_target</code></a><br>

  <a href="#gt_malloc"><code>gt_malloc</code></a><br>

  <a href="#gt_match_blast_get_align_length"><code>gt_match_blast_get_align_length</code></a><br>

  <a href="#gt_match_blast_get_bitscore"><code>gt_match_blast_get_bitscore</code></a><br>

  <a href="#gt_match_blast_get_evalue"><code>gt_match_blast_get_evalue</code></a><br>

  <a href="#gt_match_blast_get_similarity"><code>gt_match_blast_get_similarity</code></a><br>

  <a href="#gt_match_blast_new"><code>gt_match_blast_new</code></a><br>

  <a href="#gt_match_blast_set_align_length"><code>gt_match_blast_set_align_length</code></a><br>

  <a href="#gt_match_blast_set_bitscore"><code>gt_match_blast_set_bitscore</code></a><br>

  <a href="#gt_match_blast_set_evalue"><code>gt_match_blast_set_evalue</code></a><br>

  <a href="#gt_match_blast_set_similarity"><code>gt_match_blast_set_similarity</code></a><br>

  <a href="#gt_match_delete"><code>gt_match_delete</code></a><br>

  <a href="#gt_match_get_direction"><code>gt_match_get_direction</code></a><br>

  <a href="#gt_match_get_range_seq1"><code>gt_match_get_range_seq1</code></a><br>

  <a href="#gt_match_get_range_seq2"><code>gt_match_get_range_seq2</code></a><br>

  <a href="#gt_match_get_seqid1"><code>gt_match_get_seqid1</code></a><br>

  <a href="#gt_match_get_seqid2"><code>gt_match_get_seqid2</code></a><br>

  <a href="#gt_match_iterator_delete"><code>gt_match_iterator_delete</code></a><br>

  <a href="#gt_match_iterator_next"><code>gt_match_iterator_next</code></a><br>

  <a href="#gt_match_last_get_score"><code>gt_match_last_get_score</code></a><br>

  <a href="#gt_match_last_get_seqno1"><code>gt_match_last_get_seqno1</code></a><br>

  <a href="#gt_match_last_get_seqno2"><code>gt_match_last_get_seqno2</code></a><br>

  <a href="#gt_match_last_new"><code>gt_match_last_new</code></a><br>

  <a href="#gt_match_open_get_weight"><code>gt_match_open_get_weight</code></a><br>

  <a href="#gt_match_open_new"><code>gt_match_open_new</code></a><br>

  <a href="#gt_match_open_set_weight"><code>gt_match_open_set_weight</code></a><br>

  <a href="#gt_match_set_range_seq1"><code>gt_match_set_range_seq1</code></a><br>

  <a href="#gt_match_set_range_seq2"><code>gt_match_set_range_seq2</code></a><br>

  <a href="#gt_match_set_seqid1"><code>gt_match_set_seqid1</code></a><br>

  <a href="#gt_match_set_seqid1_nt"><code>gt_match_set_seqid1_nt</code></a><br>

  <a href="#gt_match_set_seqid2"><code>gt_match_set_seqid2</code></a><br>

  <a href="#gt_match_set_seqid2_nt"><code>gt_match_set_seqid2_nt</code></a><br>

  <a href="#gt_match_sw_get_alignment_length"><code>gt_match_sw_get_alignment_length</code></a><br>

  <a href="#gt_match_sw_get_edist"><code>gt_match_sw_get_edist</code></a><br>

  <a href="#gt_match_sw_get_seqno1"><code>gt_match_sw_get_seqno1</code></a><br>

  <a href="#gt_match_sw_get_seqno2"><code>gt_match_sw_get_seqno2</code></a><br>

  <a href="#gt_match_sw_new"><code>gt_match_sw_new</code></a><br>

  <a href="#gt_match_visitor_delete"><code>gt_match_visitor_delete</code></a><br>

  <a href="#gt_match_visitor_visit_match_blast"><code>gt_match_visitor_visit_match_blast</code></a><br>

  <a href="#gt_match_visitor_visit_match_open"><code>gt_match_visitor_visit_match_open</code></a><br>

  <a href="#gt_md5_encoder_add_block"><code>gt_md5_encoder_add_block</code></a><br>

  <a href="#gt_md5_encoder_delete"><code>gt_md5_encoder_delete</code></a><br>

  <a href="#gt_md5_encoder_finish"><code>gt_md5_encoder_finish</code></a><br>

  <a href="#gt_md5_encoder_new"><code>gt_md5_encoder_new</code></a><br>

  <a href="#gt_md5_encoder_reset"><code>gt_md5_encoder_reset</code></a><br>

  <a href="#gt_md5_fingerprint"><code>gt_md5_fingerprint</code></a><br>

  <a href="#gt_md5_to_id_stream_new"><code>gt_md5_to_id_stream_new</code></a><br>

  <a href="#gt_merge_feature_stream_new"><code>gt_merge_feature_stream_new</code></a><br>

  <a href="#gt_merge_stream_new"><code>gt_merge_stream_new</code></a><br>

  <a href="#gt_meta_node_cast"><code>gt_meta_node_cast</code></a><br>

  <a href="#gt_meta_node_get_data"><code>gt_meta_node_get_data</code></a><br>

  <a href="#gt_meta_node_get_directive"><code>gt_meta_node_get_directive</code></a><br>

  <a href="#gt_meta_node_new"><code>gt_meta_node_new</code></a><br>

  <a href="#gt_meta_node_try_cast"><code>gt_meta_node_try_cast</code></a><br>

  <a href="#gt_msort"><code>gt_msort</code></a><br>

  <a href="#gt_msort_r"><code>gt_msort_r</code></a><br>

  <a href="#gt_multithread"><code>gt_multithread</code></a><br>

  <a href="#gt_mutex_delete"><code>gt_mutex_delete</code></a><br>

  <a href="#gt_mutex_lock"><code>gt_mutex_lock</code></a><br>

  <a href="#gt_mutex_new"><code>gt_mutex_new</code></a><br>

  <a href="#gt_mutex_unlock"><code>gt_mutex_unlock</code></a><br>

  <a href="#gt_node_stream_cast"><code>gt_node_stream_cast</code></a><br>

  <a href="#gt_node_stream_class_new"><code>gt_node_stream_class_new</code></a><br>

  <a href="#gt_node_stream_create"><code>gt_node_stream_create</code></a><br>

  <a href="#gt_node_stream_delete"><code>gt_node_stream_delete</code></a><br>

  <a href="#gt_node_stream_is_sorted"><code>gt_node_stream_is_sorted</code></a><br>

  <a href="#gt_node_stream_next"><code>gt_node_stream_next</code></a><br>

  <a href="#gt_node_stream_pull"><code>gt_node_stream_pull</code></a><br>

  <a href="#gt_node_stream_ref"><code>gt_node_stream_ref</code></a><br>

  <a href="#gt_node_visitor_delete"><code>gt_node_visitor_delete</code></a><br>

  <a href="#gt_node_visitor_visit_comment_node"><code>gt_node_visitor_visit_comment_node</code></a><br>

  <a href="#gt_node_visitor_visit_feature_node"><code>gt_node_visitor_visit_feature_node</code></a><br>

  <a href="#gt_node_visitor_visit_meta_node"><code>gt_node_visitor_visit_meta_node</code></a><br>

  <a href="#gt_node_visitor_visit_region_node"><code>gt_node_visitor_visit_region_node</code></a><br>

  <a href="#gt_node_visitor_visit_sequence_node"><code>gt_node_visitor_visit_sequence_node</code></a><br>

  <a href="#gt_option_argument_is_optional"><code>gt_option_argument_is_optional</code></a><br>

  <a href="#gt_option_delete"><code>gt_option_delete</code></a><br>

  <a href="#gt_option_exclude"><code>gt_option_exclude</code></a><br>

  <a href="#gt_option_get_name"><code>gt_option_get_name</code></a><br>

  <a href="#gt_option_hide_default"><code>gt_option_hide_default</code></a><br>

  <a href="#gt_option_imply"><code>gt_option_imply</code></a><br>

  <a href="#gt_option_imply_either_2"><code>gt_option_imply_either_2</code></a><br>

  <a href="#gt_option_imply_either_3"><code>gt_option_imply_either_3</code></a><br>

  <a href="#gt_option_is_development_option"><code>gt_option_is_development_option</code></a><br>

  <a href="#gt_option_is_extended_option"><code>gt_option_is_extended_option</code></a><br>

  <a href="#gt_option_is_mandatory"><code>gt_option_is_mandatory</code></a><br>

  <a href="#gt_option_is_mandatory_either"><code>gt_option_is_mandatory_either</code></a><br>

  <a href="#gt_option_is_mandatory_either_3"><code>gt_option_is_mandatory_either_3</code></a><br>

  <a href="#gt_option_is_mandatory_either_4"><code>gt_option_is_mandatory_either_4</code></a><br>

  <a href="#gt_option_is_set"><code>gt_option_is_set</code></a><br>

  <a href="#gt_option_new_bool"><code>gt_option_new_bool</code></a><br>

  <a href="#gt_option_new_choice"><code>gt_option_new_choice</code></a><br>

  <a href="#gt_option_new_debug"><code>gt_option_new_debug</code></a><br>

  <a href="#gt_option_new_double"><code>gt_option_new_double</code></a><br>

  <a href="#gt_option_new_double_min"><code>gt_option_new_double_min</code></a><br>

  <a href="#gt_option_new_double_min_max"><code>gt_option_new_double_min_max</code></a><br>

  <a href="#gt_option_new_filename"><code>gt_option_new_filename</code></a><br>

  <a href="#gt_option_new_filename_array"><code>gt_option_new_filename_array</code></a><br>

  <a href="#gt_option_new_int"><code>gt_option_new_int</code></a><br>

  <a href="#gt_option_new_int_max"><code>gt_option_new_int_max</code></a><br>

  <a href="#gt_option_new_int_min"><code>gt_option_new_int_min</code></a><br>

  <a href="#gt_option_new_int_min_max"><code>gt_option_new_int_min_max</code></a><br>

  <a href="#gt_option_new_long"><code>gt_option_new_long</code></a><br>

  <a href="#gt_option_new_probability"><code>gt_option_new_probability</code></a><br>

  <a href="#gt_option_new_range"><code>gt_option_new_range</code></a><br>

  <a href="#gt_option_new_range_min_max"><code>gt_option_new_range_min_max</code></a><br>

  <a href="#gt_option_new_string"><code>gt_option_new_string</code></a><br>

  <a href="#gt_option_new_string_array"><code>gt_option_new_string_array</code></a><br>

  <a href="#gt_option_new_uint"><code>gt_option_new_uint</code></a><br>

  <a href="#gt_option_new_uint_max"><code>gt_option_new_uint_max</code></a><br>

  <a href="#gt_option_new_uint_min"><code>gt_option_new_uint_min</code></a><br>

  <a href="#gt_option_new_uint_min_max"><code>gt_option_new_uint_min_max</code></a><br>

  <a href="#gt_option_new_ulong"><code>gt_option_new_ulong</code></a><br>

  <a href="#gt_option_new_ulong_min"><code>gt_option_new_ulong_min</code></a><br>

  <a href="#gt_option_new_ulong_min_max"><code>gt_option_new_ulong_min_max</code></a><br>

  <a href="#gt_option_new_uword"><code>gt_option_new_uword</code></a><br>

  <a href="#gt_option_new_uword_min"><code>gt_option_new_uword_min</code></a><br>

  <a href="#gt_option_new_uword_min_max"><code>gt_option_new_uword_min_max</code></a><br>

  <a href="#gt_option_new_verbose"><code>gt_option_new_verbose</code></a><br>

  <a href="#gt_option_new_width"><code>gt_option_new_width</code></a><br>

  <a href="#gt_option_new_word"><code>gt_option_new_word</code></a><br>

  <a href="#gt_option_parse_spacespec"><code>gt_option_parse_spacespec</code></a><br>

  <a href="#gt_option_parser_add_option"><code>gt_option_parser_add_option</code></a><br>

  <a href="#gt_option_parser_delete"><code>gt_option_parser_delete</code></a><br>

  <a href="#gt_option_parser_get_option"><code>gt_option_parser_get_option</code></a><br>

  <a href="#gt_option_parser_new"><code>gt_option_parser_new</code></a><br>

  <a href="#gt_option_parser_parse"><code>gt_option_parser_parse</code></a><br>

  <a href="#gt_option_parser_refer_to_manual"><code>gt_option_parser_refer_to_manual</code></a><br>

  <a href="#gt_option_parser_register_hook"><code>gt_option_parser_register_hook</code></a><br>

  <a href="#gt_option_parser_reset"><code>gt_option_parser_reset</code></a><br>

  <a href="#gt_option_parser_set_comment_func"><code>gt_option_parser_set_comment_func</code></a><br>

  <a href="#gt_option_parser_set_mail_address"><code>gt_option_parser_set_mail_address</code></a><br>

  <a href="#gt_option_parser_set_max_args"><code>gt_option_parser_set_max_args</code></a><br>

  <a href="#gt_option_parser_set_min_args"><code>gt_option_parser_set_min_args</code></a><br>

  <a href="#gt_option_parser_set_min_max_args"><code>gt_option_parser_set_min_max_args</code></a><br>

  <a href="#gt_option_parser_set_version_func"><code>gt_option_parser_set_version_func</code></a><br>

  <a href="#gt_option_ref"><code>gt_option_ref</code></a><br>

  <a href="#gt_orf_iterator_delete"><code>gt_orf_iterator_delete</code></a><br>

  <a href="#gt_orf_iterator_new"><code>gt_orf_iterator_new</code></a><br>

  <a href="#gt_orf_iterator_next"><code>gt_orf_iterator_next</code></a><br>

  <a href="#gt_output_file_info_delete"><code>gt_output_file_info_delete</code></a><br>

  <a href="#gt_output_file_info_new"><code>gt_output_file_info_new</code></a><br>

  <a href="#gt_output_file_info_register_options"><code>gt_output_file_info_register_options</code></a><br>

  <a href="#gt_parse_double"><code>gt_parse_double</code></a><br>

  <a href="#gt_parse_int"><code>gt_parse_int</code></a><br>

  <a href="#gt_parse_long"><code>gt_parse_long</code></a><br>

  <a href="#gt_parse_range"><code>gt_parse_range</code></a><br>

  <a href="#gt_parse_range_tidy"><code>gt_parse_range_tidy</code></a><br>

  <a href="#gt_parse_uint"><code>gt_parse_uint</code></a><br>

  <a href="#gt_parse_ulong"><code>gt_parse_ulong</code></a><br>

  <a href="#gt_phase_get"><code>gt_phase_get</code></a><br>

  <a href="#gt_qsort_r"><code>gt_qsort_r</code></a><br>

  <a href="#gt_queue_add"><code>gt_queue_add</code></a><br>

  <a href="#gt_queue_delete"><code>gt_queue_delete</code></a><br>

  <a href="#gt_queue_get"><code>gt_queue_get</code></a><br>

  <a href="#gt_queue_head"><code>gt_queue_head</code></a><br>

  <a href="#gt_queue_new"><code>gt_queue_new</code></a><br>

  <a href="#gt_queue_remove"><code>gt_queue_remove</code></a><br>

  <a href="#gt_queue_size"><code>gt_queue_size</code></a><br>

  <a href="#gt_range_compare"><code>gt_range_compare</code></a><br>

  <a href="#gt_range_compare_with_delta"><code>gt_range_compare_with_delta</code></a><br>

  <a href="#gt_range_contains"><code>gt_range_contains</code></a><br>

  <a href="#gt_range_join"><code>gt_range_join</code></a><br>

  <a href="#gt_range_length"><code>gt_range_length</code></a><br>

  <a href="#gt_range_offset"><code>gt_range_offset</code></a><br>

  <a href="#gt_range_overlap"><code>gt_range_overlap</code></a><br>

  <a href="#gt_range_overlap_delta"><code>gt_range_overlap_delta</code></a><br>

  <a href="#gt_range_within"><code>gt_range_within</code></a><br>

  <a href="#gt_rdb_mysql_new"><code>gt_rdb_mysql_new</code></a><br>

  <a href="#gt_rdb_sqlite_new"><code>gt_rdb_sqlite_new</code></a><br>

  <a href="#gt_rdb_visitor_delete"><code>gt_rdb_visitor_delete</code></a><br>

  <a href="#gt_rdb_visitor_visit_mysql"><code>gt_rdb_visitor_visit_mysql</code></a><br>

  <a href="#gt_rdb_visitor_visit_sqlite"><code>gt_rdb_visitor_visit_sqlite</code></a><br>

  <a href="#gt_readmode_parse"><code>gt_readmode_parse</code></a><br>

  <a href="#gt_readmode_show"><code>gt_readmode_show</code></a><br>

  <a href="#gt_realloc"><code>gt_realloc</code></a><br>

  <a href="#gt_rec_map_delete"><code>gt_rec_map_delete</code></a><br>

  <a href="#gt_rec_map_get_genome_feature"><code>gt_rec_map_get_genome_feature</code></a><br>

  <a href="#gt_rec_map_get_northwest_x"><code>gt_rec_map_get_northwest_x</code></a><br>

  <a href="#gt_rec_map_get_northwest_y"><code>gt_rec_map_get_northwest_y</code></a><br>

  <a href="#gt_rec_map_get_southeast_x"><code>gt_rec_map_get_southeast_x</code></a><br>

  <a href="#gt_rec_map_get_southeast_y"><code>gt_rec_map_get_southeast_y</code></a><br>

  <a href="#gt_rec_map_has_omitted_children"><code>gt_rec_map_has_omitted_children</code></a><br>

  <a href="#gt_rec_map_new"><code>gt_rec_map_new</code></a><br>

  <a href="#gt_rec_map_ref"><code>gt_rec_map_ref</code></a><br>

  <a href="#gt_region_mapping_delete"><code>gt_region_mapping_delete</code></a><br>

  <a href="#gt_region_mapping_get_description"><code>gt_region_mapping_get_description</code></a><br>

  <a href="#gt_region_mapping_get_md5_fingerprint"><code>gt_region_mapping_get_md5_fingerprint</code></a><br>

  <a href="#gt_region_mapping_get_sequence"><code>gt_region_mapping_get_sequence</code></a><br>

  <a href="#gt_region_mapping_get_sequence_length"><code>gt_region_mapping_get_sequence_length</code></a><br>

  <a href="#gt_region_mapping_new_encseq"><code>gt_region_mapping_new_encseq</code></a><br>

  <a href="#gt_region_mapping_new_mapping"><code>gt_region_mapping_new_mapping</code></a><br>

  <a href="#gt_region_mapping_new_rawseq"><code>gt_region_mapping_new_rawseq</code></a><br>

  <a href="#gt_region_mapping_new_seqfiles"><code>gt_region_mapping_new_seqfiles</code></a><br>

  <a href="#gt_region_mapping_ref"><code>gt_region_mapping_ref</code></a><br>

  <a href="#gt_region_node_cast"><code>gt_region_node_cast</code></a><br>

  <a href="#gt_region_node_new"><code>gt_region_node_new</code></a><br>

  <a href="#gt_region_node_try_cast"><code>gt_region_node_try_cast</code></a><br>

  <a href="#gt_reverse_complement"><code>gt_reverse_complement</code></a><br>

  <a href="#gt_rwlock_delete"><code>gt_rwlock_delete</code></a><br>

  <a href="#gt_rwlock_new"><code>gt_rwlock_new</code></a><br>

  <a href="#gt_rwlock_rdlock"><code>gt_rwlock_rdlock</code></a><br>

  <a href="#gt_rwlock_unlock"><code>gt_rwlock_unlock</code></a><br>

  <a href="#gt_rwlock_wrlock"><code>gt_rwlock_wrlock</code></a><br>

  <a href="#gt_script_wrapper_stream_new"><code>gt_script_wrapper_stream_new</code></a><br>

  <a href="#gt_script_wrapper_visitor_new"><code>gt_script_wrapper_visitor_new</code></a><br>

  <a href="#gt_select_stream_new"><code>gt_select_stream_new</code></a><br>

  <a href="#gt_select_stream_set_drophandler"><code>gt_select_stream_set_drophandler</code></a><br>

  <a href="#gt_seq_iterator_delete"><code>gt_seq_iterator_delete</code></a><br>

  <a href="#gt_seq_iterator_fastq_get_file_index"><code>gt_seq_iterator_fastq_get_file_index</code></a><br>

  <a href="#gt_seq_iterator_fastq_new"><code>gt_seq_iterator_fastq_new</code></a><br>

  <a href="#gt_seq_iterator_fastq_new_colorspace"><code>gt_seq_iterator_fastq_new_colorspace</code></a><br>

  <a href="#gt_seq_iterator_fastq_relax_check_of_quality_description"><code>gt_seq_iterator_fastq_relax_check_of_quality_description</code></a><br>

  <a href="#gt_seq_iterator_getcurrentcounter"><code>gt_seq_iterator_getcurrentcounter</code></a><br>

  <a href="#gt_seq_iterator_has_qualities"><code>gt_seq_iterator_has_qualities</code></a><br>

  <a href="#gt_seq_iterator_next"><code>gt_seq_iterator_next</code></a><br>

  <a href="#gt_seq_iterator_sequence_buffer_new"><code>gt_seq_iterator_sequence_buffer_new</code></a><br>

  <a href="#gt_seq_iterator_set_quality_buffer"><code>gt_seq_iterator_set_quality_buffer</code></a><br>

  <a href="#gt_seq_iterator_set_sequence_output"><code>gt_seq_iterator_set_sequence_output</code></a><br>

  <a href="#gt_seq_iterator_set_symbolmap"><code>gt_seq_iterator_set_symbolmap</code></a><br>

  <a href="#gt_sequence_node_cast"><code>gt_sequence_node_cast</code></a><br>

  <a href="#gt_sequence_node_get_description"><code>gt_sequence_node_get_description</code></a><br>

  <a href="#gt_sequence_node_get_sequence"><code>gt_sequence_node_get_sequence</code></a><br>

  <a href="#gt_sequence_node_get_sequence_length"><code>gt_sequence_node_get_sequence_length</code></a><br>

  <a href="#gt_sequence_node_new"><code>gt_sequence_node_new</code></a><br>

  <a href="#gt_sequence_node_try_cast"><code>gt_sequence_node_try_cast</code></a><br>

  <a href="#gt_set_source_visitor_new"><code>gt_set_source_visitor_new</code></a><br>

  <a href="#gt_sort_stream_new"><code>gt_sort_stream_new</code></a><br>

  <a href="#gt_splitter_delete"><code>gt_splitter_delete</code></a><br>

  <a href="#gt_splitter_get_token"><code>gt_splitter_get_token</code></a><br>

  <a href="#gt_splitter_get_tokens"><code>gt_splitter_get_tokens</code></a><br>

  <a href="#gt_splitter_new"><code>gt_splitter_new</code></a><br>

  <a href="#gt_splitter_reset"><code>gt_splitter_reset</code></a><br>

  <a href="#gt_splitter_size"><code>gt_splitter_size</code></a><br>

  <a href="#gt_splitter_split"><code>gt_splitter_split</code></a><br>

  <a href="#gt_stat_stream_new"><code>gt_stat_stream_new</code></a><br>

  <a href="#gt_stat_stream_show_stats"><code>gt_stat_stream_show_stats</code></a><br>

  <a href="#gt_str_append_char"><code>gt_str_append_char</code></a><br>

  <a href="#gt_str_append_cstr"><code>gt_str_append_cstr</code></a><br>

  <a href="#gt_str_append_cstr_nt"><code>gt_str_append_cstr_nt</code></a><br>

  <a href="#gt_str_append_double"><code>gt_str_append_double</code></a><br>

  <a href="#gt_str_append_int"><code>gt_str_append_int</code></a><br>

  <a href="#gt_str_append_str"><code>gt_str_append_str</code></a><br>

  <a href="#gt_str_append_uint"><code>gt_str_append_uint</code></a><br>

  <a href="#gt_str_append_ulong"><code>gt_str_append_ulong</code></a><br>

  <a href="#gt_str_array_add"><code>gt_str_array_add</code></a><br>

  <a href="#gt_str_array_add_cstr"><code>gt_str_array_add_cstr</code></a><br>

  <a href="#gt_str_array_add_cstr_nt"><code>gt_str_array_add_cstr_nt</code></a><br>

  <a href="#gt_str_array_delete"><code>gt_str_array_delete</code></a><br>

  <a href="#gt_str_array_get"><code>gt_str_array_get</code></a><br>

  <a href="#gt_str_array_new"><code>gt_str_array_new</code></a><br>

  <a href="#gt_str_array_ref"><code>gt_str_array_ref</code></a><br>

  <a href="#gt_str_array_reset"><code>gt_str_array_reset</code></a><br>

  <a href="#gt_str_array_set"><code>gt_str_array_set</code></a><br>

  <a href="#gt_str_array_set_cstr"><code>gt_str_array_set_cstr</code></a><br>

  <a href="#gt_str_array_set_size"><code>gt_str_array_set_size</code></a><br>

  <a href="#gt_str_array_size"><code>gt_str_array_size</code></a><br>

  <a href="#gt_str_clone"><code>gt_str_clone</code></a><br>

  <a href="#gt_str_cmp"><code>gt_str_cmp</code></a><br>

  <a href="#gt_str_delete"><code>gt_str_delete</code></a><br>

  <a href="#gt_str_get"><code>gt_str_get</code></a><br>

  <a href="#gt_str_length"><code>gt_str_length</code></a><br>

  <a href="#gt_str_new"><code>gt_str_new</code></a><br>

  <a href="#gt_str_new_cstr"><code>gt_str_new_cstr</code></a><br>

  <a href="#gt_str_ref"><code>gt_str_ref</code></a><br>

  <a href="#gt_str_reset"><code>gt_str_reset</code></a><br>

  <a href="#gt_str_set"><code>gt_str_set</code></a><br>

  <a href="#gt_str_set_length"><code>gt_str_set_length</code></a><br>

  <a href="#gt_strand_get"><code>gt_strand_get</code></a><br>

  <a href="#gt_strcmp"><code>gt_strcmp</code></a><br>

  <a href="#gt_style_clone"><code>gt_style_clone</code></a><br>

  <a href="#gt_style_delete"><code>gt_style_delete</code></a><br>

  <a href="#gt_style_get_bool"><code>gt_style_get_bool</code></a><br>

  <a href="#gt_style_get_bool_with_track"><code>gt_style_get_bool_with_track</code></a><br>

  <a href="#gt_style_get_color"><code>gt_style_get_color</code></a><br>

  <a href="#gt_style_get_color_with_track"><code>gt_style_get_color_with_track</code></a><br>

  <a href="#gt_style_get_num"><code>gt_style_get_num</code></a><br>

  <a href="#gt_style_get_num_with_track"><code>gt_style_get_num_with_track</code></a><br>

  <a href="#gt_style_get_str"><code>gt_style_get_str</code></a><br>

  <a href="#gt_style_get_str_with_track"><code>gt_style_get_str_with_track</code></a><br>

  <a href="#gt_style_is_unsafe"><code>gt_style_is_unsafe</code></a><br>

  <a href="#gt_style_load_file"><code>gt_style_load_file</code></a><br>

  <a href="#gt_style_load_str"><code>gt_style_load_str</code></a><br>

  <a href="#gt_style_new"><code>gt_style_new</code></a><br>

  <a href="#gt_style_ref"><code>gt_style_ref</code></a><br>

  <a href="#gt_style_reload"><code>gt_style_reload</code></a><br>

  <a href="#gt_style_safe_mode"><code>gt_style_safe_mode</code></a><br>

  <a href="#gt_style_set_bool"><code>gt_style_set_bool</code></a><br>

  <a href="#gt_style_set_color"><code>gt_style_set_color</code></a><br>

  <a href="#gt_style_set_num"><code>gt_style_set_num</code></a><br>

  <a href="#gt_style_set_str"><code>gt_style_set_str</code></a><br>

  <a href="#gt_style_to_str"><code>gt_style_to_str</code></a><br>

  <a href="#gt_style_unsafe_mode"><code>gt_style_unsafe_mode</code></a><br>

  <a href="#gt_style_unset"><code>gt_style_unset</code></a><br>

  <a href="#gt_symbol"><code>gt_symbol</code></a><br>

  <a href="#gt_tag_value_map_add"><code>gt_tag_value_map_add</code></a><br>

  <a href="#gt_tag_value_map_delete"><code>gt_tag_value_map_delete</code></a><br>

  <a href="#gt_tag_value_map_example"><code>gt_tag_value_map_example</code></a><br>

  <a href="#gt_tag_value_map_foreach"><code>gt_tag_value_map_foreach</code></a><br>

  <a href="#gt_tag_value_map_get"><code>gt_tag_value_map_get</code></a><br>

  <a href="#gt_tag_value_map_new"><code>gt_tag_value_map_new</code></a><br>

  <a href="#gt_tag_value_map_remove"><code>gt_tag_value_map_remove</code></a><br>

  <a href="#gt_tag_value_map_set"><code>gt_tag_value_map_set</code></a><br>

  <a href="#gt_text_width_calculator_cairo_new"><code>gt_text_width_calculator_cairo_new</code></a><br>

  <a href="#gt_text_width_calculator_delete"><code>gt_text_width_calculator_delete</code></a><br>

  <a href="#gt_text_width_calculator_get_text_width"><code>gt_text_width_calculator_get_text_width</code></a><br>

  <a href="#gt_text_width_calculator_ref"><code>gt_text_width_calculator_ref</code></a><br>

  <a href="#gt_thread_delete"><code>gt_thread_delete</code></a><br>

  <a href="#gt_thread_join"><code>gt_thread_join</code></a><br>

  <a href="#gt_thread_new"><code>gt_thread_new</code></a><br>

  <a href="#gt_timer_delete"><code>gt_timer_delete</code></a><br>

  <a href="#gt_timer_new"><code>gt_timer_new</code></a><br>

  <a href="#gt_timer_new_with_progress_description"><code>gt_timer_new_with_progress_description</code></a><br>

  <a href="#gt_timer_omit_last_stage"><code>gt_timer_omit_last_stage</code></a><br>

  <a href="#gt_timer_show"><code>gt_timer_show</code></a><br>

  <a href="#gt_timer_show_cpu_time_by_progress"><code>gt_timer_show_cpu_time_by_progress</code></a><br>

  <a href="#gt_timer_show_formatted"><code>gt_timer_show_formatted</code></a><br>

  <a href="#gt_timer_show_progress"><code>gt_timer_show_progress</code></a><br>

  <a href="#gt_timer_show_progress_final"><code>gt_timer_show_progress_final</code></a><br>

  <a href="#gt_timer_show_progress_formatted"><code>gt_timer_show_progress_formatted</code></a><br>

  <a href="#gt_timer_show_progress_va"><code>gt_timer_show_progress_va</code></a><br>

  <a href="#gt_timer_start"><code>gt_timer_start</code></a><br>

  <a href="#gt_timer_stop"><code>gt_timer_stop</code></a><br>

  <a href="#gt_tool_delete"><code>gt_tool_delete</code></a><br>

  <a href="#gt_tool_new"><code>gt_tool_new</code></a><br>

  <a href="#gt_tool_run"><code>gt_tool_run</code></a><br>

  <a href="#gt_toolbox_add_hidden_tool"><code>gt_toolbox_add_hidden_tool</code></a><br>

  <a href="#gt_toolbox_add_tool"><code>gt_toolbox_add_tool</code></a><br>

  <a href="#gt_toolbox_delete"><code>gt_toolbox_delete</code></a><br>

  <a href="#gt_toolbox_get_tool"><code>gt_toolbox_get_tool</code></a><br>

  <a href="#gt_toolbox_new"><code>gt_toolbox_new</code></a><br>

  <a href="#gt_toolbox_show"><code>gt_toolbox_show</code></a><br>

  <a href="#gt_trans_table_delete"><code>gt_trans_table_delete</code></a><br>

  <a href="#gt_trans_table_description"><code>gt_trans_table_description</code></a><br>

  <a href="#gt_trans_table_get_scheme_descriptions"><code>gt_trans_table_get_scheme_descriptions</code></a><br>

  <a href="#gt_trans_table_new"><code>gt_trans_table_new</code></a><br>

  <a href="#gt_trans_table_new_standard"><code>gt_trans_table_new_standard</code></a><br>

  <a href="#gt_trans_table_translate_codon"><code>gt_trans_table_translate_codon</code></a><br>

  <a href="#gt_translator_delete"><code>gt_translator_delete</code></a><br>

  <a href="#gt_translator_find_codon"><code>gt_translator_find_codon</code></a><br>

  <a href="#gt_translator_find_startcodon"><code>gt_translator_find_startcodon</code></a><br>

  <a href="#gt_translator_find_stopcodon"><code>gt_translator_find_stopcodon</code></a><br>

  <a href="#gt_translator_new"><code>gt_translator_new</code></a><br>

  <a href="#gt_translator_new_with_table"><code>gt_translator_new_with_table</code></a><br>

  <a href="#gt_translator_next"><code>gt_translator_next</code></a><br>

  <a href="#gt_translator_set_codon_iterator"><code>gt_translator_set_codon_iterator</code></a><br>

  <a href="#gt_translator_set_translation_table"><code>gt_translator_set_translation_table</code></a><br>

  <a href="#gt_type_checker_delete"><code>gt_type_checker_delete</code></a><br>

  <a href="#gt_type_checker_description"><code>gt_type_checker_description</code></a><br>

  <a href="#gt_type_checker_is_a"><code>gt_type_checker_is_a</code></a><br>

  <a href="#gt_type_checker_is_partof"><code>gt_type_checker_is_partof</code></a><br>

  <a href="#gt_type_checker_is_valid"><code>gt_type_checker_is_valid</code></a><br>

  <a href="#gt_type_checker_obo_new"><code>gt_type_checker_obo_new</code></a><br>

  <a href="#gt_type_checker_ref"><code>gt_type_checker_ref</code></a><br>

  <a href="#gt_uniq_stream_new"><code>gt_uniq_stream_new</code></a><br>

  <a href="#gt_version"><code>gt_version</code></a><br>

  <a href="#gt_version_check"><code>gt_version_check</code></a><br>

  <a href="#gt_visitor_stream_new"><code>gt_visitor_stream_new</code></a><br>

  <a href="#gt_warning"><code>gt_warning</code></a><br>

  <a href="#gt_warning_default_handler"><code>gt_warning_default_handler</code></a><br>

  <a href="#gt_warning_disable"><code>gt_warning_disable</code></a><br>

  <a href="#gt_warning_get_data"><code>gt_warning_get_data</code></a><br>

  <a href="#gt_warning_get_handler"><code>gt_warning_get_handler</code></a><br>

  <a href="#gt_warning_set_handler"><code>gt_warning_set_handler</code></a><br>

  <a href="#gt_xatexit"><code>gt_xatexit</code></a><br>

  <a href="#gt_xfclose"><code>gt_xfclose</code></a><br>

  <a href="#gt_xfflush"><code>gt_xfflush</code></a><br>

  <a href="#gt_xfgetc"><code>gt_xfgetc</code></a><br>

  <a href="#gt_xfgetpos"><code>gt_xfgetpos</code></a><br>

  <a href="#gt_xfgets"><code>gt_xfgets</code></a><br>

  <a href="#gt_xfopen"><code>gt_xfopen</code></a><br>

  <a href="#gt_xfputc"><code>gt_xfputc</code></a><br>

  <a href="#gt_xfputs"><code>gt_xfputs</code></a><br>

  <a href="#gt_xfread"><code>gt_xfread</code></a><br>

  <a href="#gt_xfread_one"><code>gt_xfread_one</code></a><br>

  <a href="#gt_xfseek"><code>gt_xfseek</code></a><br>

  <a href="#gt_xfsetpos"><code>gt_xfsetpos</code></a><br>

  <a href="#gt_xfwrite"><code>gt_xfwrite</code></a><br>

  <a href="#gt_xfwrite_one"><code>gt_xfwrite_one</code></a><br>

  <a href="#gt_xputchar"><code>gt_xputchar</code></a><br>

  <a href="#gt_xputs"><code>gt_xputs</code></a><br>

  <a href="#gt_xremove"><code>gt_xremove</code></a><br>

  <a href="#gt_xrf_checker_delete"><code>gt_xrf_checker_delete</code></a><br>

  <a href="#gt_xrf_checker_is_valid"><code>gt_xrf_checker_is_valid</code></a><br>

  <a href="#gt_xrf_checker_new"><code>gt_xrf_checker_new</code></a><br>

  <a href="#gt_xrf_checker_ref"><code>gt_xrf_checker_ref</code></a><br>

  <a href="#gt_xungetc"><code>gt_xungetc</code></a><br>

  <a href="#gt_xvfprintf"><code>gt_xvfprintf</code></a><br>

  <a href="#gt_xvsnprintf"><code>gt_xvsnprintf</code></a><br>

<div id="footer">
Copyright &copy; 2008-2013
The <i>GenomeTools</i> authors.
Last update: 2014-07-11
</div>
</div>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = "https://zenlicensemanager.com/piwik/";
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 5);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="https://zenlicensemanager.com/piwik/piwik.php?idsite=5" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Tag -->
</body>
</html>
