<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>GenomeTools C API</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="menu">
<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="pub/">Download</a></li>
<li><a href="cgi-bin/gitweb.cgi?p=genometools.git;a=summary">Browse source</a></li>
<li><a href="mailman/listinfo/gt-users">Mailing list</a></li>
<li><a href="http://genometools.lighthouseapp.com/">Issue tracker</a></li>
<li><a href="design.html">Design</a></li>
<li><a id="current" href="libgenometools.html">C API</a></li>
<li><a href="docs.html"><tt>gtscript</tt> docs</a></li>
<li><a href="annotationsketch.html"><tt>AnnotationSketch</tt></a></li>
<li><a href="license.html">License</a></li>
</ul>
</div>
<div id="main">
<h1><i>GenomeTools</i> C API</h1>
<p>
This document describes the <i>GenomeTools</i> C API (that is, all public interfaces which are part of <tt>libgenometools</tt>).
</p>
<p>
See the <a href="#Index">index</a> for an alphabetical list of all available
interfaces.
</p>
<h2>Classes</h2>
<ul>

  <li><a href="#GtAddIntronsStream">GtAddIntronsStream</a>

  <li><a href="#GtAlphabet">GtAlphabet</a>

  <li><a href="#GtArray">GtArray</a>

  <li><a href="#GtBEDInStream">GtBEDInStream</a>

  <li><a href="#GtBittab">GtBittab</a>

  <li><a href="#GtBlock">GtBlock</a>

  <li><a href="#GtCDSStream">GtCDSStream</a>

  <li><a href="#GtCSAStream">GtCSAStream</a>

  <li><a href="#GtCanvas">GtCanvas</a>

  <li><a href="#GtCanvasCairoContext">GtCanvasCairoContext</a>

  <li><a href="#GtCanvasCairoFile">GtCanvasCairoFile</a>

  <li><a href="#GtCodonIterator">GtCodonIterator</a>

  <li><a href="#GtColor">GtColor</a>

  <li><a href="#GtCommentNode">GtCommentNode</a>

  <li><a href="#GtCstrTable">GtCstrTable</a>

  <li><a href="#GtCustomTrack">GtCustomTrack</a>

  <li><a href="#GtCustomTrackGcContent">GtCustomTrackGcContent</a>

  <li><a href="#GtCustomTrackScriptWrapper">GtCustomTrackScriptWrapper</a>

  <li><a href="#GtDiagram">GtDiagram</a>

  <li><a href="#GtDlist">GtDlist</a>

  <li><a href="#GtDlistelem">GtDlistelem</a>

  <li><a href="#GtEOFNode">GtEOFNode</a>

  <li><a href="#GtEncseq">GtEncseq</a>

  <li><a href="#GtEncseqBuilder">GtEncseqBuilder</a>

  <li><a href="#GtEncseqEncoder">GtEncseqEncoder</a>

  <li><a href="#GtEncseqLoader">GtEncseqLoader</a>

  <li><a href="#GtEncseqReader">GtEncseqReader</a>

  <li><a href="#GtError">GtError</a>

  <li><a href="#GtExtractFeatureStream">GtExtractFeatureStream</a>

  <li><a href="#GtFeatureIndex">GtFeatureIndex</a>

  <li><a href="#GtFeatureIndexMemory">GtFeatureIndexMemory</a>

  <li><a href="#GtFeatureNode">GtFeatureNode</a>

  <li><a href="#GtFeatureNodeIterator">GtFeatureNodeIterator</a>

  <li><a href="#GtFile">GtFile</a>

  <li><a href="#GtGFF3InStream">GtGFF3InStream</a>

  <li><a href="#GtGFF3OutStream">GtGFF3OutStream</a>

  <li><a href="#GtGFF3Parser">GtGFF3Parser</a>

  <li><a href="#GtGFF3Visitor">GtGFF3Visitor</a>

  <li><a href="#GtGTFInStream">GtGTFInStream</a>

  <li><a href="#GtGTFOutStream">GtGTFOutStream</a>

  <li><a href="#GtGenomeNode">GtGenomeNode</a>

  <li><a href="#GtGraphics">GtGraphics</a>

  <li><a href="#GtHashmap">GtHashmap</a>

  <li><a href="#GtIDToMD5Stream">GtIDToMD5Stream</a>

  <li><a href="#GtImageInfo">GtImageInfo</a>

  <li><a href="#GtInterFeatureStream">GtInterFeatureStream</a>

  <li><a href="#GtIntervalTree">GtIntervalTree</a>

  <li><a href="#GtIntervalTreeNode">GtIntervalTreeNode</a>

  <li><a href="#GtLayout">GtLayout</a>

  <li><a href="#GtLogger">GtLogger</a>

  <li><a href="#GtMD5ToIDStream">GtMD5ToIDStream</a>

  <li><a href="#GtMergeFeatureStream">GtMergeFeatureStream</a>

  <li><a href="#GtMergeStream">GtMergeStream</a>

  <li><a href="#GtNodeStream">GtNodeStream</a>

  <li><a href="#GtNodeStreamClass">GtNodeStreamClass</a>

  <li><a href="#GtNodeVisitor">GtNodeVisitor</a>

  <li><a href="#GtOption">GtOption</a>

  <li><a href="#GtOptionParser">GtOptionParser</a>

  <li><a href="#GtPhase">GtPhase</a>

  <li><a href="#GtQueue">GtQueue</a>

  <li><a href="#GtRange">GtRange</a>

  <li><a href="#GtReadmode">GtReadmode</a>

  <li><a href="#GtRecMap">GtRecMap</a>

  <li><a href="#GtRegionMapping">GtRegionMapping</a>

  <li><a href="#GtRegionNode">GtRegionNode</a>

  <li><a href="#GtSelectStream">GtSelectStream</a>

  <li><a href="#GtSequenceNode">GtSequenceNode</a>

  <li><a href="#GtSortStream">GtSortStream</a>

  <li><a href="#GtSplitter">GtSplitter</a>

  <li><a href="#GtStatStream">GtStatStream</a>

  <li><a href="#GtStr">GtStr</a>

  <li><a href="#GtStrArray">GtStrArray</a>

  <li><a href="#GtStrand">GtStrand</a>

  <li><a href="#GtStyle">GtStyle</a>

  <li><a href="#GtTagValueMap">GtTagValueMap</a>

  <li><a href="#GtTextWidthCalculator">GtTextWidthCalculator</a>

  <li><a href="#GtTextWidthCalculatorCairo">GtTextWidthCalculatorCairo</a>

  <li><a href="#GtTimer">GtTimer</a>

  <li><a href="#GtTransTable">GtTransTable</a>

  <li><a href="#GtTranslator">GtTranslator</a>

  <li><a href="#GtTypeChecker">GtTypeChecker</a>

  <li><a href="#GtTypeCheckerOBO">GtTypeCheckerOBO</a>

  <li><a href="#GtUniqStream">GtUniqStream</a>

  <li><a href="#GtVisitorStream">GtVisitorStream</a>

</ul>
<h2>Modules</h2>
<ul>

  <li><a href="#Array2dim">Array2dim</a>

  <li><a href="#Assert">Assert</a>

  <li><a href="#Bsearch">Bsearch</a>

  <li><a href="#Countingsort">Countingsort</a>

  <li><a href="#Cstr">Cstr</a>

  <li><a href="#Endianess">Endianess</a>

  <li><a href="#Fileutils">Fileutils</a>

  <li><a href="#FunctionPointer">FunctionPointer</a>

  <li><a href="#Grep">Grep</a>

  <li><a href="#Init">Init</a>

  <li><a href="#Log">Log</a>

  <li><a href="#MemoryAllocation">MemoryAllocation</a>

  <li><a href="#Msort">Msort</a>

  <li><a href="#POSIX">POSIX</a>

  <li><a href="#Parseutils">Parseutils</a>

  <li><a href="#Qsort">Qsort</a>

  <li><a href="#Strcmp">Strcmp</a>

  <li><a href="#Symbol">Symbol</a>

  <li><a href="#Undef">Undef</a>

  <li><a href="#Unused">Unused</a>

  <li><a href="#Version">Version</a>

  <li><a href="#Warning">Warning</a>

  <li><a href="#XANSI">XANSI</a>

</ul>
<a name="GtAddIntronsStream"></a>
<h2>Class GtAddIntronsStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtAddIntronsStream</code> inserts new
   feature nodes with type <em>intron</em> between existing feature nodes with type
   <em>exon</em>. This is a special case of the <code>GtInterFeatureStream</code>. </p>

<hr>
<a name="gt_add_introns_stream_new"></a>

<code>GtNodeStream*  gt_add_introns_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtAddIntronsStream*</code> which inserts feature nodes of type <em>intron</em>
   between feature nodes of type <em>exon</em> it retrieves from <code>in_stream</code> and
   returns them.
</p>
<hr>
<a name="GtAlphabet"></a>
<h2>Class GtAlphabet</h2>

<p> The following type is for storing alphabets.</p>

<hr>
<a name="gt_alphabet_new_dna"></a>

<code>GtAlphabet*     gt_alphabet_new_dna(void)</code>
<p>
Return a <code>GtAlphabet</code> object which represents a DNA alphabet.
</p>
<hr>
<a name="gt_alphabet_new_protein"></a>

<code>GtAlphabet*     gt_alphabet_new_protein(void)</code>
<p>
Return a <code>GtAlphabet</code> object which represents a protein alphabet.
</p>
<hr>
<a name="gt_alphabet_new_empty"></a>

<code>GtAlphabet*     gt_alphabet_new_empty(void)</code>
<p>
Return an empty <code>GtAlphabet</code> object.
</p>
<hr>
<a name="gt_alphabet_new_from_file"></a>

<code>GtAlphabet*     gt_alphabet_new_from_file(const char *filename, GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from an .al1 file specified by
   <code>filename</code> (i.e. no al1 suffix necessary).
</p>
<hr>
<a name="gt_alphabet_new_from_file_no_suffix"></a>

<code>GtAlphabet*     gt_alphabet_new_from_file_no_suffix(const char *filename,
                                                   GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from a file specified by
   <code>filename</code>.
</p>
<hr>
<a name="gt_alphabet_new_from_string"></a>

<code>GtAlphabet*     gt_alphabet_new_from_string(const char *alphadef,
                                           unsigned long len, GtError *err)</code>
<p>
Return a <code>GtAlphabet</code> object, as read from a string of length <code>len</code>
   specified by <code>alphadef</code>.
</p>
<hr>
<a name="gt_alphabet_new_from_sequence"></a>

<code>GtAlphabet*     gt_alphabet_new_from_sequence(const GtStrArray *filenametab,
                                             GtError *err)</code>
<p>
Returns a new <code>GtAlphabet</code> object by scanning the sequence files in
   <code>filenametab</code> to determine whether they are DNA or protein sequences,
   and the appropriate alphabet will be used (see <code>gt_alphabet_guess()</code>).
   Returns NULL on error, see <code>err</code> for details.
</p>
<hr>
<a name="gt_alphabet_guess"></a>

<code>GtAlphabet*     gt_alphabet_guess(const char *sequence, unsigned long seqlen)</code>
<p>
Try to guess which type the given <code>sequence</code> with <code>length</code> has (DNA or
   protein) and return an according <code>GtAlphabet*</code> object.
</p>
<hr>
<a name="gt_alphabet_clone"></a>

<code>GtAlphabet*     gt_alphabet_clone(const GtAlphabet *alphabet)</code>
<p>
Return a clone of <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_ref"></a>

<code>GtAlphabet*     gt_alphabet_ref(GtAlphabet *alphabet)</code>
<p>
Increase the reference count for <code>alphabet</code> and return it.
</p>
<hr>
<a name="gt_alphabet_add_mapping"></a>

<code>void            gt_alphabet_add_mapping(GtAlphabet *alphabet,
                                       const char *characters)</code>
<p>
Add the mapping of all given <code>characters</code> to the given <code>alphabet</code>. The first
   character is the result of subsequent <code>gt_alphabet_decode()</code> calls.
</p>
<hr>
<a name="gt_alphabet_add_wildcard"></a>

<code>void            gt_alphabet_add_wildcard(GtAlphabet *alphabet, char wildcard)</code>
<p>
Add <code>wildcard</code> to the <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_symbolmap"></a>

<code>const GtUchar*  gt_alphabet_symbolmap(const GtAlphabet *alphabet)</code>
<p>
Returns the array of symbols from <code>alphabet</code> such that the index of the
   character equals its encoding.
</p>
<hr>
<a name="gt_alphabet_num_of_chars"></a>

<code>unsigned int    gt_alphabet_num_of_chars(const GtAlphabet *alphabet)</code>
<p>
Returns number of characters in <code>alphabet</code> (excluding wildcards).
</p>
<hr>
<a name="gt_alphabet_size"></a>

<code>unsigned int    gt_alphabet_size(const GtAlphabet *alphabet)</code>
<p>
Returns number of characters in <code>alphabet</code> (including wildcards).
</p>
<hr>
<a name="gt_alphabet_characters"></a>

<code>const GtUchar*  gt_alphabet_characters(const GtAlphabet *alphabet)</code>
<p>
Returns an array of the characters in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_wildcard_show"></a>

<code>GtUchar         gt_alphabet_wildcard_show(const GtAlphabet *alphabet)</code>
<p>
Returns the character used in <code>alphabet</code> to represent wildcards in output.
</p>
<hr>
<a name="gt_alphabet_bits_per_symbol"></a>

<code>unsigned int    gt_alphabet_bits_per_symbol(const GtAlphabet *alphabet)</code>
<p>
Returns the required number of bits required to represent a symbol
   in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_output"></a>

<code>void            gt_alphabet_output(const GtAlphabet *alphabet, FILE *fpout)</code>
<p>
Writes a representation of <code>alphabet</code> to the file pointer <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_to_file"></a>

<code>int             gt_alphabet_to_file(const GtAlphabet *alphabet,
                                   const char *indexname,
                                   GtError *err)</code>
<p>
Writes a representation of <code>alphabet</code> to the .al1 output file as specified
   by <code>indexname</code> (i.e. without the .al1 suffix).
</p>
<hr>
<a name="gt_alphabet_to_str"></a>

<code>void             gt_alphabet_to_str(const GtAlphabet *alphabet, GtStr *dest)</code>
<p>
Writes a representation of <code>alphabet</code> to the <code>GtStr</code> as specified
   by <code>dest</code>.
</p>
<hr>
<a name="gt_alphabet_pretty_symbol"></a>

<code>GtUchar         gt_alphabet_pretty_symbol(const GtAlphabet *alphabet,
                                         unsigned int currentchar)</code>
<p>
Returns the printable character specified in <code>alphabet</code> for <code>currentchar</code>.
</p>
<hr>
<a name="gt_alphabet_echo_pretty_symbol"></a>

<code>void            gt_alphabet_echo_pretty_symbol(const GtAlphabet *alphabet,
                                              FILE *fpout,
                                              GtUchar currentchar)</code>
<p>
Prints the printable character specified in <code>alphabet</code> for <code>currentchar</code> on
   <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_is_protein"></a>

<code>bool            gt_alphabet_is_protein(const GtAlphabet *alphabet)</code>
<p>
The following method checks if the given <code>alphabet</code> is the protein
   alphabet with the aminoacids A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S,
   T, V, W, Y written in lower or upper case and returns <code>true</code>, if this is the
   case (<code>false</code> otherwise).
</p>
<hr>
<a name="gt_alphabet_is_dna"></a>

<code>bool            gt_alphabet_is_dna(const GtAlphabet *alphabet)</code>
<p>
The following method checks if the given alphabet is the DNA alphabet with
   the bases A, C, G, T written in lower or upper case and returns <code>true</code>, if
   this is the case (<code>false</code> otherwise).
</p>
<hr>
<a name="gt_alphabet_valid_input"></a>

<code>bool            gt_alphabet_valid_input(const GtAlphabet *alphabet, char c)</code>
<p>
Returns true if the character <code>c</code> is defined in <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_encode"></a>

<code>GtUchar         gt_alphabet_encode(const GtAlphabet *alphabet, char c)</code>
<p>
Encode character <code>c</code> with given <code>alphabet</code>.
   Ensure that <code>c</code> is encodable with the given <code>alphabet</code>!
</p>
<hr>
<a name="gt_alphabet_decode"></a>

<code>char            gt_alphabet_decode(const GtAlphabet *alphabet, GtUchar c)</code>
<p>
Decode character <code>c</code> with given <code>alphabet</code>.
</p>
<hr>
<a name="gt_alphabet_encode_seq"></a>

<code>void            gt_alphabet_encode_seq(const GtAlphabet *alphabet, GtUchar *out,
                                      const char *in, unsigned long length)</code>
<p>
Encode sequence <code>in</code> of given <code>length</code> with <code>alphabet</code> and store the result
   in <code>out</code>. <code>in</code> has to be encodable with the given <code>alphabet</code>!
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_fp"></a>

<code>void            gt_alphabet_decode_seq_to_fp(const GtAlphabet *alphabet,
                                            FILE *fpout,
                                            const GtUchar *src,
                                            unsigned long len)</code>
<p>
Suppose the string <code>src</code> of length <code>len</code> was transformed according to the
   <code>alphabet</code>. The following method shows each character in <code>src</code> as the
   printable character specified in the transformation. The output is written
   to the given file pointer <code>fpout</code>.
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_cstr"></a>

<code>void            gt_alphabet_decode_seq_to_cstr(const GtAlphabet *alphabet,
                                              char *dest,
                                              const GtUchar *src,
                                              unsigned long len)</code>
<p>
Analog to <code>gt_alphabet_decode_seq_to_fp()</code> but writing the output to
   <code>dest</code>.
</p>
<hr>
<a name="gt_alphabet_decode_seq_to_str"></a>

<code>GtStr*          gt_alphabet_decode_seq_to_str(const GtAlphabet *alphabet,
                                             const GtUchar *src,
                                             unsigned long len)</code>
<p>
Analog to <code>gt_alphabet_decode_seq_to_fp()</code> writing the output to
   a new <code>GtStr</code>.
</p>
<hr>
<a name="gt_alphabet_delete"></a>

<code>void            gt_alphabet_delete(GtAlphabet *alphabet)</code>
<p>
Decrease the reference count for <code>alphabet</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtArray"></a>
<h2>Class GtArray</h2>

<p> <code>GtArray</code> objects are generic arrays for elements of a certain size which
   grow on demand. </p>

<hr>
<a name="gt_array_new"></a>

<code>GtArray*       gt_array_new(size_t size_of_elem)</code>
<p>
Return a new <code>GtArray</code> object whose elements have the size <code>size_of_elem</code>.
</p>
<hr>
<a name="gt_array_ref"></a>

<code>GtArray*       gt_array_ref(GtArray *array)</code>
<p>
Increase the reference count for <code>array</code> and return it.
   If <code>array</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<a name="gt_array_clone"></a>

<code>GtArray*       gt_array_clone(const GtArray *array)</code>
<p>
Return a clone of <code>array</code>.
</p>
<hr>
<a name="gt_array_get"></a>

<code>void*          gt_array_get(const GtArray *array, unsigned long index)</code>
<p>
Return pointer to element number <code>index</code> of <code>array</code>. <code>index</code> has to be
   smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_get_first"></a>

<code>void*          gt_array_get_first(const GtArray *array)</code>
<p>
Return pointer to first element of <code>array</code>.
</p>
<hr>
<a name="gt_array_get_last"></a>

<code>void*          gt_array_get_last(const GtArray *array)</code>
<p>
Return pointer to last element of <code>array</code>.
</p>
<hr>
<a name="gt_array_pop"></a>

<code>void*          gt_array_pop(GtArray *array)</code>
<p>
Return pointer to last element of <code>array</code> and remove it from <code>array</code>.
</p>
<hr>
<a name="gt_array_get_space"></a>

<code>void*          gt_array_get_space(const GtArray *array)</code>
<p>
Return pointer to the internal space of <code>array</code> where the elements are
   stored.
</p>
<hr>
<a name="gt_array_add"></a>

<code>#define gt_array_add(array, elem)</code>
<p>
Add element <code>elem</code> to <code>array</code>. The size of <code>elem</code> must equal the given
   element size when the <code>array</code> was created and is determined automatically
   with the <code>sizeof</code> operator.
</p>
<hr>
<a name="gt_array_add_elem"></a>

<code>void           gt_array_add_elem(GtArray *array, void *elem,
                                size_t size_of_elem)</code>
<p>
Add element <code>elem</code> with size <code>size_of_elem</code> to <code>array</code>. <code>size_of_elem</code> must
   equal the given element size when the <code>array</code> was created. Usually, this
   method is not used directly and the macro <code>gt_array_add()</code> is used
   instead.
</p>
<hr>
<a name="gt_array_add_array"></a>

<code>void           gt_array_add_array(GtArray *dest, const GtArray *src)</code>
<p>
Add all elements of array <code>src</code> to the array <code>dest</code>. The element sizes of
   both arrays must be equal.
</p>
<hr>
<a name="gt_array_rem"></a>

<code>void           gt_array_rem(GtArray *array, unsigned long index)</code>
<p>
Remove element with number <code>index</code> from <code>array</code> in O(<code>gt_array_size(array)</code>)
   time. <code>index</code> has to be smaller than <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_rem_span"></a>

<code>void           gt_array_rem_span(GtArray *array, unsigned long frompos,
                                unsigned long topos)</code>
<p>
Remove elements starting with number <code>frompos</code> up to (and including) <code>topos</code>
   from <code>array</code> in O(<code>gt_array_size(array)</code>) time. <code>frompos</code> has to be smaller
   or equal than <code>topos</code> and both have to be smaller than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_reverse"></a>

<code>void           gt_array_reverse(GtArray *array)</code>
<p>
Reverse the order of the elements in <code>array</code>.
</p>
<hr>
<a name="gt_array_set_size"></a>

<code>void           gt_array_set_size(GtArray *array, unsigned long size)</code>
<p>
Set the size of <code>array</code> to <code>size</code>. <code>size</code> must be smaller or equal than
   <code>gt_array_size(array)</code>.
</p>
<hr>
<a name="gt_array_reset"></a>

<code>void           gt_array_reset(GtArray *array)</code>
<p>
Reset the <code>array</code>. That is, afterwards the array has size 0.
</p>
<hr>
<a name="gt_array_elem_size"></a>

<code>size_t         gt_array_elem_size(const GtArray *array)</code>
<p>
Return the size of the elements stored in <code>array</code>.
</p>
<hr>
<a name="gt_array_size"></a>

<code>unsigned long  gt_array_size(const GtArray *array)</code>
<p>
Return the number of elements in <code>array</code>. If <code>array</code> equals <code>NULL</code>, 0 is
   returned.
</p>
<hr>
<a name="gt_array_sort"></a>

<code>void           gt_array_sort(GtArray *array, GtCompare compar)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_stable"></a>

<code>void           gt_array_sort_stable(GtArray *array, GtCompare compar)</code>
<p>
Sort <code>array</code> in a stable way with the given compare function <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_with_data"></a>

<code>void           gt_array_sort_with_data(GtArray *array,
                                      GtCompareWithData compar,
                                      void *data)</code>
<p>
Sort <code>array</code> with the given compare function <code>compar</code>. Passes a pointer with
   userdata <code>data</code> to <code>compar</code>.
</p>
<hr>
<a name="gt_array_sort_stable_with_data"></a>

<code>void           gt_array_sort_stable_with_data(GtArray *array,
                                             GtCompareWithData compar,
                                             void *data)</code>
<p>
Sort <code>array</code> in a stable way with the given compare function <code>compar</code>. Passes
   a pointer with userdata <code>data</code> to <code>compar</code>.
</p>
<hr>
<a name="gt_array_cmp"></a>

<code>int            gt_array_cmp(const GtArray *array_a, const GtArray *array_b)</code>
<p>
Compare the content of <code>array_a</code> with the content of <code>array_b</code>.
   <code>array_a</code> and <code>array_b</code> must have the same <code>gt_array_size()</code> and
   <code>gt_array_elem_size()</code>.
</p>
<hr>
<a name="gt_array_delete"></a>

<code>void           gt_array_delete(GtArray *array)</code>
<p>
Decrease the reference count for <code>array</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GtBEDInStream"></a>
<h2>Class GtBEDInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtBEDInStream</code> allows to parse
   a BED file and return it as a stream of <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_bed_in_stream_new"></a>

<code>GtNodeStream*  gt_bed_in_stream_new(const char *filename)</code>
<p>
Return a <code>GtBEDInStream</code> object which subsequently reads the BED file with
   the given <code>filename</code>. If <code>filename</code> equals <code>NULL</code>, the BED data is read from
   <code>stdin</code>.
</p>
<hr>
<a name="gt_bed_in_stream_set_feature_type"></a>

<code>void           gt_bed_in_stream_set_feature_type(GtBEDInStream *bed_in_stream,
                                                const char *type)</code>
<p>
Create BED features parsed by <code>bed_in_stream</code> with given <code>type</code> (instead of
   the default "BED_feature").
</p>
<hr>
<a name="gt_bed_in_stream_set_thick_feature_type"></a>

<code>void           gt_bed_in_stream_set_thick_feature_type(GtBEDInStream
                                                      *bed_in_stream,
                                                      const char *type)</code>
<p>
Create thick BED features parsed by <code>bed_in_stream</code> with given <code>type</code>
   (instead of the default "BED_thick_feature").
</p>
<hr>
<a name="gt_bed_in_stream_set_block_type"></a>

<code>void           gt_bed_in_stream_set_block_type(GtBEDInStream *bed_in_stream,
                                              const char *type)</code>
<p>
Create BED blocks parsed by <code>bed_in_stream</code> with given <code>type</code> (instead of
   the default "BED_block").
</p>
<hr>
<a name="GtBittab"></a>
<h2>Class GtBittab</h2>

<p> Implements arbitrary-length bit arrays and various operations on them. </p>

<hr>
<a name="gt_bittab_new"></a>

<code>GtBittab*      gt_bittab_new(unsigned long num_of_bits)</code>
<p>
Return a new <code>GtBittab</code> of length <code>num_of_bits</code>, initialised to 0.
</p>
<hr>
<a name="gt_bittab_set_bit"></a>

<code>void           gt_bittab_set_bit(GtBittab *bittab, unsigned long i)</code>
<p>
Set bit <code>i</code> in <code>bittab</code> to 1.
</p>
<hr>
<a name="gt_bittab_unset_bit"></a>

<code>void           gt_bittab_unset_bit(GtBittab *bittab, unsigned long i)</code>
<p>
Set bit <code>i</code> in <code>bittab</code> to 0.
</p>
<hr>
<a name="gt_bittab_complement"></a>

<code>void           gt_bittab_complement(GtBittab *bittab_a,
                                   const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be the complement of <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_equal"></a>

<code>void           gt_bittab_equal(GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be equal to <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_and"></a>

<code>void           gt_bittab_and(GtBittab *bittab_a, const GtBittab *bittab_b,
                            const GtBittab *bittab_c)</code>
<p>
Set <code>bittab_a</code> to be the bitwise AND of <code>bittab_b</code> and <code>bittab_c</code>.
</p>
<hr>
<a name="gt_bittab_or"></a>

<code>void           gt_bittab_or(GtBittab *bittab_a, const GtBittab *bittab_b,
                           const GtBittab *bittab_c)</code>
<p>
Set <code>bittab_a</code> to be the bitwise OR of <code>bittab_b</code> and <code>bittab_c</code>.
</p>
<hr>
<a name="gt_bittab_nand"></a>

<code>void           gt_bittab_nand(GtBittab *bittab_a, const GtBittab *bittab_b,
                             const GtBittab *bittab_c)</code>
<p>
Set <code>bittab_a</code> to be <code>bittab_b</code> NAND <code>bittab_c</code>.
</p>
<hr>
<a name="gt_bittab_and_equal"></a>

<code>void           gt_bittab_and_equal(GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be the bitwise AND of <code>bittab_a</code> and <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_or_equal"></a>

<code>void           gt_bittab_or_equal(GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Set <code>bittab_a</code> to be the bitwise OR of <code>bittab_a</code> and <code>bittab_b</code>.
</p>
<hr>
<a name="gt_bittab_shift_left_equal"></a>

<code>void           gt_bittab_shift_left_equal(GtBittab *bittab)</code>
<p>
Shift <code>bittab</code> by one position to the left.
</p>
<hr>
<a name="gt_bittab_shift_right_equal"></a>

<code>void           gt_bittab_shift_right_equal(GtBittab *bittab)</code>
<p>
Shift <code>bittab</code> by one position to the right.
</p>
<hr>
<a name="gt_bittab_unset"></a>

<code>void           gt_bittab_unset(GtBittab *bittab)</code>
<p>
Set all bits in <code>bittab</code> to 0.
</p>
<hr>
<a name="gt_bittab_show"></a>

<code>void           gt_bittab_show(const GtBittab *bittab, FILE *fp)</code>
<p>
Output a representation of <code>bittab</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_bittab_get_all_bitnums"></a>

<code>void           gt_bittab_get_all_bitnums(const GtBittab *bittab, GtArray *array)</code>
<p>
Fill <code>array</code> with the indices of all set bits in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_bit_is_set"></a>

<code>bool           gt_bittab_bit_is_set(const GtBittab *bittab, unsigned long i)</code>
<p>
Return <code>true</code> if bit <code>i</code> is set in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_cmp"></a>

<code>bool           gt_bittab_cmp(const GtBittab *bittab_a, const GtBittab *bittab_b)</code>
<p>
Return <code>true</code> if <code>bittab_a</code> and <code>bittab_b</code> are identical.
</p>
<hr>
<a name="gt_bittab_get_first_bitnum"></a>

<code>unsigned long  gt_bittab_get_first_bitnum(const GtBittab *bittab)</code>
<p>
Return the index of the first set bit in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_get_last_bitnum"></a>

<code>unsigned long  gt_bittab_get_last_bitnum(const GtBittab *bittab)</code>
<p>
Return the index of the last set bit in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_get_next_bitnum"></a>

<code>unsigned long  gt_bittab_get_next_bitnum(const GtBittab *bittab,
                                        unsigned long i)</code>
<p>
Return the index of the next set bit in <code>bittab</code> with an index greater
   than <code>i</code>.
</p>
<hr>
<a name="gt_bittab_count_set_bits"></a>

<code>unsigned long  gt_bittab_count_set_bits(const GtBittab *bittab)</code>
<p>
Return the number of set bits in <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_size"></a>

<code>unsigned long  gt_bittab_size(GtBittab *bittab)</code>
<p>
Return the total number of bits of <code>bittab</code>.
</p>
<hr>
<a name="gt_bittab_delete"></a>

<code>void           gt_bittab_delete(GtBittab *bittab)</code>
<p>
Delete <code>bittab</code>.
</p>
<hr>
<a name="GtBlock"></a>
<h2>Class GtBlock</h2>

<p> The <code>GtBlock</code> class represents a portion of screen space which relates to
   a specific ``top-level'' feature (and maybe its collapsed child features).
   It is the smallest layoutable unit in AnnotationSketch and has a caption
   (which may be displayed above the block rendering). </p>

<hr>
<a name="gt_block_new"></a>

<code>GtBlock*               gt_block_new(void)</code>
<p>
Creates a new <code>GtBlock</code> object.
</p>
<hr>
<a name="gt_block_ref"></a>

<code>GtBlock*               gt_block_ref(GtBlock*)</code>
<p>
Increases the reference count.
</p>
<hr>
<a name="gt_block_new_from_node"></a>

<code>GtBlock*               gt_block_new_from_node(GtFeatureNode *node)</code>
<p>
Create a new GtBlock object, setting block parameters (such as strand,
   range) from a given <code>node</code> template.
</p>
<hr>
<a name="gt_block_get_range"></a>

<code>GtRange                gt_block_get_range(const GtBlock*)</code>
<p>
Returns the base range of the <code>GtBlock</code>'s top level element.
</p>
<hr>
<a name="gt_block_get_range_ptr"></a>

<code>GtRange*               gt_block_get_range_ptr(const GtBlock *block)</code>
<p>
Returns a pointer to the base range of the <code>GtBlock</code>'s top level element.
</p>
<hr>
<a name="gt_block_has_only_one_fullsize_element"></a>

<code>bool                   gt_block_has_only_one_fullsize_element(const GtBlock*)</code>
<p>
Checks whether a <code>GtBlock</code> is occupied completely by a single element.
</p>
<hr>
<a name="gt_block_merge"></a>

<code>void                   gt_block_merge(GtBlock*, GtBlock*)</code>
<p>
Merges the contents of two <code>GtBlock</code>s into the first one.
</p>
<hr>
<a name="gt_block_clone"></a>

<code>GtBlock*               gt_block_clone(GtBlock*)</code>
<p>
Returns an independent copy of a <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_set_caption_visibility"></a>

<code>void                   gt_block_set_caption_visibility(GtBlock*, bool)</code>
<p>
Set whether a block caption should be displayed or not.
</p>
<hr>
<a name="gt_block_caption_is_visible"></a>

<code>bool                   gt_block_caption_is_visible(const GtBlock*)</code>
<p>
Returns whether a block caption should be displayed or not.
</p>
<hr>
<a name="gt_block_set_caption"></a>

<code>void                   gt_block_set_caption(GtBlock*, GtStr *caption)</code>
<p>
Sets the <code>GtBlock</code>'s caption to <code>caption</code>.
</p>
<hr>
<a name="gt_block_get_caption"></a>

<code>GtStr*                 gt_block_get_caption(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s caption.
</p>
<hr>
<a name="gt_block_set_strand"></a>

<code>void                   gt_block_set_strand(GtBlock*, GtStrand strand)</code>
<p>
Sets the <code>GtBlock</code>'s strand to <code>strand</code>.
</p>
<hr>
<a name="gt_block_get_strand"></a>

<code>GtStrand               gt_block_get_strand(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s strand.
</p>
<hr>
<a name="gt_block_get_top_level_feature"></a>

<code>GtFeatureNode*         gt_block_get_top_level_feature(const GtBlock*)</code>
<p>
Returns the <code>GtBlock</code>'s top level feature as a <code>GtFeatureNode</code> object.
</p>
<hr>
<a name="gt_block_get_size"></a>

<code>unsigned long          gt_block_get_size(const GtBlock*)</code>
<p>
Returns the number of elements in the <code>GtBlock</code>.
</p>
<hr>
<a name="gt_block_delete"></a>

<code>void                   gt_block_delete(GtBlock*)</code>
<p>
Deletes a <code>GtBlock</code>.
</p>
<hr>
<a name="GtCDSStream"></a>
<h2>Class GtCDSStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtCDSStream</code> determines the
   coding sequence (CDS) for sequences determined by feature nodes of type
   <em>exon</em> and adds them as feature nodes of type <em>CDS</em>. </p>

<hr>
<a name="gt_cds_stream_new"></a>

<code>GtNodeStream*  gt_cds_stream_new(GtNodeStream *in_stream,
                                GtRegionMapping *region_mapping,
                                unsigned int minorflen, const char *source,
                                bool start_codon, bool final_stop_codon,
                                bool generic_star_codons)</code>
<p>
Create a <code>GtCDSStream*</code> which determines the coding sequence (CDS) for
   sequences determined by feature nodes of type <em>exon</em> it retrieves from
   <code>in_stream</code>, adds them as feature nodes of type <em>CDS</em> and returns all
   nodes. <code>region_mapping</code> is used to map the sequence IDs of the feature nodes
   to the regions of the actual sequences. <code>minorflen</code> is the minimum length an
   ORF must have in order to be added. The CDS features are created with the
   given <code>source</code>. If <code>start_codon</code> equals <code>true</code> an ORF must begin with a start
   codon, otherwise it can start at any position. If <code>final_stop_codon</code> equals
   <code>true</code> the final ORF must end with a stop codon. If <code>generic_start_codons</code>
   equals <code>true</code>, the start codons of the standard translation scheme are used
   as start codons (otherwise the amino acid 'M' is regarded as a start codon).
</p>
<hr>
<a name="GtCSAStream"></a>
<h2>Class GtCSAStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtCSAStream</code> takes spliced
   alignments and transforms them into consensus spliced alignments. </p>

<hr>
<a name="gt_csa_stream_new"></a>

<code>GtNodeStream*  gt_csa_stream_new(GtNodeStream *in_stream,
                                unsigned long join_length)</code>
<p>
Create a <code>GtCSAStream*</code> which takes spliced alignments from its <code>in_stream</code>
   (which are at most <code>join_length</code> many bases apart), transforms them into
   consensus spliced alignments, and returns them.
</p>
<hr>
<a name="GtCanvas"></a>
<h2>Class GtCanvas</h2>

<p> The <code>GtCanvas</code> class is an abstraction of a stateful drawing surface.
   Constructors must be implemented in subclasses as different arguments are
   required for drawing to specific graphics back-ends. </p>

<hr>
<a name="gt_canvas_get_height"></a>

<code>unsigned long  gt_canvas_get_height(GtCanvas *canvas)</code>
<p>
Returns the height of the given <code>canvas</code>.
</p>
<hr>
<a name="gt_canvas_delete"></a>

<code>void           gt_canvas_delete(GtCanvas *canvas)</code>
<p>
Delete the given <code>canvas</code>.
</p>
<hr>
<a name="GtCanvasCairoContext"></a>
<h2>Class GtCanvasCairoContext</h2>

<p> Implements the <code>GtCanvas</code> interface using a Cairo context (<code>cairo_t</code>)
   as input. This Canvas uses the <code>GtGraphicsCairo</code> class.</p><p>   Drawing to a <code>cairo_t</code> allows the use of the  <em>AnnotationSketch</em> engine
   in any Cairo-based graphical application. </p>

<hr>
<a name="gt_canvas_cairo_context_new"></a>

<code>GtCanvas*  gt_canvas_cairo_context_new(GtStyle *style, cairo_t *context,
                                      double offsetpos,
                                      unsigned long width,
                                      unsigned long height,
                                      GtImageInfo *image_info,
                                      GtError *err)</code>
<p>
Create a new <code>GtCanvas</code> object tied to the cairo_t <code>context</code>, <code>width</code> and
   <code>height</code> using the given <code>style</code>. The optional <code>image_info</code> is
   filled when the created Canvas object is used to render a <code>GtDiagram</code> object.
   <code>offsetpos</code> determines where to start drawing on the surface.
</p>
<hr>
<a name="GtCanvasCairoFile"></a>
<h2>Class GtCanvasCairoFile</h2>

<p> Implements the <code>GtCanvas</code> interface.
   This Canvas uses the <code>GtGraphicsCairo</code> class.  </p>

<hr>
<a name="gt_canvas_cairo_file_new"></a>

<code>GtCanvas*  gt_canvas_cairo_file_new(GtStyle *style,
                                   GtGraphicsOutType output_type,
                                   unsigned long width,
                                   unsigned long height,
                                   GtImageInfo *image_info,
                                   GtError *err)</code>
<p>
Create a new <code>GtCanvasCairoFile</code> object with given <code>output_type</code> and
   <code>width</code> using the configuration given in <code>style</code>. The optional <code>image_info</code>
   is filled when the created object is used to render a <code>GtDiagram</code> object.
   Possible <code>GtGraphicsOutType</code> values are <code>GRAPHICS_PNG</code>, <code>GRAPHICS_PS</code>,
   <code>GRAPHICS_PDF</code> and <code>GRAPHICS_SVG</code>. Dependent on the local Cairo installation,
   not all of them may be available.
</p>
<hr>
<a name="gt_canvas_cairo_file_to_file"></a>

<code>int      gt_canvas_cairo_file_to_file(GtCanvasCairoFile *canvas,
                                     const char *filename, GtError *err)</code>
<p>
Write rendered <code>canvas</code> to the file with name <code>filename</code>. If this
   method returns a value other than 0, check <code>err</code> for an error message.
</p>
<hr>
<a name="gt_canvas_cairo_file_to_stream"></a>

<code>int      gt_canvas_cairo_file_to_stream(GtCanvasCairoFile *canvas,
                                       GtStr *stream)</code>
<p>
Append rendered <code>canvas</code> image data to given <code>stream</code>.
</p>
<hr>
<a name="GtCodonIterator"></a>
<h2>Class GtCodonIterator</h2>

<p> the ``codon iterator'' interface </p>

<hr>
<a name="gt_codon_iterator_current_position"></a>

<code>unsigned long           gt_codon_iterator_current_position(GtCodonIterator *ci)</code>
<p>
Return the current reading offset of <code>ci</code>, starting from the position
   in the sequence given at iterator instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_length"></a>

<code>unsigned long           gt_codon_iterator_length(GtCodonIterator *ci)</code>
<p>
Return the length of the substring to scan, given at instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_rewind"></a>

<code>void                    gt_codon_iterator_rewind(GtCodonIterator *ci)</code>
<p>
Rewind the iterator to point again to the position in the sequence given
   at iterator instantiation time.
</p>
<hr>
<a name="gt_codon_iterator_next"></a>

<code>GtCodonIteratorStatus   gt_codon_iterator_next(GtCodonIterator *ci,
                                              char *n1, char *n2, char *n3,
                                              unsigned int *frame,
                                              GtError *err)</code>
<p>
Sets the values of <code>n1</code>, <code>n2</code> and <code>n3</code> to the codon beginning at the current
   reading position of <code>ci</code> and then advances the reading position by one. The
   current reading frame shift (0, 1 or 2) is for the current codon is written
   to the position pointed to by <code>frame</code>.
   This function returns one of three status codes:
   GT_CODON_ITERATOR_OK    : a codon was read successfully,
   GT_CODON_ITERATOR_END   : no codon was read because the end of the scan
                             region has been reached,
   GT_CODON_ITERATOR_ERROR : no codon was read because an error occurred during
                             sequence access. See <code>err</code> for details.
</p>
<hr>
<a name="gt_codon_iterator_delete"></a>

<code>void                    gt_codon_iterator_delete(GtCodonIterator *ci)</code>
<p>
Delete <code>ci</code>.
</p>
<hr>
<a name="GtColor"></a>
<h2>Class GtColor</h2>

<p> The <code>GtColor</code> class holds a RGB color definition. </p>

<hr>
<a name="gt_color_new"></a>

<code>GtColor*  gt_color_new(double red, double green, double blue, double alpha)</code>
<p>
Create a new <code>GtColor</code> object with the color given by the <code>red</code>, <code>green</code>,
   and <code>blue</code> arguments. The value for each color channel must be between 0
   and 1.
</p>
<hr>
<a name="gt_color_set"></a>

<code>void       gt_color_set(GtColor *color, double red, double green, double blue,
                       double alpha)</code>
<p>
Change the color of the <code>color</code> object to the color given by the <code>red</code>,
   <code>green</code>, and <code>blue</code> arguments. The value for each color channel must be
   between 0 and 1.
</p>
<hr>
<a name="gt_color_equals"></a>

<code>bool       gt_color_equals(const GtColor *c1, const GtColor *c2)</code>
<p>
Returns <code>true</code> if the colors <code>c1</code> and <code>c2</code> are equal.
</p>
<hr>
<a name="gt_color_delete"></a>

<code>void       gt_color_delete(GtColor *color)</code>
<p>
Delete the <code>color</code> object.
</p>
<hr>
<a name="GtCommentNode"></a>
<h2>Class GtCommentNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Comment nodes correspond to comment
   lines in GFF3 files (i.e., lines which start with a single ``<code>#</code>''). </p>

<hr>
<a name="gt_comment_node_new"></a>

<code>GtGenomeNode*             gt_comment_node_new(const char *comment)</code>
<p>
Return a new <code>GtCommentNode</code> object representing a <code>comment</code>. Please note
   that the single leading ``<code>#</code>'' which denotes comment lines in GFF3 files
   should not be part of <code>comment</code>.
</p>
<hr>
<a name="gt_comment_node_get_comment"></a>

<code>const char*               gt_comment_node_get_comment(const GtCommentNode
                                                     *comment_node)</code>
<p>
Return the comment stored in <code>comment_node</code>.
</p>
<hr>
<a name="GtCstrTable"></a>
<h2>Class GtCstrTable</h2>

<p> Implements a table of C strings. </p>

<hr>
<a name="gt_cstr_table_new"></a>

<code>GtCstrTable*   gt_cstr_table_new(void)</code>
<p>
Return a new <code>GtCstrTable</code> object.
</p>
<hr>
<a name="gt_cstr_table_add"></a>

<code>void           gt_cstr_table_add(GtCstrTable *table, const char *cstr)</code>
<p>
Add <code>cstr</code> to <code>table</code>. <code>table</code> must not already contain <code>cstr</code>!
</p>
<hr>
<a name="gt_cstr_table_get"></a>

<code>const char*    gt_cstr_table_get(const GtCstrTable *table, const char *cstr)</code>
<p>
If a C string equal to <code>cstr</code> is contained in <code>table</code>, it is returned.
   Otherwise <code>NULL</code> is returned.
</p>
<hr>
<a name="gt_cstr_table_get_all"></a>

<code>GtStrArray*    gt_cstr_table_get_all(const GtCstrTable *table)</code>
<p>
Return a <code>GtStrArray*</code> which contains all <code>cstr</code>s added to <code>table</code> in
   alphabetical order. The caller is responsible to free it!
</p>
<hr>
<a name="gt_cstr_table_delete"></a>

<code>void           gt_cstr_table_delete(GtCstrTable *table)</code>
<p>
Delete C string <code>table</code>.
</p>
<hr>
<a name="GtCustomTrack"></a>
<h2>Class GtCustomTrack</h2>

<p> The <code>GtCustomTrack</code> interface allows the <code>GtCanvas</code> to call user-defined
   drawing functions on a <code>GtGraphics</code> object. Please refer to the specific
   implementations' documentation for more information on a particular
   custom track. </p>

<hr>
<a name="gt_custom_track_ref"></a>

<code>GtCustomTrack*  gt_custom_track_ref(GtCustomTrack *ctrack)</code>
<p>
Increase the reference count for <code>ctrack</code>.
</p>
<hr>
<a name="gt_custom_track_delete"></a>

<code>void            gt_custom_track_delete(GtCustomTrack *ctrack)</code>
<p>
Delete the given <code>ctrack</code>.
</p>
<hr>
<a name="GtCustomTrackGcContent"></a>
<h2>Class GtCustomTrackGcContent</h2>

<p> Implements the <code>GtCustomTrack</code> interface. This custom track draws a plot of
   the GC content of a given sequence in the displayed range. As a window
   size for GC content calculation, <code>windowsize</code> is used. </p>

<hr>
<a name="gt_custom_track_gc_content_new"></a>

<code>GtCustomTrack*  gt_custom_track_gc_content_new(const char *seq,
                                              unsigned long seqlen,
                                              unsigned long windowsize,
                                              unsigned long height,
                                              double avg,
                                              bool show_scale)</code>
<p>
Creates a new <code>GtCustomTrackGcContent</code> for sequence <code>seq</code> with length
   <code>seqlen</code> of height <code>height</code> with windowsize <code>windowsize</code>.
   A horizontal line is drawn for the percentage value <code>avg</code>,
   with <code>avg</code> between 0 and 1. If <code>show_scale</code> is set to true, then a vertical
   scale rule is drawn at the left end of the curve.
</p>
<hr>
<a name="GtCustomTrackScriptWrapper"></a>
<h2>Class GtCustomTrackScriptWrapper</h2>

<p> Implements the <code>GtCustomTrack</code> interface. This custom track is
   only used to store pointers to external callbacks, e.g. written in a
   scripting language. This class does not store any state, relying on the
   developer of the external custom track class to do so.  </p>

<hr>
<a name="gt_custom_track_script_wrapper_new"></a>

<code>GtCustomTrack*  gt_custom_track_script_wrapper_new(GtCtScriptRenderFunc
                                                             render_func,
                                                  GtCtScriptGetHeightFunc
                                                             get_height_func,
                                                  GtCtScriptGetTitleFunc
                                                             get_title_func,
                                                  GtCtScriptFreeFunc
                                                             free_func)</code>
<p>
Creates a new <code>GtCustomTrackScriptWrapper</code> object.
</p>
<hr>
<a name="GtDiagram"></a>
<h2>Class GtDiagram</h2>

<p> The <code>GtDiagram</code> class acts as a representation of a sequence annotation
   diagram independent of any output format. Besides annotation features as
   annotation graphs, it can contain one or more custom tracks. A individual
   graphical representation of the <code>GtDiagram</code> contents is created by creating a
   <code>GtLayout</code> object using the <code>GtDiagram</code> and then calling
   <code>gt_layout_sketch()</code> with an appropriate <code>GtCanvas</code> object. </p>

<hr>
<a name="gt_diagram_new"></a>

<code>GtDiagram*  gt_diagram_new(GtFeatureIndex *feature_index, const char *seqid,
                          const GtRange *range, GtStyle *style, GtError*)</code>
<p>
Create a new <code>GtDiagram</code> object representing the feature nodes in
   <code>feature_index</code> in region <code>seqid</code> overlapping with <code>range</code>. The <code>GtStyle</code>
   object <code>style</code> will be used to determine collapsing options during the
   layout process.
</p>
<hr>
<a name="gt_diagram_new_from_array"></a>

<code>GtDiagram*  gt_diagram_new_from_array(GtArray *features, const GtRange *range,
                                     GtStyle *style)</code>
<p>
Create a new <code>GtDiagram</code> object representing the feature nodes in
   <code>features</code>. The features must overlap with <code>range</code>. The <code>GtStyle</code>
   object <code>style</code> will be used to determine collapsing options during the
   layout process.
</p>
<hr>
<a name="gt_diagram_get_range"></a>

<code>GtRange     gt_diagram_get_range(const GtDiagram *diagram)</code>
<p>
Returns the sequence position range represented by the <code>diagram</code>.
</p>
<hr>
<a name="gt_diagram_set_track_selector_func"></a>

<code>void        gt_diagram_set_track_selector_func(GtDiagram*, GtTrackSelectorFunc,
                                              void*)</code>
<p>
Assigns a GtTrackSelectorFunc to use to assign blocks to tracks.
   If none is set, or set to NULL, then track types are used as track keys
   (default behavior).
</p>
<hr>
<a name="gt_diagram_reset_track_selector_func"></a>

<code>void        gt_diagram_reset_track_selector_func(GtDiagram *diagram)</code>
<p>
Resets the track selection behavior of this <code>GtDiagram</code> back to the
   default.
</p>
<hr>
<a name="gt_diagram_add_custom_track"></a>

<code>void        gt_diagram_add_custom_track(GtDiagram*, GtCustomTrack*)</code>
<p>
Registers a new custom track in the diagram.
</p>
<hr>
<a name="gt_diagram_delete"></a>

<code>void        gt_diagram_delete(GtDiagram*)</code>
<p>
Delete the <code>diagram</code> and all its components.
</p>
<hr>
<a name="GtDlist"></a>
<h2>Class GtDlist</h2>

<p> A double-linked list which is sorted according to a <code>GtCompare</code> compare
   function (<code>qsort(3)</code>-like, only if one was supplied to the constructor). </p>

<hr>
<a name="gt_dlist_new"></a>

<code>GtDlist*       gt_dlist_new(GtCompare compar)</code>
<p>
Return a new <code>GtDlist</code> object sorted according to <code>compar</code> function. If
   <code>compar</code> equals <code>NULL</code>, no sorting is enforced.
</p>
<hr>
<a name="gt_dlist_first"></a>

<code>GtDlistelem*   gt_dlist_first(const GtDlist *dlist)</code>
<p>
Return the first <code>GtDlistelem</code> object in <code>dlist</code>.
</p>
<hr>
<a name="gt_dlist_last"></a>

<code>GtDlistelem*   gt_dlist_last(const GtDlist *dlist)</code>
<p>
Return the last <code>GtDlistelem</code> object in <code>dlist</code>.
</p>
<hr>
<a name="gt_dlist_find"></a>

<code>GtDlistelem*   gt_dlist_find(const GtDlist *dlist, void *data)</code>
<p>
Return the first <code>GtDlistelem</code> object in <code>dlist</code> which contains data
   identical to <code>data</code>. Takes O(n) time.
</p>
<hr>
<a name="gt_dlist_size"></a>

<code>unsigned long  gt_dlist_size(const GtDlist *dlist)</code>
<p>
Return the number of <code>GtDlistelem</code> objects in <code>dlist</code>.
</p>
<hr>
<a name="gt_dlist_add"></a>

<code>void           gt_dlist_add(GtDlist *dlist, void *data)</code>
<p>
Add a new <code>GtDlistelem</code> object containing <code>data</code> to <code>dlist</code>.
   Usually O(n), but O(1) if data is added in sorted order.
</p>
<hr>
<a name="gt_dlist_remove"></a>

<code>void           gt_dlist_remove(GtDlist *dlist, GtDlistelem *dlistelem)</code>
<p>
Remove <code>dlistelem</code> from <code>dlist</code> and free it.
</p>
<hr>
<a name="gt_dlist_example"></a>

<code>int            gt_dlist_example(GtError *err)</code>
<p>
Example for usage of the <code>GtDlist</code> class.
</p>
<hr>
<a name="gt_dlist_delete"></a>

<code>void           gt_dlist_delete(GtDlist *dlist)</code>
<p>
Delete <code>dlist</code>.
</p>
<hr>
<a name="GtDlistelem"></a>
<h2>Class GtDlistelem</h2>
<a name="gt_dlistelem_next"></a>

<code>GtDlistelem*   gt_dlistelem_next(const GtDlistelem *dlistelem)</code>
<p>
Return the successor of <code>dlistelem</code>, or <code>NULL</code> if the element is the last
   one in the <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlistelem_previous"></a>

<code>GtDlistelem*   gt_dlistelem_previous(const GtDlistelem *dlistelem)</code>
<p>
Return the predecessor of <code>dlistelem</code>, or <code>NULL</code> if the element is the
   first one in the <code>GtDlist</code>.
</p>
<hr>
<a name="gt_dlistelem_get_data"></a>

<code>void*          gt_dlistelem_get_data(const GtDlistelem *dlistelem)</code>
<p>
Return the data pointer attached to <code>dlistelem</code>.
</p>
<hr>
<a name="GtEOFNode"></a>
<h2>Class GtEOFNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. EOF nodes mark the barrier between
   separate input files in an GFF3 stream. </p>

<hr>
<a name="gt_eof_node_new"></a>

<code>GtGenomeNode*             gt_eof_node_new(void)</code>
<p>
Create a new <code>GtEOFNode*</code> representing an EOF marker.
</p>
<hr>
<a name="GtEncseq"></a>
<h2>Class GtEncseq</h2>

<p> The <code>GtEncseq</code> class represents a concatenated collection of sequences from
   one or more input files in a bit-compressed encoding. It is stored in a
   number of <code>mmap()</code>able files, depending on which features it is meant to
   support.
   The main compressed sequence information is stored in an <em>encoded sequence</em>
   table, with the file suffix '.esq'. This table is the minimum requirement
   for the <code>GtEncseq</code> structure and must always be present. In addition, if
   support for multiple sequences is desired, a <em>sequence separator position</em>
   table with the '.ssp' suffix is required. If support for sequence
   descriptions is required, two additional tables are needed: a <em>description</em>
   table with the suffix '.des' and a <em>description separator</em> table with the
   file suffix '.sds'. Creation and requirement of these tables can be switched
   on and off using API functions as outlined below.
   The <code>GtEncseq</code> represents the stored sequences as one concatenated string.
   It allows access to the sequences by providing start positions and lengths
   for each sequence, making it possible to extract encoded substrings into a
   given buffer, as well as accessing single characters both in a random and a
   sequential fashion. </p>

<hr>
<a name="gt_encseq_total_length"></a>

<code>unsigned long      gt_encseq_total_length(const GtEncseq *encseq)</code>
<p>
Returns the total number of characters in all sequences of <code>encseq</code>,
   including separators and wildcards.
</p>
<hr>
<a name="gt_encseq_num_of_sequences"></a>

<code>unsigned long      gt_encseq_num_of_sequences(const GtEncseq *encseq)</code>
<p>
Returns the total number of sequences contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_get_encoded_char"></a>

<code>GtUchar            gt_encseq_get_encoded_char(const GtEncseq *encseq,
                                             unsigned long pos,
                                             GtReadmode readmode)</code>
<p>
Returns the encoded representation of the character at position <code>pos</code> of
   <code>encseq</code> read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_get_decoded_char"></a>

<code>char               gt_encseq_get_decoded_char(const GtEncseq *encseq,
                                             unsigned long pos,
                                             GtReadmode readmode)</code>
<p>
Returns the decoded representation of the character at position <code>pos</code> of
   <code>encseq</code> read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_position_is_separator"></a>

<code>bool               gt_encseq_position_is_separator(const GtEncseq *encseq,
                                                  unsigned long pos,
                                                  GtReadmode readmode)</code>
<p>
Returns true iff <code>pos</code> is a separator position of <code>encseq</code>
   read in the direction as indicated by <code>readmode</code>.
</p>
<hr>
<a name="gt_encseq_ref"></a>

<code>GtEncseq*          gt_encseq_ref(GtEncseq *encseq)</code>
<p>
Increases the reference count of <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_create_reader_with_readmode"></a>

<code>GtEncseqReader*    gt_encseq_create_reader_with_readmode(const GtEncseq *encseq,
                                                        GtReadmode readmode,
                                                        unsigned long startpos)</code>
<p>
Returns a new <code>GtEncseqReader</code> for <code>encseq</code>, starting from position
   <code>startpos</code>. Also supports reading the sequence from the reverse and
   delivering (reverse) complement characters on DNA alphabets using the
   <code>readmode</code> option. Please make sure that the <code>GT_READMODE_COMPL</code> and
   <code>GT_READMODE_REVCOMPL</code> readmodes are only used on DNA alphabets.
</p>
<hr>
<a name="gt_encseq_extract_encoded"></a>

<code>void               gt_encseq_extract_encoded(const GtEncseq *encseq,
                                              GtUchar *buffer,
                                              unsigned long frompos,
                                              unsigned long topos)</code>
<p>
Returns the encoded representation of the substring from position <code>frompos</code>
   to position <code>topos</code> of <code>encseq</code>. The result is written to the location
   pointed to by <code>buffer</code>, which must be large enough to hold the result.
</p>
<hr>
<a name="gt_encseq_extract_decoded"></a>

<code>void               gt_encseq_extract_decoded(const GtEncseq *encseq,
                                            char *buffer,
                                            unsigned long frompos,
                                            unsigned long topos)</code>
<p>
Returns the decoded version of the substring from position <code>frompos</code>
   to position <code>topos</code> of <code>encseq</code>. The result is written to the location
   pointed to by <code>buffer</code>, which must be large enough to hold the result.
</p>
<hr>
<a name="gt_encseq_seqlength"></a>

<code>unsigned long      gt_encseq_seqlength(const GtEncseq *encseq,
                                      unsigned long seqnum)</code>
<p>
Returns the length of the <code>seqnum</code>-th sequence in the <code>encseq</code>.
   Requires multiple sequence support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_min_seq_length"></a>

<code>unsigned long      gt_encseq_min_seq_length(const GtEncseq *encseq)</code>
<p>
Returns the length of the shortest sequence in the <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_max_seq_length"></a>

<code>unsigned long      gt_encseq_max_seq_length(const GtEncseq *encseq)</code>
<p>
Returns the length of the longest sequence in the <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_has_multiseq_support"></a>

<code>bool               gt_encseq_has_multiseq_support(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> has multiple sequence support.
</p>
<hr>
<a name="gt_encseq_has_description_support"></a>

<code>bool               gt_encseq_has_description_support(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> has description support.
</p>
<hr>
<a name="gt_encseq_seqstartpos"></a>

<code>unsigned long      gt_encseq_seqstartpos(const GtEncseq *encseq,
                                        unsigned long seqnum)</code>
<p>
Returns the start position of the <code>seqnum</code>-th sequence in the <code>encseq</code>.
   Requires multiple sequence support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_seqnum"></a>

<code>unsigned long      gt_encseq_seqnum(const GtEncseq *encseq,
                                   unsigned long position)</code>
<p>
Returns the sequence number from the given <code>position</code> for a given
   GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_description"></a>

<code>const char*        gt_encseq_description(const GtEncseq *encseq,
                                        unsigned long *desclen,
                                        unsigned long seqnum)</code>
<p>
Returns a pointer to the description of the <code>seqnum</code>-th sequence in the
   <code>encseq</code>. The length of the returned string is written to the
   location pointed at by <code>desclen</code>.
   The returned description pointer is not <code>\0</code>-terminated!
   Requires description support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenames"></a>

<code>const GtStrArray*  gt_encseq_filenames(const GtEncseq *encseq)</code>
<p>
Returns a <code>GtStrArray</code> of the names of the original sequence files
   contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_num_of_files"></a>

<code>unsigned long      gt_encseq_num_of_files(const GtEncseq *encseq)</code>
<p>
Returns the number of files contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_effective_filelength"></a>

<code>uint64_t           gt_encseq_effective_filelength(const GtEncseq *encseq,
                                                 unsigned long filenum)</code>
<p>
Returns the effective length (sum of sequence lengths and separators
   between them) of the <code>filenum</code>-th file contained in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filestartpos"></a>

<code>unsigned long      gt_encseq_filestartpos(const GtEncseq *encseq,
                                         unsigned long filenum)</code>
<p>
Returns the start position of the sequences of the  <code>filenum</code>-th file in the
   <code>encseq</code>. Requires multiple file support enabled in <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_filenum"></a>

<code>unsigned long      gt_encseq_filenum(const GtEncseq *encseq,
                                    unsigned long position)</code>
<p>
Returns the file number from the given <code>position</code> for a given
   GtEncseq <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_alphabet"></a>

<code>GtAlphabet*        gt_encseq_alphabet(const GtEncseq *encseq)</code>
<p>
Returns the <code>GtAlphabet</code> associated with <code>encseq</code>.
</p>
<hr>
<a name="gt_encseq_mirror"></a>

<code>int               gt_encseq_mirror(GtEncseq *encseq, GtError *err)</code>
<p>
Extends <code>encseq</code>  by virtual reverse complement sequences.
   Returns 0 if mirroring has been successfully enabled, otherwise -1.
   <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_encseq_unmirror"></a>

<code>void               gt_encseq_unmirror(GtEncseq *encseq)</code>
<p>
Removes virtual reverse complement sequences added by
   <code>gt_encseq_mirror()</code>.
</p>
<hr>
<a name="gt_encseq_is_mirrored"></a>

<code>bool               gt_encseq_is_mirrored(const GtEncseq *encseq)</code>
<p>
Returns <code>true</code> if <code>encseq</code> contains virtual reverse complement sequences as
   added by <code>gt_encseq_mirror()</code>.
</p>
<hr>
<a name="gt_encseq_version"></a>

<code>unsigned long      gt_encseq_version(const GtEncseq *encseq)</code>
<p>
Returns the version number of the file representation of <code>encseq</code> if it
   exists, or 0 if it was not mapped from a file.
</p>
<hr>
<a name="gt_encseq_is_64_bit"></a>

<code>bool               gt_encseq_is_64_bit(const GtEncseq *encseq)</code>
<p>
Returns TRUE if <code>encseq</code> was created on a 64-bit system.
</p>
<hr>
<a name="gt_encseq_delete"></a>

<code>void               gt_encseq_delete(GtEncseq *encseq)</code>
<p>
Deletes <code>encseq</code> and frees all associated space.
</p>
<hr>
<a name="GtEncseqBuilder"></a>
<h2>Class GtEncseqBuilder</h2>

<p> The <code>GtEncseqBuilder</code> class creates <code>GtEncseq</code> objects by constructing
   uncompressed, encoded string copies in memory. </p>

<hr>
<a name="gt_encseq_builder_new"></a>

<code>GtEncseqBuilder*  gt_encseq_builder_new(GtAlphabet *alpha)</code>
<p>
Creates a new <code>GtEncseqBuilder</code> using the alphabet <code>alpha</code> as a basis for
   on-the-fly encoding of sequences in memory.
</p>
<hr>
<a name="gt_encseq_builder_enable_description_support"></a>

<code>void              gt_encseq_builder_enable_description_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   to be built by <code>eb</code>. Requires additional memory to hold the descriptions and
   a position index.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_builder_disable_description_support"></a>

<code>void              gt_encseq_builder_disable_description_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   to be built by <code>eb</code>. Disabling this support will result in an error when
   trying to call the method <code>gt_encseq_description()</code> on the
   <code>GtEncseq</code> object created by <code>eb</code>.
</p>
<hr>
<a name="gt_encseq_builder_enable_multiseq_support"></a>

<code>void              gt_encseq_builder_enable_multiseq_support(GtEncseqBuilder *eb)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence to be built by <code>eb</code>. Requires additional memory for an index of
   starting positions. Activated by default.
</p>
<hr>
<a name="gt_encseq_builder_disable_multiseq_support"></a>

<code>void              gt_encseq_builder_disable_multiseq_support(
                                                           GtEncseqBuilder *eb)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence to be built by <code>eb</code>. Disabling this support will result in an
   error when trying to call the method <code>gt_encseq_seqlength()</code> or
   <code>gt_encseq_seqstartpos()</code> on the <code>GtEncseq</code> object created by <code>eb</code>.
</p>
<hr>
<a name="gt_encseq_builder_create_esq_tab"></a>

<code>void              gt_encseq_builder_create_esq_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .esq table containing the encoded sequence itself.
   Naturally, enabled by default.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_esq_tab"></a>

<code>void              gt_encseq_builder_do_not_create_esq_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .esq table.
</p>
<hr>
<a name="gt_encseq_builder_create_des_tab"></a>

<code>void              gt_encseq_builder_create_des_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .des table containing sequence descriptions.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_des_tab"></a>

<code>void              gt_encseq_builder_do_not_create_des_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .des table.
</p>
<hr>
<a name="gt_encseq_builder_create_ssp_tab"></a>

<code>void              gt_encseq_builder_create_ssp_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .ssp table containing indexes for multiple sequences.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_ssp_tab"></a>

<code>void              gt_encseq_builder_do_not_create_ssp_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .ssp table.
</p>
<hr>
<a name="gt_encseq_builder_create_sds_tab"></a>

<code>void              gt_encseq_builder_create_sds_tab(GtEncseqBuilder *eb)</code>
<p>
Enables creation of the .sds table containing indexes for sequence
   descriptions.
</p>
<hr>
<a name="gt_encseq_builder_do_not_create_sds_tab"></a>

<code>void              gt_encseq_builder_do_not_create_sds_tab(GtEncseqBuilder *eb)</code>
<p>
Disables creation of the .sds table.
</p>
<hr>
<a name="gt_encseq_builder_add_cstr"></a>

<code>void              gt_encseq_builder_add_cstr(GtEncseqBuilder *eb,
                                            const char *str,
                                            unsigned long strlen,
                                            const char *desc)</code>
<p>
Adds a sequence given as a C string <code>str</code> of length <code>strlen</code> to the
   encoded sequence to be built by <code>eb</code>. Additionally, a description can be
   given (<code>desc</code>). If description support is enabled, this must not be <code>NULL</code>.
   A copy will be made during the addition process and the sequence will
   be encoded using the alphabet set at the construction time of <code>eb</code>. Thus it
   must only contain symbols compatible with the alphabet.
</p>
<hr>
<a name="gt_encseq_builder_add_str"></a>

<code>void              gt_encseq_builder_add_str(GtEncseqBuilder *eb, GtStr *str,
                                           const char *desc)</code>
<p>
Adds a sequence given as a GtStr <code>str</code> to the encoded sequence to be built
   by <code>eb</code>. Additionally, a description can be given. If description support
   is enabled, <code>desc</code> must not be <code>NULL</code>.
   A copy will be made during the addition process and the sequence will
   be encoded using the alphabet set at the construction time of <code>eb</code>. Thus it
   must only contain symbols compatible with the alphabet.
</p>
<hr>
<a name="gt_encseq_builder_add_encoded"></a>

<code>void              gt_encseq_builder_add_encoded(GtEncseqBuilder *eb,
                                               const GtUchar *str,
                                               unsigned long strlen,
                                               const char *desc)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>.
   Does not take ownership of <code>str</code>.
   Additionally, a description <code>desc</code> can be given. If description support
   is enabled, this must not be <code>NULL</code>.
</p>
<hr>
<a name="gt_encseq_builder_add_encoded_own"></a>

<code>void              gt_encseq_builder_add_encoded_own(GtEncseqBuilder *eb,
                                                   const GtUchar *str,
                                                   unsigned long strlen,
                                                   const char *desc)</code>
<p>
Adds a sequence given as a pre-encoded string  <code>str</code> of length <code>strlen</code> to
   the encoded sequence to be built by <code>eb</code>. <code>str</code> must be encoded using the
   alphabet set at the construction time of <code>eb</code>.
   Always creates a copy of <code>str</code>, so it can be used with memory that is to be
   freed immediately after adding.
   Additionally, a description <code>desc</code> can be given. If description support
   is enabled, this must not be <code>NULL</code>.
</p>
<hr>
<a name="gt_encseq_builder_set_logger"></a>

<code>void              gt_encseq_builder_set_logger(GtEncseqBuilder*, GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is <code>NULL</code> (no
   logging).
</p>
<hr>
<a name="gt_encseq_builder_build"></a>

<code>GtEncseq*         gt_encseq_builder_build(GtEncseqBuilder *eb, GtError *err)</code>
<p>
Creates a new <code>GtEncseq</code> from the sequences added to <code>eb</code>.
   Returns a <code>GtEncseq</code> instance on success, or <code>NULL</code> on error.
   If an error occurred, <code>err</code> is set accordingly.
   The state of <code>eb</code> is reset to empty after successful creation of a new
   <code>GtEncseq</code> (like having called <code>gt_encseq_builder_reset()</code>).
</p>
<hr>
<a name="gt_encseq_builder_reset"></a>

<code>void              gt_encseq_builder_reset(GtEncseqBuilder *eb)</code>
<p>
Clears all added sequences and descriptions, resetting <code>eb</code> to a state
   similar to the state immediately after its initial creation.
</p>
<hr>
<a name="gt_encseq_builder_delete"></a>

<code>void              gt_encseq_builder_delete(GtEncseqBuilder *eb)</code>
<p>
Deletes <code>eb</code>.
</p>
<hr>
<a name="GtEncseqEncoder"></a>
<h2>Class GtEncseqEncoder</h2>

<p> The <code>GtEncseqEncoder</code> class creates objects encapsulating a parameter
   set for conversion from sequence files into encoded sequence files on
   secondary storage. </p>

<hr>
<a name="gt_encseq_encoder_new"></a>

<code>GtEncseqEncoder*  gt_encseq_encoder_new(void)</code>
<p>
Creates a new <code>GtEncseqEncoder</code>.
</p>
<hr>
<a name="gt_encseq_encoder_set_timer"></a>

<code>void              gt_encseq_encoder_set_timer(GtEncseqEncoder *ee, GtTimer *t)</code>
<p>
Sets <code>t</code> to be the timer for <code>ee</code>. Default is <code>NULL</code> (no progress
reporting).
</p>
<hr>
<a name="gt_encseq_encoder_get_timer"></a>

<code>GtTimer*          gt_encseq_encoder_get_timer(const GtEncseqEncoder *ee)</code>
<p>
Returns the timer set for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_use_representation"></a>

<code>int               gt_encseq_encoder_use_representation(GtEncseqEncoder *ee,
                                                      const char *sat,
                                                      GtError *err)</code>
<p>
Sets the representation of <code>ee</code> to <code>sat</code> which must be one of 'direct',
   'bytecompress', 'bit', 'uchar', 'ushort' or 'uint32'. Returns 0 on success,
   and a negative value on error (<code>err</code> is set accordingly).
</p>
<hr>
<a name="gt_encseq_encoder_representation"></a>

<code>GtStr*            gt_encseq_encoder_representation(const GtEncseqEncoder *ee)</code>
<p>
Returns the representation requested for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_use_symbolmap_file"></a>

<code>int               gt_encseq_encoder_use_symbolmap_file(GtEncseqEncoder *ee,
                                                      const char *smap,
                                                      GtError *err)</code>
<p>
Sets the symbol map file to use in <code>ee</code> to <code>smap</code> which must a valid
   alphabet description file. Returns 0 on success, and a negative value on
   error (<code>err</code> is set accordingly). Default is <code>NULL</code> (no alphabet
   transformation).
</p>
<hr>
<a name="gt_encseq_encoder_symbolmap_file"></a>

<code>const char*       gt_encseq_encoder_symbolmap_file(const GtEncseqEncoder *ee)</code>
<p>
Returns the symbol map file requested for <code>ee</code>.
</p>
<hr>
<a name="gt_encseq_encoder_set_logger"></a>

<code>void              gt_encseq_encoder_set_logger(GtEncseqEncoder *ee,
                                              GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is <code>NULL</code> (no
   logging).
</p>
<hr>
<a name="gt_encseq_encoder_enable_description_support"></a>

<code>void              gt_encseq_encoder_enable_description_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   encoded by <code>ee</code>. That is, the .des and .sds tables are created.
   This is a prerequisite for being able to activate description support in
   <code>gt_encseq_loader_require_description_support()</code>. Activated by default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_description_support"></a>

<code>void              gt_encseq_encoder_disable_description_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   encoded by <code>ee</code>. That is, the .des and .sds tables are not created.
   Encoded sequences created without this support will not be able to be
   loaded via a <code>GtEncseqLoader</code> with
   <code>gt_encseq_loader_require_description_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_multiseq_support"></a>

<code>void              gt_encseq_encoder_enable_multiseq_support(GtEncseqEncoder *ee)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence encoded by <code>ee</code>. That is, the .ssp table is created.
   This is a prerequisite for being able to activate description support in
   <code>gt_encseq_loader_require_multiseq_support()</code>. Activated by default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_multiseq_support"></a>

<code>void              gt_encseq_encoder_disable_multiseq_support(
                                                           GtEncseqEncoder *ee)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence encoded by <code>ee</code>. That is, the .ssp table is not created.
   Encoded sequences created without this support will not be able to be
   loaded via a <code>GtEncseqLoader</code> with
   <code>gt_encseq_loader_require_multiseq_support()</code> enabled.
</p>
<hr>
<a name="gt_encseq_encoder_enable_lossless_support"></a>

<code>void              gt_encseq_encoder_enable_lossless_support(GtEncseqEncoder *ee)</code>
<p>
Enables support for lossless reproduction of the original sequence,
   regardless of alphabet transformations that may apply. Deactivated by
   default.
</p>
<hr>
<a name="gt_encseq_encoder_disable_lossless_support"></a>

<code>void              gt_encseq_encoder_disable_lossless_support(GtEncseqEncoder
                                                                           *ee)</code>
<p>
Enables support for lossless reproduction of the original sequence,
   regardless of alphabet transformations that may apply. Encoded sequences
   created without this support will not be able to be loaded via a
   <code>GtEncseqLoader</code> with <code>gt_encseq_loader_require_lossless_support()</code>
   enabled.
</p>
<hr>
<a name="gt_encseq_encoder_create_des_tab"></a>

<code>void              gt_encseq_encoder_create_des_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .des table containing sequence descriptions.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_des_tab"></a>

<code>void              gt_encseq_encoder_do_not_create_des_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .des table.
</p>
<hr>
<a name="gt_encseq_encoder_des_tab_requested"></a>

<code>bool              gt_encseq_encoder_des_tab_requested(const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .des table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_ssp_tab"></a>

<code>void              gt_encseq_encoder_create_ssp_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .ssp table containing indexes for multiple sequences.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_ssp_tab"></a>

<code>void              gt_encseq_encoder_do_not_create_ssp_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .ssp table.
</p>
<hr>
<a name="gt_encseq_encoder_ssp_tab_requested"></a>

<code>bool              gt_encseq_encoder_ssp_tab_requested(const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .ssp table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_create_sds_tab"></a>

<code>void              gt_encseq_encoder_create_sds_tab(GtEncseqEncoder *ee)</code>
<p>
Enables creation of the .sds table containing indexes for sequence
   descriptions. Enabled by default.
</p>
<hr>
<a name="gt_encseq_encoder_do_not_create_sds_tab"></a>

<code>void              gt_encseq_encoder_do_not_create_sds_tab(GtEncseqEncoder *ee)</code>
<p>
Disables creation of the .sds table.
</p>
<hr>
<a name="gt_encseq_encoder_sds_tab_requested"></a>

<code>bool              gt_encseq_encoder_sds_tab_requested(const GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the creation of the .sds table has been requested,
   <code>false</code> otherwise.
</p>
<hr>
<a name="gt_encseq_encoder_set_input_dna"></a>

<code>void              gt_encseq_encoder_set_input_dna(GtEncseqEncoder *ee)</code>
<p>
Sets the sequence input type for <code>ee</code> to DNA.
</p>
<hr>
<a name="gt_encseq_encoder_is_input_dna"></a>

<code>bool              gt_encseq_encoder_is_input_dna(GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the input sequence has been defined as being DNA.
</p>
<hr>
<a name="gt_encseq_encoder_set_input_protein"></a>

<code>void              gt_encseq_encoder_set_input_protein(GtEncseqEncoder *ee)</code>
<p>
Sets the sequence input type for <code>ee</code> to protein/amino acids.
</p>
<hr>
<a name="gt_encseq_encoder_is_input_protein"></a>

<code>bool              gt_encseq_encoder_is_input_protein(GtEncseqEncoder *ee)</code>
<p>
Returns <code>true</code> if the input sequence has been defined as being protein.
</p>
<hr>
<a name="gt_encseq_encoder_encode"></a>

<code>int               gt_encseq_encoder_encode(GtEncseqEncoder *ee,
                                          GtStrArray *seqfiles,
                                          const char *indexname,
                                          GtError *err)</code>
<p>
Encodes the sequence files given in <code>seqfiles</code> using the settings in <code>ee</code>
   and <code>indexname</code> as the prefix for the index tables. Returns 0 on success, or
   a negative value on error (<code>err</code> is set accordingly).
</p>
<hr>
<a name="gt_encseq_encoder_delete"></a>

<code>void              gt_encseq_encoder_delete(GtEncseqEncoder *ee)</code>
<p>
Deletes <code>ee</code>.
</p>
<hr>
<a name="GtEncseqLoader"></a>
<h2>Class GtEncseqLoader</h2>

<p> The <code>GtEncseqLoader</code> class creates <code>GtEncseq</code> objects by mapping index files
   from secondary storage into memory. </p>

<hr>
<a name="gt_encseq_loader_new"></a>

<code>GtEncseqLoader*   gt_encseq_loader_new(void)</code>
<p>
Creates a new <code>GtEncseqLoader</code>.
</p>
<hr>
<a name="gt_encseq_loader_enable_autosupport"></a>

<code>void              gt_encseq_loader_enable_autosupport(GtEncseqLoader *el)</code>
<p>
Enables auto-discovery of supported features when loading an encoded
   sequence. That is, if a file with <code>indexname</code>.<code>suffix</code> exists which
   is named like a table file, it is loaded automatically.
   Use <code>gt_encseq_has_multiseq_support()</code> etc. to query for these capabilities.
</p>
<hr>
<a name="gt_encseq_loader_disable_autosupport"></a>

<code>void              gt_encseq_loader_disable_autosupport(GtEncseqLoader *el)</code>
<p>
Disables auto-discovery of supported features.
</p>
<hr>
<a name="gt_encseq_loader_require_description_support"></a>

<code>void              gt_encseq_loader_require_description_support(
                                                            GtEncseqLoader *el)</code>
<p>
Enables support for retrieving descriptions from the encoded sequence
   to be loaded by <code>el</code>. That is, the .des and .sds tables must be present.
   For example, these tables are created by having enabled the
   <code>gt_encseq_encoder_enable_description_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_description_support"></a>

<code>void              gt_encseq_loader_drop_description_support(GtEncseqLoader *el)</code>
<p>
Disables support for retrieving descriptions from the encoded sequence
   to be loaded by <code>el</code>. That is, the .des and .sds tables need not be present.
   However, disabling this support will result in an error when trying to call
   the method <code>gt_encseq_description()</code> on the <code>GtEncseq</code>
   object created by <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_require_multiseq_support"></a>

<code>void              gt_encseq_loader_require_multiseq_support(GtEncseqLoader *el)</code>
<p>
Enables support for random access to multiple sequences in the encoded
   sequence to be loaded by <code>el</code>. That is, the .ssp table must be present.
   For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_multiseq_support()</code> option when encoding.
   Activated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_multiseq_support"></a>

<code>void              gt_encseq_loader_drop_multiseq_support(GtEncseqLoader *el)</code>
<p>
Disables support for random access to multiple sequences in the encoded
   sequence to be loaded by <code>el</code>. That is, the .ssp table needs not be present.
   However, disabling this support will result in an error when trying to call
   the method <code>gt_encseq_seqlength()</code> and <code>gt_encseq_seqstartpos()</code> on
   the <code>GtEncseq</code> object created by <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_require_lossless_support"></a>

<code>void              gt_encseq_loader_require_lossless_support(GtEncseqLoader *el)</code>
<p>
Enables support for lossless reproduction of the original sequence
   in the encoded sequence to be loaded by <code>el</code>. That is, the .ois table
   must be present.
   For example, this table is created by having enabled the
   <code>gt_encseq_encoder_enable_lossless_support()</code> option when encoding.
   Deactivated by default.
</p>
<hr>
<a name="gt_encseq_loader_drop_lossless_support"></a>

<code>void              gt_encseq_loader_drop_lossless_support(GtEncseqLoader *el)</code>
<p>
Disables support for lossless reproduction of the original sequence
   in the encoded sequence to be loaded by <code>el</code>. That is, the .ois table
   needs not be present.
   However, disabling this support may result in a reduced alphabet
   representation when accessing decoded characters.
</p>
<hr>
<a name="gt_encseq_loader_require_des_tab"></a>

<code>void              gt_encseq_loader_require_des_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .des table containing sequence descriptions.
   Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_des_tab"></a>

<code>void              gt_encseq_loader_do_not_require_des_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .des table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_des_tab_required"></a>

<code>bool              gt_encseq_loader_des_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns <code>true</code> if a .des table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_require_ssp_tab"></a>

<code>void              gt_encseq_loader_require_ssp_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .ssp table containing indexes for multiple
   sequences. Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_ssp_tab"></a>

<code>void              gt_encseq_loader_do_not_require_ssp_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .ssp table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_ssp_tab_required"></a>

<code>bool              gt_encseq_loader_ssp_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns <code>true</code> if a .ssp table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_require_sds_tab"></a>

<code>void              gt_encseq_loader_require_sds_tab(GtEncseqLoader *el)</code>
<p>
Requires presence of the .sds table containing indexes for sequence
   descriptions. Enabled by default.
</p>
<hr>
<a name="gt_encseq_loader_do_not_require_sds_tab"></a>

<code>void              gt_encseq_loader_do_not_require_sds_tab(GtEncseqLoader *el)</code>
<p>
Disables requirement of the .sds table for loading a <code>GtEncseq</code>
   using <code>el</code>.
</p>
<hr>
<a name="gt_encseq_loader_sds_tab_required"></a>

<code>bool              gt_encseq_loader_sds_tab_required(const GtEncseqLoader *el)</code>
<p>
Returns <code>true</code> if a .sds table must be present for loading to succeed.
</p>
<hr>
<a name="gt_encseq_loader_set_logger"></a>

<code>void              gt_encseq_loader_set_logger(GtEncseqLoader *el, GtLogger *l)</code>
<p>
Sets the logger to use by <code>ee</code> during encoding to <code>l</code>. Default is <code>NULL</code> (no
   logging).
</p>
<hr>
<a name="gt_encseq_loader_mirror"></a>

<code>void              gt_encseq_loader_mirror(GtEncseqLoader *el)</code>
<p>
Enables loading of a sequence using <code>el</code> with mirroring enabled from the
   start. Identical to invoking <code>gt_encseq_mirror()</code> directly after loading.
</p>
<hr>
<a name="gt_encseq_loader_do_not_mirror"></a>

<code>void              gt_encseq_loader_do_not_mirror(GtEncseqLoader *el)</code>
<p>
Disables loading of a sequence using <code>el</code> with mirroring enabled right from
   the start.
</p>
<hr>
<a name="gt_encseq_loader_load"></a>

<code>GtEncseq*         gt_encseq_loader_load(GtEncseqLoader *el,
                                       const char *indexname,
                                       GtError *err)</code>
<p>
Attempts to map the index files as specified by <code>indexname</code> using the options
   set in <code>el</code> using this interface. Returns a <code>GtEncseq</code> instance
   on success, or <code>NULL</code> on error. If an error occurred, <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_encseq_loader_delete"></a>

<code>void              gt_encseq_loader_delete(GtEncseqLoader *el)</code>
<p>
Deletes <code>el</code>.
</p>
<hr>
<a name="GtEncseqReader"></a>
<h2>Class GtEncseqReader</h2>

<p> The <code>GtEncseqReader</code> class represents the current state of a
   sequential scan of a <code>GtEncseq</code> region as an iterator. </p>

<hr>
<a name="gt_encseq_reader_reinit_with_readmode"></a>

<code>void             gt_encseq_reader_reinit_with_readmode(GtEncseqReader *esr,
                                                      const GtEncseq *encseq,
                                                      GtReadmode readmode,
                                                      unsigned long startpos)</code>
<p>
Reinitializes the given <code>esr</code> with the values as described in
   <code>gt_encseq_create_reader_with_readmode()</code>.
</p>
<hr>
<a name="gt_encseq_reader_next_encoded_char"></a>

<code>GtUchar          gt_encseq_reader_next_encoded_char(GtEncseqReader *esr)</code>
<p>
Returns the next encoded character from current position of <code>esr</code>, advancing
   the iterator by one position.
</p>
<hr>
<a name="gt_encseq_reader_next_decoded_char"></a>

<code>char             gt_encseq_reader_next_decoded_char(GtEncseqReader *esr)</code>
<p>
Returns the next decoded character from current position of <code>esr</code>, advancing
   the iterator by one position.
</p>
<hr>
<a name="gt_encseq_reader_delete"></a>

<code>void             gt_encseq_reader_delete(GtEncseqReader *esr)</code>
<p>
Deletes <code>esr</code>, freeing all associated space.
</p>
<hr>
<a name="GtError"></a>
<h2>Class GtError</h2>

<p>
   This class is used for the handling of <strong>user errors</strong> in <em>GenomeTools</em>.
   Thereby, the actual <code>GtError</code> object is used to store the <em>error message</em>
   while it is signaled by the return value of the called function, if an error
   occured.</p><p>   By convention in <em>GenomeTools</em>, the <code>GtError</code> object is always passed into
   a function as the last parameter and -1 (or <code>NULL</code> for constructors) is used
   as return value to indicate that an error occurred.
   Success is usually indicated by 0 as return value or via a non-<code>NULL</code> object
   pointer for constructors.</p><p>   It is possible to use <code>NULL</code> as an <code>GtError</code> object, if one is not interested
   in the actual error message.</p><p>   Functions which do not get an <code>GtError</code> object cannot fail due to a user
   error and it is not necessary to check their return code for an error
   condition.
</p>

<hr>
<a name="gt_error_new"></a>

<code>GtError*    gt_error_new(void)</code>
<p>
Return a new <code>GtError</code> object
</p>
<hr>
<a name="gt_error_check"></a>

<code>#define gt_error_check(err)</code>
<p>
Insert an assertion to check that the error <code>err</code> is not set or is <code>NULL</code>.
   This macro should be used at the beginning of every routine which has an
   <code>GtError*</code> argument to make sure the error propagation has been coded
   correctly.
</p>
<hr>
<a name="gt_error_set"></a>

<code>void         gt_error_set(GtError *err, const char *format, ...)</code>
<p>
Set the error message stored in <code>err</code> according to <code>format</code> (as in
   <code>printf(3)</code>).
</p>
<hr>
<a name="gt_error_vset"></a>

<code>void         gt_error_vset(GtError *err, const char *format, va_list ap)</code>
<p>
Set the error message stored in <code>err</code> according to <code>format</code> (as in
   <code>vprintf(3)</code>).
</p>
<hr>
<a name="gt_error_set_nonvariadic"></a>

<code>void         gt_error_set_nonvariadic(GtError *err, const char *msg)</code>
<p>
Set the error message stored in <code>err</code> to <code>msg</code>.
</p>
<hr>
<a name="gt_error_is_set"></a>

<code>bool         gt_error_is_set(const GtError *err)</code>
<p>
Return <code>true</code> if the error <code>err</code> is set, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_error_unset"></a>

<code>void         gt_error_unset(GtError *err)</code>
<p>
Unset the error <code>err</code>.
</p>
<hr>
<a name="gt_error_get"></a>

<code>const char*  gt_error_get(const GtError *err)</code>
<p>
Return the error string stored in <code>err</code> (the error must be set).
</p>
<hr>
<a name="gt_error_delete"></a>

<code>void         gt_error_delete(GtError *err)</code>
<p>
Delete the error object <code>err</code>.
</p>
<hr>
<a name="GtExtractFeatureStream"></a>
<h2>Class GtExtractFeatureStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtExtractFeatureStream</code> extracts
   the corresponding sequences of features. </p>

<hr>
<a name="gt_extract_feature_stream_new"></a>

<code>GtNodeStream*  gt_extract_feature_stream_new(GtNodeStream *in_stream,
                                            GtRegionMapping *region_Mapping,
                                            const char *type, bool join,
                                            bool translate, bool seqid,
                                            bool target, unsigned long width,
                                            GtFile *outfp)</code>
<p>
Create a <code>GtExtractFeatureStream*</code> which extracts the corresponding sequences
   of feature nodes (of the given <code>type</code>) it retrieves from <code>in_stream</code> and
   writes them in FASTA format (with the given <code>width</code>) to <code>outfp</code>. If <code>join</code> is
   <code>true</code>, features of the given <code>type</code> are joined together before the sequence
   is extracted. If <code>translate</code> is <code>true</code>, the sequences are translated into
   amino acid sequences before they are written to <code>outfp</code>. If <code>seqid</code> is <code>true</code>
   the sequence IDs of the extracted features are added to the FASTA header.
   If <code>target</code> is <code>true</code> the target IDs of the extracted features are added to
   the FASTA header. Takes ownership of <code>region_mapping</code>!
</p>
<hr>
<a name="GtFeatureIndex"></a>
<h2>Class GtFeatureIndex</h2>

<p> This interface represents a searchable container for <code>GtFeatureNode</code> objects,
   typically root nodes of larger structures. How storage and searching takes
   place is left to the discretion of the implementing class.</p><p>   Output from a <code>gt_feature_index_get_features_*()</code> method should always
   be sorted by feature start position. </p>

<hr>
<a name="gt_feature_index_add_region_node"></a>

<code>void         gt_feature_index_add_region_node(GtFeatureIndex *feature_index,
                                             GtRegionNode *region_node)</code>
<p>
Add <code>region_node</code> to <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_add_feature_node"></a>

<code>void         gt_feature_index_add_feature_node(GtFeatureIndex *feature_index,
                                              GtFeatureNode *feature_node)</code>
<p>
Add <code>feature_node</code> to <code>feature_index</code>, associating it with a sequence
   region denoted by its identifier string.
</p>
<hr>
<a name="gt_feature_index_add_gff3file"></a>

<code>int          gt_feature_index_add_gff3file(GtFeatureIndex *feature_index,
                                          const char *gff3file, GtError *err)</code>
<p>
Add all features contained in <code>gff3file</code> to <code>feature_index</code>, if <code>gff3file</code> is
   valid. Otherwise, <code>feature_index</code> is not changed and <code>err</code> is set.
</p>
<hr>
<a name="gt_feature_index_get_features_for_seqid"></a>

<code>GtArray*     gt_feature_index_get_features_for_seqid(GtFeatureIndex*,
                                                    const char *seqid)</code>
<p>
Returns an array of <code>GtFeatureNodes</code> associated with a given sequence region
   identifier <code>seqid</code>.
</p>
<hr>
<a name="gt_feature_index_get_features_for_range"></a>

<code>int          gt_feature_index_get_features_for_range(GtFeatureIndex
                                                    *feature_index,
                                                    GtArray *results,
                                                    const char *seqid,
                                                    const GtRange *range,
                                                    GtError*)</code>
<p>
Look up genome features in <code>feature_index</code> for sequence region <code>seqid</code> in
   <code>range</code> and store them in <code>results</code>.
</p>
<hr>
<a name="gt_feature_index_get_first_seqid"></a>

<code>const char*  gt_feature_index_get_first_seqid(const GtFeatureIndex
                                             *feature_index)</code>
<p>
Returns the first sequence region identifier added to <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_get_seqids"></a>

<code>GtStrArray*  gt_feature_index_get_seqids(const GtFeatureIndex *feature_index)</code>
<p>
Returns a <code>GtStrArray</code> of all sequence region identifiers contained in
   <code>feature_index</code> (in alphabetical order).
</p>
<hr>
<a name="gt_feature_index_get_range_for_seqid"></a>

<code>void         gt_feature_index_get_range_for_seqid(GtFeatureIndex *feature_index,
                                                 GtRange *range,
                                                 const char *seqid)</code>
<p>
Writes the range of all features contained in the <code>feature_index</code> for
   region identifier <code>seqid</code> to the <code>GtRange</code> pointer <code>range</code>.
</p>
<hr>
<a name="gt_feature_index_has_seqid"></a>

<code>bool         gt_feature_index_has_seqid(const GtFeatureIndex *feature_index,
                                       const char *seqid)</code>
<p>
Returns <code>true</code> if the sequence region identified by <code>seqid</code> has been
  registered in the <code>feature_index</code>.
</p>
<hr>
<a name="gt_feature_index_delete"></a>

<code>void         gt_feature_index_delete(GtFeatureIndex*)</code>
<p>
Deletes the <code>feature_index</code> and all its referenced features.
</p>
<hr>
<a name="GtFeatureIndexMemory"></a>
<h2>Class GtFeatureIndexMemory</h2>

<p> The <code>GtFeatureIndexMemory</code> class implements a <code>GtFeatureIndex</code> in memory.
   Features are organized by region node. Each region node collects its
   feature nodes in an interval tree structure, which allows for efficient
   range queries. </p>

<hr>
<a name="gt_feature_index_memory_new"></a>

<code>GtFeatureIndex*  gt_feature_index_memory_new(void)</code>
<p>
Creates a new <code>GtFeatureIndexMemory</code> object.
</p>
<hr>
<a name="GtFeatureNode"></a>
<h2>Class GtFeatureNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. A single feature node corresponds
   to a GFF3 feature line (i.e., a line which does not start with <code>#</code>).
   Part-of relationships (which are realized in GFF3 with the <code>Parent</code> and <code>ID</code>
   attributes) are realized in the C API with the
   <code>gt_feature_node_add_child()</code> method.</p><p>   Besides the ``mere'' feature nodes two ``special'' feature nodes exist:
   multi-features and pseudo-features.</p><p>   Multi-features represent features which span multiple lines (it is indicated
   in GFF3 files by the fact, that each line has the same ID attribute).</p><p>   To check if a feature is a multi-feature use the method
   <code>gt_feature_node_is_multi()</code>.
   Multi-features are connected via a ``representative''. That is, two features
   are part of the same multi-feature if they have the same representative.
   The feature node representative can be be retrieved via the
   <code>gt_feature_node_get_multi_representative()</code> method.</p><p>   Pseudo-features became a technical necessity to be able to pass related
   top-level features as a single entity through the streaming machinery.
   There are two cases in which a pseudo-feature has to be introduced.</p><p>   First, if a multi-feature has no parent. In this case all features which
   comprise the multi-feature become the children of a pseudo-feature.</p><p>   Second, if two or more top-level features have the same children (and are
   thereby connected). In this case all these top-level features become the
   children of a pseudo-feature.</p><p>   It should be clear from the explanation above that pseudo-features make only
   sense as top-level features (a fact which is enforced in the code).</p><p>   Pseudo-features are typically ignored during a traversal to give the illusion
   that they do not exist. </p>

<hr>
<a name="gt_feature_node_new"></a>

<code>GtGenomeNode*   gt_feature_node_new(GtStr *seqid, const char *type,
                                   unsigned long start, unsigned long end,
                                   GtStrand strand)</code>
<p>
Return an new <code>GtFeatureNode</code> object on sequence with ID <code>seqid</code> and type
   <code>type</code> which lies from <code>start</code> to <code>end</code> on strand <code>strand</code>.
   The <code>GtFeatureNode*</code> stores a new reference to <code>seqid</code>, so make sure you do
   not modify the original <code>seqid</code> afterwards!
   <code>start</code> and <code>end</code> always refer to the forward strand, therefore <code>start</code> has
   to be smaller or equal than <code>end</code>.
</p>
<hr>
<a name="gt_feature_node_new_pseudo"></a>

<code>GtGenomeNode*   gt_feature_node_new_pseudo(GtStr *seqid, unsigned long start,
                                          unsigned long end, GtStrand strand)</code>
<p>
Return a new pseudo-<code>GtFeatureNode</code> object on sequence with ID <code>seqid</code> which
   lies from <code>start</code> to <code>end</code> on strand <code>strand</code>. Pseudo-features do not have a
   type.  The <code>GtFeatureNode </code> stores a new reference to <code>seqid</code>, so make sure
   you do not modify the original <code>seqid</code> afterwards.  <code>start</code> and <code>end</code> always
   refer to the forward strand, therefore <code>start</code> has to be smaller or equal
   than <code>end</code>.
</p>
<hr>
<a name="gt_feature_node_new_pseudo_template"></a>

<code>GtGenomeNode*   gt_feature_node_new_pseudo_template(GtFeatureNode *feature_node)</code>
<p>
Return a new pseudo-<code>GtFeatureNode</code> object which uses <code>feature_node</code> as
   template.  That is, the sequence ID, range, strand, and source are taken from
   <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_new_standard_gene"></a>

<code>GtGenomeNode*   gt_feature_node_new_standard_gene(void)</code>
<p>
Return the ``standard gene'' (mainly for testing purposes).
</p>
<hr>
<a name="gt_feature_node_add_child"></a>

<code>void            gt_feature_node_add_child(GtFeatureNode *parent,
                                         GtFeatureNode *child)</code>
<p>
Add <code>child</code> feature node to <code>parent</code> feature node.
   <code>parent</code> takes ownership of <code>child</code>.
</p>
<hr>
<a name="gt_feature_node_get_source"></a>

<code>const char*     gt_feature_node_get_source(const GtFeatureNode *feature_node)</code>
<p>
Return the source of <code>feature_node</code>. If no source has been set, "." is
   returned. Corresponds to column 2 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_source"></a>

<code>void            gt_feature_node_set_source(GtFeatureNode *feature_node,
                                          GtStr *source)</code>
<p>
Set the <code>source</code> of <code>feature_node</code>. Stores a new reference to <code>source</code>.
   Corresponds to column 2 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_has_source"></a>

<code>bool            gt_feature_node_has_source(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> has a defined source (i.e., on different
   from "."). <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_get_type"></a>

<code>const char*     gt_feature_node_get_type(const GtFeatureNode *feature_node)</code>
<p>
Return the type of <code>feature_node</code>.
   Corresponds to column 3 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_type"></a>

<code>void            gt_feature_node_set_type(GtFeatureNode *feature_node,
                                        const char *type)</code>
<p>
Set the type of <code>feature_node</code> to <code>type</code>.
</p>
<hr>
<a name="gt_feature_node_has_type"></a>

<code>bool            gt_feature_node_has_type(GtFeatureNode *feature_node,
                                        const char *type)</code>
<p>
Return <code>true</code> if <code>feature_node</code> has given <code>type</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_score_is_defined"></a>

<code>bool            gt_feature_node_score_is_defined(const GtFeatureNode
                                                *feature_node)</code>
<p>
Return <code>true</code> if the score of <code>feature_node</code> is defined, <code>false</code>
   otherwise.
</p>
<hr>
<a name="gt_feature_node_get_score"></a>

<code>float           gt_feature_node_get_score(const GtFeatureNode *feature_node)</code>
<p>
Return the score of <code>feature_node</code>. The score has to be defined.
   Corresponds to column 6 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_score"></a>

<code>void            gt_feature_node_set_score(GtFeatureNode *feature_node,
                                         float score)</code>
<p>
Set the score of <code>feature_node</code> to <code>score</code>.
</p>
<hr>
<a name="gt_feature_node_unset_score"></a>

<code>void            gt_feature_node_unset_score(GtFeatureNode *feature_node)</code>
<p>
Unset the score of <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_get_strand"></a>

<code>GtStrand        gt_feature_node_get_strand(const GtFeatureNode *feature_node)</code>
<p>
Return the strand of <code>feature_node</code>.
   Corresponds to column 7 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_strand"></a>

<code>void            gt_feature_node_set_strand(GtFeatureNode *feature_node,
                                          GtStrand strand)</code>
<p>
Set the strand of <code>feature_node</code> to <code>strand</code>.
</p>
<hr>
<a name="gt_feature_node_get_phase"></a>

<code>GtPhase         gt_feature_node_get_phase(const GtFeatureNode *feature_node)</code>
<p>
Return the phase of <code>feature_node</code>.
   Corresponds to column 8 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_set_phase"></a>

<code>void            gt_feature_node_set_phase(GtFeatureNode *feature_node,
                                         GtPhase phase)</code>
<p>
Set the phase of <code>feature_node</code> to <code>phase</code>.
</p>
<hr>
<a name="gt_feature_node_get_attribute"></a>

<code>const char*     gt_feature_node_get_attribute(const GtFeatureNode *feature_node,
                                             const char *name)</code>
<p>
Return the attribute of <code>feature_node</code> with the given <code>name</code>.
   If no such attribute has been added, <code>NULL</code> is returned.
   The attributes are stored in column 9 of GFF3 feature lines.
</p>
<hr>
<a name="gt_feature_node_get_attribute_list"></a>

<code>GtStrArray*     gt_feature_node_get_attribute_list(const GtFeatureNode
                                                  *feature_node)</code>
<p>
Return a string array containing the used attribute names of <code>feature_node</code>.
   The caller is responsible to free the returned <code>GtStrArray*</code>.
</p>
<hr>
<a name="gt_feature_node_add_attribute"></a>

<code>void            gt_feature_node_add_attribute(GtFeatureNode *feature_node,
                                             const char *tag,
                                             const char *value)</code>
<p>
Add attribute <code>tag</code>=<code>value</code> to <code>feature_node</code>. <code>tag</code> and <code>value</code> must at
   least have length 1. <code>feature_node</code> must not contain an attribute with the
   given <code>tag</code> already. You should not add Parent and ID attributes, use
   <code>gt_feature_node_add_child()</code> to denote part-of relationships.
</p>
<hr>
<a name="gt_feature_node_set_attribute"></a>

<code>void            gt_feature_node_set_attribute(GtFeatureNode* feature_node,
                                             const char *tag,
                                             const char *value)</code>
<p>
Set attribute <code>tag</code> to new <code>value</code> in <code>feature_node</code>, if it exists already.
   Otherwise the attribute <code>tag</code>=<code>value</code> is added to <code>feature_node</code>.
   <code>tag</code> and <code>value</code> must at least have length 1.
   You should not set Parent and ID attributes, use
   <code>gt_feature_node_add_child()</code> to denote part-of relationships.
</p>
<hr>
<a name="gt_feature_node_is_multi"></a>

<code>bool            gt_feature_node_is_multi(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> is a multi-feature, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_is_pseudo"></a>

<code>bool            gt_feature_node_is_pseudo(const GtFeatureNode *feature_node)</code>
<p>
Return <code>true</code> if <code>feature_node</code> is a pseudo-feature, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_feature_node_make_multi_representative"></a>

<code>void            gt_feature_node_make_multi_representative(GtFeatureNode
                                                         *feature_node)</code>
<p>
Make <code>feature_node</code> the representative of a multi-feature.
   Thereby <code>feature_node</code> becomes a multi-feature.
</p>
<hr>
<a name="gt_feature_node_set_multi_representative"></a>

<code>void            gt_feature_node_set_multi_representative(GtFeatureNode
                                                        *feature_node,
                                                        GtFeatureNode
                                                        *representative)</code>
<p>
Set the multi-feature representative of <code>feature_node</code> to <code>representative</code>.
   Thereby <code>feature_node</code> becomes a multi-feature.
</p>
<hr>
<a name="gt_feature_node_unset_multi"></a>

<code>void            gt_feature_node_unset_multi(GtFeatureNode *feature_node)</code>
<p>
Unset the multi-feature status of <code>feature_node</code> and remove its multi-feature
   representative.
</p>
<hr>
<a name="gt_feature_node_get_multi_representative"></a>

<code>GtFeatureNode*  gt_feature_node_get_multi_representative(GtFeatureNode
                                                        *feature_node)</code>
<p>
Return the representative of the multi-feature <code>feature_node</code>.
</p>
<hr>
<a name="gt_feature_node_is_similar"></a>

<code>bool            gt_feature_node_is_similar(const GtFeatureNode *feature_node_a,
                                          const GtFeatureNode *feature_node_b)</code>
<p>
Returns <code>true</code>, if the given <code>feature_node_a</code> has the same seqid, feature
   type, range, strand, and phase as <code>feature_node_b</code>.
   Returns <code>false</code> otherwise.
</p>
<hr>
<a name="GtFeatureNodeIterator"></a>
<h2>Class GtFeatureNodeIterator</h2>
<a name="gt_feature_node_iterator_new"></a>

<code>GtFeatureNodeIterator*  gt_feature_node_iterator_new(const GtFeatureNode
                                                    *feature_node)</code>
<p>
Return a new <code>GtFeatureNodeIterator*</code> which performs a depth-first
   traversal of <code>feature_node</code> (including <code>feature_node</code> itself).
   It ignores pseudo-features.
</p>
<hr>
<a name="gt_feature_node_iterator_new_direct"></a>

<code>GtFeatureNodeIterator*  gt_feature_node_iterator_new_direct(const GtFeatureNode
                                                           *feature_node)</code>
<p>
Return a new <code>GtFeatureNodeIterator*</code> which iterates over all direct
   children of <code>feature_node</code> (without <code>feature_node</code> itself).
</p>
<hr>
<a name="gt_feature_node_iterator_next"></a>

<code>GtFeatureNode*          gt_feature_node_iterator_next(GtFeatureNodeIterator
                                                     *feature_node_iterator)</code>
<p>
Return the next <code>GtFeatureNode*</code> in <code>feature_node_iterator</code> or <code>NULL</code> if none
   exists.
</p>
<hr>
<a name="gt_feature_node_iterator_delete"></a>

<code>void                    gt_feature_node_iterator_delete(GtFeatureNodeIterator
                                                       *feature_node_iterator)</code>
<p>
Delete <code>feature_node_iterator</code>.
</p>
<hr>
<a name="GtFile"></a>
<h2>Class GtFile</h2>

<p> This class defines (generic) files in <em>GenomeTools</em>. A generic file is is a
   file which either uncompressed or compressed (with gzip or bzip2).
   A <code>NULL</code>-pointer as generic file implies <code>stdout</code>. </p>

<hr>
<a name="gt_file_new"></a>

<code>GtFile*  gt_file_new(const char *path, const char *mode, GtError *err)</code>
<p>
Return a new <code>GtFile</code> object for the given <code>path</code> and open the underlying
   file handle with given <code>mode</code>. Returns <code>NULL</code> and sets <code>err</code> accordingly, if
   the file <code>path</code> could not be opened. The compression mode is determined by
   the ending of <code>path</code> (gzip compression if it ends with '.gz', bzip2
   compression if it ends with '.bz2', and uncompressed otherwise).
</p>
<hr>
<a name="gt_file_xprintf"></a>

<code>void     gt_file_xprintf(GtFile *file, const char *format, ...)</code>
<p>
<code>printf(3)</code> for generic <code>file</code>.
</p>
<hr>
<a name="gt_file_xfputs"></a>

<code>void     gt_file_xfputs(const char *cstr, GtFile *file)</code>
<p>
Write <code>\0</code>-terminated C string <code>cstr</code> to <code>file</code>. Similar to <code>fputs(3)</code>, but
   terminates on error.
</p>
<hr>
<a name="gt_file_xfgetc"></a>

<code>int      gt_file_xfgetc(GtFile *file)</code>
<p>
Return next character from <code>file</code> or <code>EOF</code>, if end-of-file is reached.
</p>
<hr>
<a name="gt_file_xread"></a>

<code>int      gt_file_xread(GtFile *file, void *buf, size_t nbytes)</code>
<p>
Read up to <code>nbytes</code> from generic <code>file</code> and store result in <code>buf</code>, returns
   bytes read.
</p>
<hr>
<a name="gt_file_xwrite"></a>

<code>void     gt_file_xwrite(GtFile *file, void *buf, size_t nbytes)</code>
<p>
Write <code>nbytes</code> from <code>buf</code> to given generic <code>file</code>.
</p>
<hr>
<a name="gt_file_xrewind"></a>

<code>void     gt_file_xrewind(GtFile *file)</code>
<p>
Rewind the generic <code>file</code>.
</p>
<hr>
<a name="gt_file_delete"></a>

<code>void     gt_file_delete(GtFile *file)</code>
<p>
Close the underlying file handle and destroy the <code>file</code> object.
</p>
<hr>
<a name="GtGFF3InStream"></a>
<h2>Class GtGFF3InStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGFF3InStream</code> parses GFF3 files
   and returns them as a stream of <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_gff3_in_stream_new_unsorted"></a>

<code>GtNodeStream*             gt_gff3_in_stream_new_unsorted(int num_of_files,
                                                        const char **filenames)</code>
<p>
Return a <code>GtGFF3InStream</code> object which subsequently reads the <code>num_of_files</code>
   many GFF3 files denoted in <code>filenames</code>. The GFF3 files do not have to be
   sorted. If <code>num_of_files</code> is 0 or a file name is "-", it is read from
   <code>stdin</code>. The memory footprint is O(file size) in the worst-case.
</p>
<hr>
<a name="gt_gff3_in_stream_new_sorted"></a>

<code>GtNodeStream*             gt_gff3_in_stream_new_sorted(const char *filename)</code>
<p>
Create a <code>GtGFF3InStream*</code> which reads the sorted GFF3 file denoted by
   <code>filename</code>. If filename is <code>NULL</code>, it is read from <code>stdin</code>.
   The memory footprint is O(1) on average.
</p>
<hr>
<a name="gt_gff3_in_stream_check_id_attributes"></a>

<code>void                      gt_gff3_in_stream_check_id_attributes(GtGFF3InStream
                                                               *gff3_in_stream)</code>
<p>
Make sure all ID attributes which are parsed by <code>gff3_in_stream</code> are correct.
   Increases the memory footprint to O(file size).
</p>
<hr>
<a name="gt_gff3_in_stream_enable_tidy_mode"></a>

<code>void                      gt_gff3_in_stream_enable_tidy_mode(GtGFF3InStream
                                                            *gff3_in_stream)</code>
<p>
Enable tidy mode for <code>gff3_in_stream</code>. That is, the GFF3 parser tries to tidy
   up features which would normally lead to an error.
</p>
<hr>
<a name="gt_gff3_in_stream_show_progress_bar"></a>

<code>void                      gt_gff3_in_stream_show_progress_bar(GtGFF3InStream
                                                             *gff3_in_stream)</code>
<p>
Show progress bar on <code>stdout</code> to convey the progress of parsing the GFF3
   files underlying <code>gff3_in_stream</code>.
</p>
<hr>
<a name="GtGFF3OutStream"></a>
<h2>Class GtGFF3OutStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGFF3OutStream</code> produces GFF3
   output.
   It automatically inserts termination lines at the appropriate places. </p>

<hr>
<a name="gt_gff3_out_stream_new"></a>

<code>GtNodeStream*  gt_gff3_out_stream_new(GtNodeStream *in_stream, GtFile *outfp)</code>
<p>
Create a <code>GtGFF3OutStream*</code> which uses <code>in_stream</code> as input.
   It shows the nodes passed through it as GFF3 on <code>outfp</code>.
</p>
<hr>
<a name="gt_gff3_out_stream_set_fasta_width"></a>

<code>void           gt_gff3_out_stream_set_fasta_width(GtGFF3OutStream
                                                 *gff3_out_stream,
                                                 unsigned long fasta_width)</code>
<p>
Set the width with which the FASTA sequences of <code>GtSequenceNode</code>s passed
   through <code>gff3_out_stream</code> are shown to <code>fasta_width</code>.
   Per default, each FASTA entry is shown on a single line.
</p>
<hr>
<a name="gt_gff3_out_stream_retain_id_attributes"></a>

<code>void           gt_gff3_out_stream_retain_id_attributes(GtGFF3OutStream
                                                      *gff3_out_stream)</code>
<p>
If this method is called upon <code>gff3_out_stream</code>, use the original ID
   attributes provided in the input (instead of creating new ones, which
   is the default). Memory consumption for <code>gff3_out_stream</code> is raised from O(1)
   to O(<code>input_size</code>), because bookkeeping of used IDs becomes necessary to
   avoid ID collisions.
</p>
<hr>
<a name="GtGFF3Parser"></a>
<h2>Class GtGFF3Parser</h2>

<p> A <code>GtGFF3Parser</code> can be used to parse GFF3 files and convert them into
   <code>GtGenomeNode</code> objects. If the GFF3 files do not contain the encouraged
   sequence-region meta directives, the GFF3 parser introduces the corresponding
   region nodes automatically. This is a low-level class and it is usually not
   used directly. Normally, a <code>GtGFF3InStream</code> is used to parse GFF3 files. </p>

<hr>
<a name="gt_gff3_parser_new"></a>

<code>GtGFF3Parser*  gt_gff3_parser_new(GtTypeChecker *type_checker)</code>
<p>
Return a new <code>GtGFF3Parser</code> object with optional <code>type_checker</code>. If a
   <code>type_checker</code> was given, the <code>GtGFF3Parser</code> stores a new reference to it
   internally and uses the <code>type_checker</code> to check types during parsing.
</p>
<hr>
<a name="gt_gff3_parser_check_id_attributes"></a>

<code>void           gt_gff3_parser_check_id_attributes(GtGFF3Parser *gff3_parser)</code>
<p>
Enable ID attribute checking in <code>gff3_parser</code>. Thereby, the memory
   consumption of the <code>gff3_parser</code> becomes proportional to the input file
   size(s).
</p>
<hr>
<a name="gt_gff3_parser_check_region_boundaries"></a>

<code>void           gt_gff3_parser_check_region_boundaries(GtGFF3Parser *gff3_parser)</code>
<p>
Enable sequence region boundary checking in <code>gff3_parser</code>. That is,
   encountering features outside the sequence region boundaries will result in
   an error.
</p>
<hr>
<a name="gt_gff3_parser_do_not_check_region_boundaries"></a>

<code>void           gt_gff3_parser_do_not_check_region_boundaries(GtGFF3Parser
                                                                  *gff3_parser)</code>
<p>
Disable sequence region boundary checking in <code>gff3_parser</code>. That is,
   features outside the sequence region boundaries will be permitted.
</p>
<hr>
<a name="gt_gff3_parser_set_offset"></a>

<code>void           gt_gff3_parser_set_offset(GtGFF3Parser *gff3_parser, long offset)</code>
<p>
Transform all features parsed by <code>gff3_parser</code> by the given <code>offset</code>.
</p>
<hr>
<a name="gt_gff3_parser_enable_tidy_mode"></a>

<code>void           gt_gff3_parser_enable_tidy_mode(GtGFF3Parser *gff3_parser)</code>
<p>
Enable the tidy mode in <code>gff3_parser</code>. In tidy mode the <code>gff3_parser</code> parser
   tries to tidy up features which would normally lead to a parse error.
</p>
<hr>
<a name="gt_gff3_parser_parse_genome_nodes"></a>

<code>int            gt_gff3_parser_parse_genome_nodes(GtGFF3Parser *gff3_parser,
                                                int *status_code,
                                                GtQueue *genome_nodes,
                                                GtCstrTable *used_types,
                                                GtStr *filenamestr,
                                                unsigned long long *line_number,
                                                GtFile *fpin,
                                                GtError *err)</code>
<p>
Use <code>gff3_parser</code> to parse genome nodes from file pointer <code>fpin</code>.
   <code>status_code</code> is set to 0 if at least one genome node was created (and stored
   in <code>genome_nodes</code>) and to <code>EOF</code> if no further genome nodes could be parsed
   from <code>fpin</code>. Every encountered (genome feature) type is recorded in the
   C string table <code>used_types</code>. The parser uses the given <code>filenamestr</code> to
   store the file name of <code>fpin</code> in the created genome nodes or to give the
   correct filename in error messages, if necessary.
   <code>line_number</code> is increased accordingly during parsing and has to be set to 0
   before parsing a new <code>fpin</code>.
   If an error occurs during parsing this method returns -1 and sets <code>err</code>
   accordingly.
</p>
<hr>
<a name="gt_gff3_parser_reset"></a>

<code>void           gt_gff3_parser_reset(GtGFF3Parser *gff3_parser)</code>
<p>
Reset the <code>gff3_parser</code> (necessary if the input file is switched).
</p>
<hr>
<a name="gt_gff3_parser_delete"></a>

<code>void           gt_gff3_parser_delete(GtGFF3Parser *gff3_parser)</code>
<p>
Delete the <code>gff3_parser</code>.
</p>
<hr>
<a name="GtGFF3Visitor"></a>
<h2>Class GtGFF3Visitor</h2>

<p> Implements the <code>GtNodeVisitor</code> interface with a visitor that produces GFF3
   output. This is a low-level class and it is usually not used directly.
   Normally, a <code>GtGFF3OutStream</code> is used to produce GFF3 output. </p>

<hr>
<a name="gt_gff3_visitor_new"></a>

<code>GtNodeVisitor*  gt_gff3_visitor_new(GtFile *outfp)</code>
<p>
Create a new <code>GtNodeVisitor*</code> which writes the output it produces to the
   given output file pointer <code>outfp</code>. If <code>outfp</code> is <code>NULL</code>, the output is
   written to <code>stdout</code>.
</p>
<hr>
<a name="gt_gff3_visitor_set_fasta_width"></a>

<code>void            gt_gff3_visitor_set_fasta_width(GtGFF3Visitor *gff3_visitor,
                                               unsigned long fasta_width)</code>
<p>
Set the width with which the FASTA sequences of <code>GtSequenceNode</code>s visited
   by <code>gff3_visitor</code> are shown to <code>fasta_width</code>.
   Per default, each FASTA entry is shown on a single line.
</p>
<hr>
<a name="gt_gff3_visitor_retain_id_attributes"></a>

<code>void            gt_gff3_visitor_retain_id_attributes(GtGFF3Visitor
                                                    *gff3_visitor)</code>
<p>
Retain the original ID attributes (instead of creating new ones), if
   possible.  Memory consumption for <code>gff3_visitor</code> is raised from O(1) to
   O(<code>input_size</code>), because bookkeeping of used IDs becomes necessary to avoid
   ID collisions.
</p>
<hr>
<a name="GtGTFInStream"></a>
<h2>Class GtGTFInStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGTFInStream</code> parses a GTF2.2
   file and returns it as a stream of <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_gtf_in_stream_new"></a>

<code>GtNodeStream*  gt_gtf_in_stream_new(const char *filename)</code>
<p>
Create a <code>GtGTFInStream*</code> which subsequently reads the GTF file with the
   given <code>filename</code>. If <code>filename</code> equals <code>NULL</code>, the GTF data is read from
   <code>stdin</code>.
</p>
<hr>
<a name="GtGTFOutStream"></a>
<h2>Class GtGTFOutStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtGTFOutStream</code> produces GTF2.2
   output. </p>

<hr>
<a name="gt_gtf_out_stream_new"></a>

<code>GtNodeStream*  gt_gtf_out_stream_new(GtNodeStream *in_stream, GtFile *outfp)</code>
<p>
Create a <code>GtNodeStream*</code> which uses <code>in_stream</code> as input.
   It shows the nodes passed through it as GTF2.2 on <code>outfp</code>.
</p>
<hr>
<a name="GtGenomeNode"></a>
<h2>Class GtGenomeNode</h2>

<p> The <code>GtGenomeNode</code> interface. The different implementation of the
   <code>GtGenomeNode</code> interface represent different parts of genome annotations (as
   they are usually found in GFF3 files). </p>

<hr>
<a name="gt_genome_node_ref"></a>

<code>GtGenomeNode*  gt_genome_node_ref(GtGenomeNode *genome_node)</code>
<p>
Increase the reference count for <code>genome_node</code> and return it.
   <code>genome_node</code> cannot be <code>NULL</code>.
</p>
<hr>
<a name="gt_genome_node_get_seqid"></a>

<code>GtStr*         gt_genome_node_get_seqid(GtGenomeNode *genome_node)</code>
<p>
Return the sequence ID of <code>genome_node</code>.
   Corresponds to column 1 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_range"></a>

<code>GtRange        gt_genome_node_get_range(GtGenomeNode *genome_node)</code>
<p>
Return the genomic range of of <code>genome_node</code>.
   Corresponds to columns 4 and 5 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_start"></a>

<code>unsigned long  gt_genome_node_get_start(GtGenomeNode *genome_node)</code>
<p>
Return the start of <code>genome_node</code>.
   Corresponds to column 4 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_end"></a>

<code>unsigned long  gt_genome_node_get_end(GtGenomeNode *genome_node)</code>
<p>
Return the end of <code>genome_node</code>.
   Corresponds to column 5 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_length"></a>

<code>unsigned long  gt_genome_node_get_length(GtGenomeNode *genome_node)</code>
<p>
Return the length of <code>genome_node</code>.
   Computed from column 4 and 5 of GFF3 feature lines.
</p>
<hr>
<a name="gt_genome_node_get_filename"></a>

<code>const char*    gt_genome_node_get_filename(const GtGenomeNode* genome_node)</code>
<p>
Return the filename the <code>genome_node</code> was read from.
   If the node did not originate from a file, an appropriate string is
   returned.
</p>
<hr>
<a name="gt_genome_node_get_line_number"></a>

<code>unsigned int   gt_genome_node_get_line_number(const GtGenomeNode*)</code>
<p>
Return the line of the source file the <code>genome_node</code> was encountered on
   (if the node was read from a file, otherwise 0 is returned).
</p>
<hr>
<a name="gt_genome_node_set_range"></a>

<code>void           gt_genome_node_set_range(GtGenomeNode *genome_node,
                                       const GtRange *range)</code>
<p>
Set the genomic range of <code>genome_node</code> to given <code>range</code>.
</p>
<hr>
<a name="gt_genome_node_add_user_data"></a>

<code>void           gt_genome_node_add_user_data(GtGenomeNode *genome_node,
                                           const char *key, void *data,
                                           GtFree free_func)</code>
<p>
Attach a pointer to <code>data</code> to the <code>genome_node</code> using a given string as
   <code>key</code>. <code>free_func</code> is the optional destructor for <code>data</code>.
</p>
<hr>
<a name="gt_genome_node_get_user_data"></a>

<code>void*          gt_genome_node_get_user_data(const GtGenomeNode *genome_node,
                                           const char *key)</code>
<p>
Return the pointer attached to the <code>genome_node</code> for a given <code>key</code>.
</p>
<hr>
<a name="gt_genome_node_release_user_data"></a>

<code>void           gt_genome_node_release_user_data(GtGenomeNode *genome_node,
                                               const char *key)</code>
<p>
Call the destructor function associated with the user data attached to
   <code>genome_node</code> under the <code>key</code> on the attached data.
</p>
<hr>
<a name="gt_genome_node_cmp"></a>

<code>int            gt_genome_node_cmp(GtGenomeNode *genome_node_a,
                                 GtGenomeNode *genome_node_b)</code>
<p>
Compare <code>genome_node_a</code> with <code>genome_node_b</code> and return the result (similar
   to <code>strcmp(3)</code>). This method is the criterion used to sort genome nodes.
</p>
<hr>
<a name="gt_genome_node_accept"></a>

<code>int            gt_genome_node_accept(GtGenomeNode *genome_node,
                                    GtNodeVisitor *node_visitor, GtError *err)</code>
<p>
Let <code>genome_node</code> accept the <code>node_visitor</code>.
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_genome_node_delete"></a>

<code>void           gt_genome_node_delete(GtGenomeNode *genome_node)</code>
<p>
Decrease the reference count for <code>genome_node</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtGraphics"></a>
<h2>Class GtGraphics</h2>

<p> The <code>GtGraphics</code> interface acts as a low-level abstraction of a drawing
   surface. It is used as a common drawing object in <code>GtCanvas</code> and
   <code>GtCustomTrack</code> implementations and supports a variety of drawing operations
   for both text and basic primitive shapes. </p>

<hr>
<a name="gt_graphics_draw_text"></a>

<code>void    gt_graphics_draw_text(GtGraphics*, double x, double y, const char*)</code>
<p>
Draws text in black to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as
   a baseline.
</p>
<hr>
<a name="gt_graphics_draw_text_clip"></a>

<code>void    gt_graphics_draw_text_clip(GtGraphics*, double x, double y, const char*)</code>
<p>
Draws text in black to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as
   a baseline. If the text exceeds the margins, it is clipped.
</p>
<hr>
<a name="gt_graphics_draw_text_left"></a>

<code>#define gt_graphics_draw_text_left(g,x,y,t)</code>
<p>
Synonym to <code>gt_graphics_draw_text()</code>
</p>
<hr>
<a name="gt_graphics_draw_text_centered"></a>

<code>void    gt_graphics_draw_text_centered(GtGraphics*, double x, double y,
                                      const char*)</code>
<p>
Draws text in black centered at (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as a
   baseline.
</p>
<hr>
<a name="gt_graphics_draw_text_right"></a>

<code>void    gt_graphics_draw_text_right(GtGraphics*, double x, double y,
                                   const char*)</code>
<p>
Draws text in black to the left of (<code>x</code>,<code>y</code>). The coordinate <code>y</code> is used as a
   baseline.
</p>
<hr>
<a name="gt_graphics_draw_colored_text"></a>

<code>void    gt_graphics_draw_colored_text(GtGraphics*, double x, double y,
                                     GtColor, const char*)</code>
<p>
Draws text in a given <code>GtColor</code> to the right of (<code>x</code>,<code>y</code>). The coordinate <code>y</code>
   is used as a baseline.
</p>
<hr>
<a name="gt_graphics_get_text_height"></a>

<code>double  gt_graphics_get_text_height(GtGraphics*)</code>
<p>
Returns the height of a capital letter in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_background_color"></a>

<code>int  gt_graphics_set_background_color(GtGraphics*, GtColor)</code>
<p>
Sets the background color of the <code>GtGraphics</code> to a specific color.
   Note that this may only be supported for bitmap output formats.
</p>
<hr>
<a name="gt_graphics_get_text_width"></a>

<code>double  gt_graphics_get_text_width(GtGraphics*, const char *text)</code>
<p>
Returns the width of the given string in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_font"></a>

<code>void    gt_graphics_set_font(GtGraphics *g, const char *family,
                            FontSlant slant, FontWeight weight, double size)</code>
<p>
Sets basic font family, slant and weight options. Font families are
   implementation-specific, e.g. in Cairo there is no operation to list
   available family names on the system, but the standard CSS2 generic family
   names, ("serif", "sans-serif", "cursive", "fantasy", "monospace"), are
   likely to work as expected.
</p>
<hr>
<a name="gt_graphics_get_image_width"></a>

<code>double  gt_graphics_get_image_width(GtGraphics*)</code>
<p>
Returns the width of the image in pixels/points.
</p>
<hr>
<a name="gt_graphics_get_image_height"></a>

<code>double  gt_graphics_get_image_height(GtGraphics*)</code>
<p>
Returns the height of the image in pixels/points.
</p>
<hr>
<a name="gt_graphics_set_margins"></a>

<code>void    gt_graphics_set_margins(GtGraphics*, double margin_x,
                                  double margin_y)</code>
<p>
Set margins (space to the image boundaries that are clear of elements)
   in the graphics.
   <code>margin_x</code> denotes the Margin to the left and right, in pixels.
   <code>margin_y</code> denotes the Margin to the top and bottom, in pixels.
</p>
<hr>
<a name="gt_graphics_get_xmargins"></a>

<code>double  gt_graphics_get_xmargins(GtGraphics*)</code>
<p>
Returns the horizontal margins in pixels/points.
</p>
<hr>
<a name="gt_graphics_get_ymargins"></a>

<code>double  gt_graphics_get_ymargins(GtGraphics*)</code>
<p>
Returns the vertical margins in pixels/points.
</p>
<hr>
<a name="gt_graphics_draw_horizontal_line"></a>

<code>void    gt_graphics_draw_horizontal_line(GtGraphics *g, double x, double y,
                                        GtColor color, double width,
                                        double stroke_width)</code>
<p>
Draws a horizontal line of length <code>width</code> beginning at the given coordinates
   to the right in the color <code>color</code> with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_vertical_line"></a>

<code>void    gt_graphics_draw_vertical_line(GtGraphics *g, double x, double y,
                                      GtColor color, double length,
                                      double stroke_width)</code>
<p>
Draws a vertical line of length <code>length</code> beginning at the given coordinates
   downwards in the color <code>color</code> with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_line"></a>

<code>void    gt_graphics_draw_line(GtGraphics *g, double x, double y,
                             double xto, double yto, GtColor color,
                             double stroke_width)</code>
<p>
Draws a line beginning at (<code>x</code>,<code>y</code>) to (<code>xto</code>,<code>yto</code>) in the color <code>color</code>
   with stroke width <code>stroke_width</code>.
</p>
<hr>
<a name="gt_graphics_draw_box"></a>

<code>void    gt_graphics_draw_box(GtGraphics*, double x, double y, double width,
                            double height, GtColor fill_color,
                            ArrowStatus arrow_status, double arrow_width,
                            double stroke_width, GtColor stroke_color,
                            bool dashed)</code>
<p>
Draws a arrow-like box glyph at (<code>x</code>,<code>y</code>) where these are the top left
   coordinates. The box extends <code>width</code> pixels (incl. arrowhead) into the x
   direction and <code>height</code> pixels into the y direction. It will be filled with
   <code>fill_color</code> and stroked with width <code>stroke_width</code> and color <code>stroke_color</code>.
   The width of the arrowhead is given by the <code>arrow_width</code> parameter.
   The <code>arrow_status</code> parameter determines whether an arrowhead will be drawn
   at the left or right end, both ends, or none.
   If <code>dashed</code> is set to true, then the outline will be dashed instead of
   solid.
</p>
<hr>
<a name="gt_graphics_draw_dashes"></a>

<code>void    gt_graphics_draw_dashes(GtGraphics*, double x, double y,
                                  double width, double height,
                                  ArrowStatus arrow_status, double arrow_width,
                                  double stroke_width, GtColor stroke_color)</code>
<p>
Draws a transparent box with a dashed line at the center at (<code>x</code>,<code>y</code>)
   (where these are the top left coordinates). The box extends <code>width</code> pixels
   (incl. arrowhead) into the x direction and <code>height</code> pixels into the y
   direction. It will be stroked with width <code>stroke_width</code> and color
   <code>stroke_color</code>. The width of the arrowhead is given by the <code>arrow_width</code>
   parameter. The <code>arrow_status</code> parameter determines whether an arrowhead will
   be drawn at the left or right end, both ends, or none.
</p>
<hr>
<a name="gt_graphics_draw_caret"></a>

<code>void    gt_graphics_draw_caret(GtGraphics*, double x, double y, double width,
                              double height, ArrowStatus arrow_status,
                              double arrow_width,  double stroke_width,
                              GtColor stroke_color)</code>
<p>
Draws a caret (``hat'') style glyph at (<code>x</code>,<code>y</code>) (where these are the top
   left coordinates). The box extends <code>width</code> pixels (incl. arrowhead) into the
   x direction and <code>height</code> pixels into the y direction. It will be stroked
   with width <code>stroke_width</code> and color <code>stroke_color</code>. The width of the
   arrowhead is given by the <code>arrow_width</code> parameter. The <code>arrow_status</code>
   parameter determines whether an arrowhead will be drawn at the left or right
   end, both ends, or none.
</p>
<hr>
<a name="gt_graphics_draw_rectangle"></a>

<code>void    gt_graphics_draw_rectangle(GtGraphics*, double x, double y,
                                  bool filled, GtColor fill_color,
                                  bool stroked, GtColor stroke_color,
                                  double stroke_width, double width,
                                  double height)</code>
<p>
Draws a rectangle at (<code>x</code>,<code>y</code>) where these are the top left coordinates.
   The rectangle extends <code>width</code> pixels (incl. arrowhead) into the x
   direction and <code>height</code> pixels into the y direction. It will be filled with
   <code>fill_color</code> if <code>filled</code> is set to true and stroked with width <code>stroke_width</code>
   and color <code>stroke_color</code> if <code>stroked</code> is set to true.
</p>
<hr>
<a name="gt_graphics_draw_arrowhead"></a>

<code>void    gt_graphics_draw_arrowhead(GtGraphics*, double x, double y, GtColor,
                                  ArrowStatus arrow_status)</code>
<p>
Draws an arrowhead at (<code>x</code>,<code>y</code>) where these are the top left coordinates.
   The direction is determined by the <code>arrow_status</code> parameter.
</p>
<hr>
<a name="gt_graphics_draw_curve_data"></a>

<code>void    gt_graphics_draw_curve_data(GtGraphics *g, double x, double y,
                                   GtColor color,
                                   double data[], unsigned long ndata,
                                   GtRange valrange, unsigned long height)</code>
<p>
Draws a curve over the full visible image width (without margins) at
   (<code>x</code>,<code>y</code>) where these are the top left coordinates. As input, the array of
   double values <code>data</code> with <code>ndata</code> data points is used. The <code>valrange</code> gives
   the minimum and maximum value of the displayed data. If a value outside the
   data range is encountered, the drawing will be stopped at this data point.
</p>
<hr>
<a name="gt_graphics_save_to_file"></a>

<code>int     gt_graphics_save_to_file(const GtGraphics*, const char *filename,
                                GtError*)</code>
<p>
Write out the <code>GtGraphics</code> object to the given file with <code>filename</code>.
</p>
<hr>
<a name="gt_graphics_save_to_stream"></a>

<code>void    gt_graphics_save_to_stream(const GtGraphics*, GtStr *stream)</code>
<p>
Write out the <code>GtGraphics</code> object to the given <code>stream</code>.
</p>
<hr>
<a name="gt_graphics_delete"></a>

<code>void    gt_graphics_delete(GtGraphics*)</code>
<p>
Deletes the the <code>GtGraphics</code> object.
</p>
<hr>
<a name="GtHashmap"></a>
<h2>Class GtHashmap</h2>

<p> A hashmap allowing to index any kind of pointer (as a value). As keys,
   strings or any other pointer can be used. </p>

<hr>
<a name="gt_hashmap_new"></a>

<code>GtHashmap*  gt_hashmap_new(GtHashType keyhashtype, GtFree keyfree,
                          GtFree valuefree)</code>
<p>
Creates a new <code>GtHashmap</code> object of type <code>keyhashtype</code>. If <code>keyfree</code> and/or
   <code>valuefree</code> are given, they will be used to free the hashmap members
   when the <code>GtHashmap</code> is deleted. <code>keyhashtype</code> defines how to hash the
   keys given when using the <code>GtHashmap</code>.
   <code>GT_HASH_DIRECT</code> uses the key pointer as a basis for the hash function.
   Equal pointers will refer to the same value. If <code>GT_HASH_STRING</code> is used, the
   keys will be  evaluated as strings and keys will be considered equal if the
   strings are identical, regardless of their address in memory
</p>
<hr>
<a name="gt_hashmap_get"></a>

<code>void*       gt_hashmap_get(GtHashmap *hashmap, const void *key)</code>
<p>
Return the value stored in <code>hashmap</code> for <code>key</code> or <code>NULL</code> if no such key
   exists.
</p>
<hr>
<a name="gt_hashmap_add"></a>

<code>void        gt_hashmap_add(GtHashmap *hashmap, void *key, void *value)</code>
<p>
Set the value stored in <code>hashmap</code> for <code>key</code> to <code>value</code>, overwriting the prior
   value for that key if present.
</p>
<hr>
<a name="gt_hashmap_remove"></a>

<code>void        gt_hashmap_remove(GtHashmap *hashmap, const void *key)</code>
<p>
Remove the member with key <code>key</code> from <code>hashmap</code>.
</p>
<hr>
<a name="gt_hashmap_foreach_ordered"></a>

<code>int         gt_hashmap_foreach_ordered(GtHashmap *hashmap,
                                      GtHashmapVisitFunc func,
                                      void *data, GtCompare cmp, GtError*)</code>
<p>
Iterate over <code>hashmap</code> in order given by compare function <code>cmp</code>.
   For each member, <code>func</code> is called (see interface).
</p>
<hr>
<a name="gt_hashmap_foreach"></a>

<code>int         gt_hashmap_foreach(GtHashmap *hashmap, GtHashmapVisitFunc func,
                              void *data, GtError*)</code>
<p>
Iterate over <code>hashmap</code> in arbitrary order given by compare function <code>cmp</code>.
   For each member, <code>func</code> is called (see interface).
</p>
<hr>
<a name="gt_hashmap_foreach_in_key_order"></a>

<code>int         gt_hashmap_foreach_in_key_order(GtHashmap *hashmap,
                                           GtHashmapVisitFunc func,
                                           void *data, GtError*)</code>
<p>
Iterate over <code>hashmap</code> in either alphabetical order (if <code>GtHashType</code> was
   specified as <code>GT_HASH_STRING</code>) or numerical order (if <code>GtHashType</code> was
   specified as <code>GT_HASH_DIRECT</code>).
</p>
<hr>
<a name="gt_hashmap_reset"></a>

<code>void        gt_hashmap_reset(GtHashmap *hashmap)</code>
<p>
Reset <code>hashmap</code> by unsetting values for all keys, calling the free function
   if necessary.
</p>
<hr>
<a name="gt_hashmap_delete"></a>

<code>void        gt_hashmap_delete(GtHashmap *hashmap)</code>
<p>
Delete <code>hashmap</code>, calling the free function if necessary.
</p>
<hr>
<a name="GtIDToMD5Stream"></a>
<h2>Class GtIDToMD5Stream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtIDToMD5Stream</code> converts
   ``regular'' sequence IDs to MD5 fingerprints. </p>

<hr>
<a name="gt_id_to_md5_stream_new"></a>

<code>GtNodeStream*  gt_id_to_md5_stream_new(GtNodeStream *in_stream,
                                      GtRegionMapping *region_mapping,
                                      bool substitute_target_ids)</code>
<p>
Create a <code>GtIDToMD5Stream</code> object which converts ``regular'' sequence IDs
   from nodes it retrieves from its <code>in_stream</code> to MD5 fingerprints (with the
   help of the given <code>region_mapping</code>). If <code>substitute_target_ids</code> is true, the
   IDs of Target attributes are also converted to MD5 fingerprints.
   Takes ownership of <code>region_mapping</code>!
</p>
<hr>
<a name="GtImageInfo"></a>
<h2>Class GtImageInfo</h2>

<p> The <code>GtImageInfo</code> class is a container for 2D coordinate to <code>GtFeatureNode</code>
   mappings which could, for example, be used to associate sections of a
   rendered image with GUI widgets or HTML imagemap areas. This information is
   given in the form of <code>GtRecMap</code> objects. They are created during the
   image rendering process and stored inside a <code>GtImageInfo</code> object for later
   retrieval. Additionally, the rendered width of an image can be obtained via
   a <code>GtImageInfo</code> method. </p>

<hr>
<a name="gt_image_info_new"></a>

<code>GtImageInfo*      gt_image_info_new(void)</code>
<p>
Creates a new <code>GtImageInfo</code> object.
</p>
<hr>
<a name="gt_image_info_get_height"></a>

<code>unsigned int      gt_image_info_get_height(GtImageInfo *image_info)</code>
<p>
Returns the height of the rendered image (in pixels or points).
</p>
<hr>
<a name="gt_image_info_num_of_rec_maps"></a>

<code>unsigned long     gt_image_info_num_of_rec_maps(GtImageInfo *image_info)</code>
<p>
Returns the total number of mappings in <code>image_info</code>.
</p>
<hr>
<a name="gt_image_info_get_rec_map"></a>

<code>const GtRecMap*   gt_image_info_get_rec_map(GtImageInfo *image_info,
                                           unsigned long i)</code>
<p>
Returns the <code>i</code>-th <code>GtRecMap</code> mapping in <code>image_info</code>.
</p>
<hr>
<a name="gt_image_info_delete"></a>

<code>void              gt_image_info_delete(GtImageInfo *image_info)</code>
<p>
Deletes <code>image_info</code> and all the <code>GtRecMap</code> objects created by it.
</p>
<hr>
<a name="GtInterFeatureStream"></a>
<h2>Class GtInterFeatureStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtInterFeatureStream</code> inserts new
   feature nodes between existing feature nodes of a certain type. </p>

<hr>
<a name="gt_inter_feature_stream_new"></a>

<code>GtNodeStream*  gt_inter_feature_stream_new(GtNodeStream *in_stream,
                                          const char *outside_type,
                                          const char *inter_type)</code>
<p>
Create a <code>GtInterFeatureStream*</code> which inserts feature nodes of type
   <code>inter_type</code> between the feature nodes of type <code>outside_type</code> it retrieves
   from <code>in_stream</code> and returns them.
</p>
<hr>
<a name="GtIntervalTree"></a>
<h2>Class GtIntervalTree</h2>

<p> This is an interval tree data structure, implemented according to
   Cormen et al., Introduction to Algorithms, 2nd edition, MIT Press,
   Cambridge, MA, USA, 2001 </p>

<hr>
<a name="gt_interval_tree_new"></a>

<code>GtIntervalTree*      gt_interval_tree_new(GtFree)</code>
<p>
Creates a new <code>GtIntervalTree</code>. If a <code>GtFree</code> function is given as an
   argument, it is applied on the data pointers in all inserted nodes when the
   <code>GtIntervalTree</code> is deleted.
</p>
<hr>
<a name="gt_interval_tree_size"></a>

<code>unsigned long        gt_interval_tree_size(GtIntervalTree*)</code>
<p>
Returns the number of elements in the <code>GtIntervalTree</code>.
</p>
<hr>
<a name="gt_interval_tree_find_first_overlapping"></a>

<code>GtIntervalTreeNode*  gt_interval_tree_find_first_overlapping(GtIntervalTree*,
                                                            unsigned long start,
                                                            unsigned long end)</code>
<p>
Returns the first node in the <code>GtIntervalTree</code> which overlaps the given
   range (from <code>start</code> to <code>end</code>).
</p>
<hr>
<a name="gt_interval_tree_insert"></a>

<code>void                 gt_interval_tree_insert(GtIntervalTree *tree,
                                            GtIntervalTreeNode *node)</code>
<p>
Inserts node <code>node</code> into <code>tree</code>.
</p>
<hr>
<a name="gt_interval_tree_find_all_overlapping"></a>

<code>void                 gt_interval_tree_find_all_overlapping(GtIntervalTree*,
                                                          unsigned long start,
                                                          unsigned long end,
                                                          GtArray*)</code>
<p>
Collects data pointers of all <code>GtIntervalTreeNode</code>s in the tree which
   overlapp with the query range (from <code>start</code> to <code>end</code>) in a <code>GtArray</code>.
</p>
<hr>
<a name="gt_interval_tree_traverse"></a>

<code>int                  gt_interval_tree_traverse(GtIntervalTree*,
                                              GtIntervalTreeIteratorFunc func,
                                              void *data)</code>
<p>
Traverses the <code>GtIntervalTree</code> in a depth-first fashion, applying <code>func</code> to
   each node encountered. The <code>data</code> pointer can be used to reference arbitrary
   data needed in the <code>GtIntervalTreeIteratorFunc</code>.
</p>
<hr>
<a name="gt_interval_tree_delete"></a>

<code>void                 gt_interval_tree_delete(GtIntervalTree*)</code>
<p>
Deletes a <code>GtIntervalTree</code>. If a <code>GtFree</code> function was set in the tree
   constructor, data pointers specified in the nodes are freed using the given
   <code>GtFree</code> function.
</p>
<hr>
<a name="GtIntervalTreeNode"></a>
<h2>Class GtIntervalTreeNode</h2>
<a name="gt_interval_tree_node_new"></a>

<code>GtIntervalTreeNode*  gt_interval_tree_node_new(void *data,
                                              unsigned long low,
                                              unsigned long high)</code>
<p>
Creates a new <code>GtIntervalTreeNode</code>. Transfers ownership of <code>data</code> to interval
   tree if inserted into a <code>GtIntervalTree</code> in which a
   <code>GtIntervalTreeDataFreeFunc</code> is set.
</p>
<hr>
<a name="gt_interval_tree_node_get_data"></a>

<code>void*                gt_interval_tree_node_get_data(GtIntervalTreeNode* node)</code>
<p>
Returns a pointer to the data associated with node <code>node</code>.
</p>
<hr>
<a name="GtLayout"></a>
<h2>Class GtLayout</h2>

<p> The <code>GtLayout</code> class represents contents (tracks) of a <code>GtDiagram</code> broken up
   into lines such that a given horizontal space allotment given in pixels
   or points is used up most efficiently. This is done using the <code>GtLineBreaker</code>
   and <code>GtTextWidthCalculator</code> classes. As defaults, Cairo-based instances of
   these classes are used but can be specified separately.</p><p>   A <code>GtLayout</code> can be queried for the height of the laid out representation and
   finally be rendered to a <code>GtCanvas</code>. </p>

<hr>
<a name="gt_layout_new"></a>

<code>GtLayout*      gt_layout_new(GtDiagram *diagram, unsigned int width, GtStyle*,
                            GtError*)</code>
<p>
Creates a new <code>GtLayout</code> object for the contents of <code>diagram</code>.
   The layout is done for a target image width of <code>width</code> and using the rules in
   <code>GtStyle</code> object <code>style</code>.
</p>
<hr>
<a name="gt_layout_new_with_twc"></a>

<code>GtLayout*      gt_layout_new_with_twc(GtDiagram*,
                                     unsigned int width,
                                     GtStyle*,
                                     GtTextWidthCalculator*,
                                     GtError*)</code>
<p>
Like <code>gt_layout_new()</code>, but allows use of a different <code>GtTextWidthCalculator</code>
   implementation.
</p>
<hr>
<a name="gt_layout_set_track_ordering_func"></a>

<code>void           gt_layout_set_track_ordering_func(GtLayout *layout,
                                                GtTrackOrderingFunc func,
                                                void *data)</code>
<p>
Sets the <code>GtTrackOrderingFunc</code> comparator function <code>func</code> which defines an
   order on the tracks contained in <code>layout</code>. This determines the order in
   which the tracks are drawn vertically.
   Additional data necessary in the comparator function can be given in <code>data</code>,
   the caller is responsible to free it.
</p>
<hr>
<a name="gt_layout_get_height"></a>

<code>int            gt_layout_get_height(const GtLayout *layout,
                                   unsigned long *result,
                                   GtError *err)</code>
<p>
Calculates the height of <code>layout</code> in pixels. The height value is written to
   the location pointed to by <code>result</code>. If an error occurs during the
   calculation, this function returns -1 and <code>err</code> is set accordingly.
   Returns 0 on success.
</p>
<hr>
<a name="gt_layout_sketch"></a>

<code>int            gt_layout_sketch(GtLayout *layout, GtCanvas *target_canvas,
                               GtError*)</code>
<p>
Renders <code>layout</code> on the <code>target_canvas</code>.
</p>
<hr>
<a name="gt_layout_delete"></a>

<code>void           gt_layout_delete(GtLayout*)</code>
<p>
Destroys a layout.
</p>
<hr>
<a name="GtLogger"></a>
<h2>Class GtLogger</h2>
<a name="gt_logger_new"></a>

<code>GtLogger*  gt_logger_new(bool enabled, const char *prefix, FILE *target)</code>
<p>
Creates a new <code>GtLogger</code>, with logging <code>enabled</code> or not,
   and prefixing all log entries with <code>prefix</code> (e.g. "debug").
   The log output is terminated by a newline. All log output will
   be written to <code>target</code>.
</p>
<hr>
<a name="gt_logger_enable"></a>

<code>void       gt_logger_enable(GtLogger *logger)</code>
<p>
Enable logging on <code>logger</code>.
</p>
<hr>
<a name="gt_logger_disable"></a>

<code>void       gt_logger_disable(GtLogger *logger)</code>
<p>
Disable logging on <code>logger</code>.
</p>
<hr>
<a name="gt_logger_enabled"></a>

<code>bool       gt_logger_enabled(GtLogger *logger)</code>
<p>
Return <code>true</code> if logging is enabled on <code>logger</code>, false otherwise.
</p>
<hr>
<a name="gt_logger_target"></a>

<code>FILE*      gt_logger_target(GtLogger *logger)</code>
<p>
Return logging target of <code>logger</code>.
</p>
<hr>
<a name="gt_logger_set_target"></a>

<code>void       gt_logger_set_target(GtLogger *logger, FILE *fp)</code>
<p>
Set logging target of <code>logger</code> to <code>fp</code>.
</p>
<hr>
<a name="gt_logger_log_force"></a>

<code>void       gt_logger_log_force(GtLogger *logger, const char *format, ...)</code>
<p>
Log to target regardless of logging status.
</p>
<hr>
<a name="gt_logger_log"></a>

<code>void       gt_logger_log(GtLogger *logger, const char *format, ...)</code>
<p>
Log to target depending on logging status.
</p>
<hr>
<a name="gt_logger_log_va_force"></a>

<code>void       gt_logger_log_va_force(GtLogger *logger, const char *format, va_list)</code>
<p>
Log to target regardless of logging status, using a va_list argument.
</p>
<hr>
<a name="gt_logger_log_va"></a>

<code>void       gt_logger_log_va(GtLogger *logger, const char *format, va_list)</code>
<p>
Log to target depending on logging status, using a va_list argument.
</p>
<hr>
<a name="gt_logger_delete"></a>

<code>void       gt_logger_delete(GtLogger *logger)</code>
<p>
Delete <code>logger</code>.
</p>
<hr>
<a name="GtMD5ToIDStream"></a>
<h2>Class GtMD5ToIDStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtMD5ToIDStream</code> converts MD5
   fingerprints used as sequence IDs to ``regular'' ones. </p>

<hr>
<a name="gt_md5_to_id_stream_new"></a>

<code>GtNodeStream*  gt_md5_to_id_stream_new(GtNodeStream *in_stream,
                                      GtRegionMapping *region_mapping)</code>
<p>
Create a <code>GtMD5toIDStream*</code> which converts MD5 sequence IDs from nodes it
   retrieves from its <code>in_stream</code> to ``regular'' ones (with the help of the
   given <code>region_mapping</code>). Takes ownership of <code>region_mapping</code>!
</p>
<hr>
<a name="GtMergeFeatureStream"></a>
<h2>Class GtMergeFeatureStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtMergeFeatureStream</code> merges
   adjacent features of the same type. </p>

<hr>
<a name="gt_merge_feature_stream_new"></a>

<code>GtNodeStream*  gt_merge_feature_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtMergeFeatureStream*</code> which merges adjacent features of the same
   type it retrieves from <code>in_stream</code> and returns them (and all other unmodified
   features).
</p>
<hr>
<a name="GtMergeStream"></a>
<h2>Class GtMergeStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtMergeStream</code> allows to merge a
   set of sorted streams in a sorted fashion. </p>

<hr>
<a name="gt_merge_stream_new"></a>

<code>GtNodeStream*  gt_merge_stream_new(const GtArray *node_streams)</code>
<p>
Create a <code>GtMergeStream*</code> which merges the given (sorted) <code>node_streams</code> in a
   sorted fashion.
</p>
<hr>
<a name="GtNodeStream"></a>
<h2>Class GtNodeStream</h2>

<p> The <code>GtNodeStream</code> interface. <code>GtNodeStream</code> objects process <code>GtGenomeNode</code>
   objects in a pull-based architecture and can be chained together. </p>

<hr>
<a name="gt_node_stream_ref"></a>

<code>GtNodeStream*  gt_node_stream_ref(GtNodeStream *node_stream)</code>
<p>
Increase the reference count for <code>node_stream</code> and return it.
</p>
<hr>
<a name="gt_node_stream_next"></a>

<code>int            gt_node_stream_next(GtNodeStream *node_stream,
                                  GtGenomeNode **genome_node,
                                  GtError *err)</code>
<p>
Try to get the the next <code>GtGenomeNode</code> from <code>node_stream</code> and store it in
   <code>genome_node</code> (transfers ownership to <code>genome_node</code>).
   If no error occurs, 0 is returned and <code>genome_node</code> contains either the next
   <code>GtGenomeNode</code> or <code>NULL</code>, if the <code>node_stream</code> is exhausted.
   If an error occurs, -1 is returned and <code>err</code> is set accordingly (the status
   of <code>genome_node</code> is undefined, but no ownership transfer occured).
</p>
<hr>
<a name="gt_node_stream_pull"></a>

<code>int            gt_node_stream_pull(GtNodeStream *node_stream, GtError *err)</code>
<p>
Calls <code>gt_node_stream_next()</code> on <code>node_stream</code> repeatedly until the
   <code>node_stream</code> is exhausted (0 is returned) or an error occurs (-1 is returned
   and <code>err</code> is set). All retrieved <code>GtGenomeNode</code>s are deleted automatically
   with calls to <code>gt_genome_node_delete()</code>.
   This method is basically a convenience method which simplifies calls to
   <code>gt_node_stream_next()</code> in a loop where the retrieved <code>GtGenomeNode</code> objects
   are not processed any further.
</p>
<hr>
<a name="gt_node_stream_is_sorted"></a>

<code>bool           gt_node_stream_is_sorted(GtNodeStream *node_stream)</code>
<p>
Return <code>true</code> if <code>node_stream</code> is a sorted stream, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_node_stream_delete"></a>

<code>void           gt_node_stream_delete(GtNodeStream *node_stream)</code>
<p>
Decrease the reference count for <code>node_stream</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="gt_node_stream_create"></a>

<code>GtNodeStream*       gt_node_stream_create(const GtNodeStreamClass
                                         *node_stream_class,
                                         bool ensure_sorting)</code>
<p>
Create a new object of the given <code>node_stream_class</code>. If <code>ensure_sorting</code> is
   <code>true</code>, it is enforced that all genome node objects pulled from this class
   are sorted. That is, for consecutive nodes <code>a</code> and <code>b</code> obtained from the
   given <code>node_stream_class</code> the return code of <code>gt_genome_node_compare(a,b)</code>
   has to be smaller or equal than 0. If this condition is not met, an assertion
   fails.
</p>
<hr>
<a name="gt_node_stream_cast"></a>

<code>void*               gt_node_stream_cast(const GtNodeStreamClass
                                       *node_stream_class,
                                       GtNodeStream *node_stream)</code>
<p>
Cast <code>node_stream</code> to the given <code>node_stream_class</code>.
   That is, if <code>node_stream</code> is not from the given <code>node_stream_class</code>, an
   assertion will fail.
</p>
<hr>
<a name="GtNodeStreamClass"></a>
<h2>Class GtNodeStreamClass</h2>
<a name="gt_node_stream_class_new"></a>

<code>const
GtNodeStreamClass*  gt_node_stream_class_new(size_t size,
                                            GtNodeStreamFreeFunc free,
                                            GtNodeStreamNextFunc next)</code>
<p>
Create a new node stream class (that is, a class which implements the node
   stream interface). <code>size</code> denotes the size of objects of the new node stream
   class. The optional <code>free</code> method is called once, if an object of the new
   class is deleted. The mandatory <code>next</code> method has to implement the
   <code>gt_node_stream_next()</code> semantic for the new class.
</p>
<hr>
<a name="GtNodeVisitor"></a>
<h2>Class GtNodeVisitor</h2>

<p> The <code>GtNodeVisitor</code> interface, a visitor for <code>GtGenomeNode</code> objects. </p>

<hr>
<a name="gt_node_visitor_visit_comment_node"></a>

<code>int    gt_node_visitor_visit_comment_node(GtNodeVisitor *node_visitor,
                                         GtCommentNode *comment_node,
                                         GtError *err)</code>
<p>
Visit <code>comment_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_feature_node"></a>

<code>int    gt_node_visitor_visit_feature_node(GtNodeVisitor *node_visitor,
                                         GtFeatureNode *feature_node,
                                         GtError *err)</code>
<p>
Visit <code>feature_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_region_node"></a>

<code>int    gt_node_visitor_visit_region_node(GtNodeVisitor *node_visitor,
                                        GtRegionNode *region_node,
                                        GtError *err)</code>
<p>
Visit <code>region_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_visit_sequence_node"></a>

<code>int    gt_node_visitor_visit_sequence_node(GtNodeVisitor *node_visitor,
                                          GtSequenceNode *sequence_node,
                                          GtError *err)</code>
<p>
Visit <code>sequence_node</code> with <code>node_visitor</code>.
</p>
<hr>
<a name="gt_node_visitor_delete"></a>

<code>void   gt_node_visitor_delete(GtNodeVisitor *node_visitor)</code>
<p>
Delete <code>node_visitor</code>.
</p>
<hr>
<a name="GtOption"></a>
<h2>Class GtOption</h2>

<p> <code>GtOption</code> objects represent command line options (which are used in
   a <code>GtOptionParser</code>).
   Option descriptions are automatically formatted to
   <code>GT_OPTION_PARSER_TERMINAL_WIDTH</code>, but it is possible to embed newlines into
   the descriptions to manually affect the formatting. </p>

<hr>
<a name="gt_option_new_bool"></a>

<code>GtOption*        gt_option_new_bool(const char *option_string,
                                   const char *description,
                                   bool *value, bool default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_double"></a>

<code>GtOption*        gt_option_new_double(const char *option_string,
                                     const char *description, double *value,
                                     double default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_double_min"></a>

<code>GtOption*        gt_option_new_double_min(const char *option_string,
                                         const char *description, double *value,
                                         double default_value,
                                         double minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_double_min_max"></a>

<code>GtOption*        gt_option_new_double_min_max(const char *option_string,
                                             const char *description,
                                             double *value,
                                             double default_value,
                                             double minimum_value,
                                             double maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_probability"></a>

<code>GtOption*        gt_option_new_probability(const char *option_string,
                                          const char *description,
                                          double *value,
                                          double default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at larger or equal than 0.0 and smaller or
  equal than 1.0.
</p>
<hr>
<a name="gt_option_new_int"></a>

<code>GtOption*        gt_option_new_int(const char *option_string,
                                  const char *description,
                                  int *value, int default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_int_min"></a>

<code>GtOption*        gt_option_new_int_min(const char *option_string,
                                      const char *description, int *value,
                                      int default_value, int minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_int_max"></a>

<code>GtOption*        gt_option_new_int_max(const char *option_string,
                                      const char *description, int *value,
                                      int default_value, int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at most have the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_int_min_max"></a>

<code>GtOption*        gt_option_new_int_min_max(const char *option_string,
                                          const char *description,
                                          int *value, int default_value,
                                          int minimum_value, int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_uint"></a>

<code>GtOption*        gt_option_new_uint(const char *option_string,
                                   const char *description,
                                   unsigned int *value,
                                   unsigned int default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_uint_min"></a>

<code>GtOption*        gt_option_new_uint_min(const char *option_string,
                                       const char *description,
                                       unsigned int *value,
                                       unsigned int default_value,
                                       unsigned int minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_uint_max"></a>

<code>GtOption*        gt_option_new_uint_max(const char *option_string,
                                       const char *description,
                                       unsigned int *value,
                                       unsigned int default_value,
                                       unsigned int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at most have the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_uint_min_max"></a>

<code>GtOption*        gt_option_new_uint_min_max(const char *option_string,
                                           const char *description,
                                           unsigned int *value,
                                           unsigned int default_value,
                                           unsigned int minimum_value,
                                           unsigned int maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_long"></a>

<code>GtOption*        gt_option_new_long(const char *option_string,
                                   const char *description,
                                   long *value, long default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_ulong"></a>

<code>GtOption*        gt_option_new_ulong(const char *option_string,
                                    const char *description,
                                    unsigned long *value,
                                    unsigned long default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_ulong_min"></a>

<code>GtOption*        gt_option_new_ulong_min(const char *option_string,
                                        const char *description,
                                        unsigned long *value,
                                        unsigned long default_value,
                                        unsigned long minimum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code>.
</p>
<hr>
<a name="gt_option_new_ulong_min_max"></a>

<code>GtOption*        gt_option_new_ulong_min_max(const char *option_string,
                                            const char *description,
                                            unsigned long *value,
                                            unsigned long default_value,
                                            unsigned long minimum_value,
                                            unsigned long maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The argument to this option must at least have the <code>minimum_value</code> and at most
  the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_range"></a>

<code>GtOption*        gt_option_new_range(const char *option_string,
                                    const char *description,
                                    GtRange *value, GtRange *default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
   If <code>default_value</code> equals <code>NULL</code>, <code>GT_UNDEF_LONG</code> will be used as the default
   start and end point of <code>value</code>.
</p>
<hr>
<a name="gt_option_new_range_min_max"></a>

<code>GtOption*        gt_option_new_range_min_max(const char *option_string,
                                            const char *description,
                                            GtRange *value,
                                            GtRange *default_value,
                                            unsigned long minimum_value,
                                            unsigned long maximum_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
  The first argument to this option (which will be used as the start) must at
  least have the <code>minimum_value</code> and the second argument (which will be used as
  the end) at most the <code>maximum_value</code>.
</p>
<hr>
<a name="gt_option_new_string"></a>

<code>GtOption*        gt_option_new_string(const char *option_string,
                                     const char *description,
                                     GtStr *value, const char *default_value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing is stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_string_array"></a>

<code>GtOption*        gt_option_new_string_array(const char *option_string,
                                           const char *description,
                                           GtStrArray *value)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing are stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_choice"></a>

<code>GtOption*        gt_option_new_choice(const char *option_string,
                                     const char *description, GtStr *value,
                                     const char *default_value,
                                     const char **domain)</code>
<p>
Return a <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code> which allows only arguments given in the <code>NULL</code>-terminated
   <code>domain</code> (<code>default_value</code> must be an entry of <code>domain</code> or <code>NULL</code>).
</p>
<hr>
<a name="gt_option_new_filename"></a>

<code>GtOption*        gt_option_new_filename(const char *option_string,
                                       const char *description,
                                       GtStr *filename)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The result of the option parsing are stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_filename_array"></a>

<code>GtOption*        gt_option_new_filename_array(const char *option_string,
                                             const char *description,
                                             GtStrArray *filename_array)</code>
<p>
Return a new <code>GtOption</code> with the given <code>option_string</code>, <code>description</code>, and
   <code>default_value</code>. The results of the option parsing are stored in <code>value</code>.
</p>
<hr>
<a name="gt_option_new_debug"></a>

<code>GtOption*        gt_option_new_debug(bool *value)</code>
<p>
Return a new debug <code>GtOption</code> object: <code>-debug</code>, "enable debugging output",
   default is <code>false</code>. The result of the option parsing is stored in <code>value</code>
</p>
<hr>
<a name="gt_option_new_verbose"></a>

<code>GtOption*        gt_option_new_verbose(bool *value)</code>
<p>
Return a new verbose <code>GtOption</code> object: <code>-v</code>, "be verbose",
   default is <code>false</code>. The result of the option parsing is stored in <code>value</code>
</p>
<hr>
<a name="gt_option_new_width"></a>

<code>GtOption*        gt_option_new_width(unsigned long *value)</code>
<p>
Return a new width <code>GtOption</code> object: <code>-width</code>, "set output width for FASTA
   sequence printing (0 disables formatting)", default is 0.
   The result of the option parsing is stored in <code>value</code>
</p>
<hr>
<a name="gt_option_ref"></a>

<code>GtOption*        gt_option_ref(GtOption *option)</code>
<p>
Increase the reference count for <code>option</code> and return it.
</p>
<hr>
<a name="gt_option_get_name"></a>

<code>const char*      gt_option_get_name(const GtOption * option)</code>
<p>
Return the name of <code>option</code>
</p>
<hr>
<a name="gt_option_is_mandatory"></a>

<code>void             gt_option_is_mandatory(GtOption *option)</code>
<p>
Make <code>option</code> mandatory.
</p>
<hr>
<a name="gt_option_is_mandatory_either"></a>

<code>void             gt_option_is_mandatory_either(GtOption *option_a,
                                              const GtOption *option_b)</code>
<p>
Make it mandatory, that either <code>option_a</code> or <code>option_b</code> is used.
</p>
<hr>
<a name="gt_option_is_mandatory_either_3"></a>

<code>void             gt_option_is_mandatory_either_3(GtOption *option_a,
                                                const GtOption *option_b,
                                                const GtOption *option_c)</code>
<p>
Make it mandatory, that one of the options <code>option_a</code>, <code>option_b</code>, or
   <code>option_c</code> is used.
</p>
<hr>
<a name="gt_option_is_extended_option"></a>

<code>void             gt_option_is_extended_option(GtOption *option)</code>
<p>
Set that <code>option</code> is only shown in the output of <code>-help+</code>.
</p>
<hr>
<a name="gt_option_is_development_option"></a>

<code>void             gt_option_is_development_option(GtOption *option)</code>
<p>
Set that <code>option</code> is only shown in the output of <code>-helpdev</code>.
</p>
<hr>
<a name="gt_option_imply"></a>

<code>void             gt_option_imply(GtOption *option_a, const GtOption *option_b)</code>
<p>
Make <code>option_a</code> imply <code>option_b</code>.
</p>
<hr>
<a name="gt_option_imply_either_2"></a>

<code>void             gt_option_imply_either_2(GtOption *option_a,
                                         const GtOption *option_b,
                                         const GtOption *option_c)</code>
<p>
Make <code>option_a</code> imply either <code>option_b</code> or <code>option_c</code>
</p>
<hr>
<a name="gt_option_exclude"></a>

<code>void             gt_option_exclude(GtOption *option_a, GtOption *option_b)</code>
<p>
Set that the options <code>option_a</code> and <code>option_b</code> exclude each other.
</p>
<hr>
<a name="gt_option_hide_default"></a>

<code>void             gt_option_hide_default(GtOption *option)</code>
<p>
Hide the default value of <code>option</code> in <code>-help</code> output.
</p>
<hr>
<a name="gt_option_argument_is_optional"></a>

<code>void             gt_option_argument_is_optional(GtOption *option)</code>
<p>
Set that the argument to <code>option</code> is optional
</p>
<hr>
<a name="gt_option_is_set"></a>

<code>bool             gt_option_is_set(const GtOption *option)</code>
<p>
Return <code>true</code> if <code>option</code> was set, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_option_delete"></a>

<code>void             gt_option_delete(GtOption*)</code>
<p>
Delete <code>option</code>.
</p>
<hr>
<a name="gt_option_parse_spacespec"></a>

<code>int  gt_option_parse_spacespec(unsigned long *maximumspace,
                              const char *optname,
                              const GtStr *memlimit,
                              GtError *err)</code>
<p>
Parse the argument to option -memlimit. Could be made into
   a special parser, but I do not know how. SK. 2011-09-19
</p>
<hr>
<a name="GtOptionParser"></a>
<h2>Class GtOptionParser</h2>

<p> <code>GtOptionParser</code> objects can be used to parse command line options. </p>

<hr>
<a name="GT_OPTION_PARSER_TERMINAL_WIDTH"></a>

<code>#define GT_OPTION_PARSER_TERMINAL_WIDTH</code>
<p>
The default terminal width used in the output of the <code>GtOptionParser</code>.
</p>
<hr>
<a name="gt_option_parser_new"></a>

<code>GtOptionParser*  gt_option_parser_new(const char *synopsis,
                                     const char *one_liner)</code>
<p>
Return a new <code>GtOptionParser</code> object. The <code>synopsis</code> should summarize the
   command line arguments and mandatory arguments in a single line.
   The <code>one_liner</code> should describe the program for which the <code>GtOptionParser</code> is
   used in a single line and must have an upper case letter at the start and a
   '.' at the end.
</p>
<hr>
<a name="gt_option_parser_add_option"></a>

<code>void             gt_option_parser_add_option(GtOptionParser *option_parser,
                                            GtOption *option)</code>
<p>
Add <code>option</code> to <code>option_parser</code>. Takes ownership of <code>option</code>.
</p>
<hr>
<a name="gt_option_parser_get_option"></a>

<code>GtOption*        gt_option_parser_get_option(GtOptionParser *option_parser,
                                            const char *option_string)</code>
<p>
Return the <code>GtOption</code> object if an option named <code>option_string</code> is present in
   <code>option_parser</code>, and <code>NULL</code> if no such option exists.
</p>
<hr>
<a name="gt_option_parser_refer_to_manual"></a>

<code>void             gt_option_parser_refer_to_manual(GtOptionParser *option_parser)</code>
<p>
Refer to manual at the end of <code>-help</code> output of <code>opion_parser</code>.
</p>
<hr>
<a name="gt_option_parser_set_comment_func"></a>

<code>void             gt_option_parser_set_comment_func(GtOptionParser *option_parser,
                                                  GtShowCommentFunc
                                                  comment_func,
                                                  void *data)</code>
<p>
Set <code>comment_func</code> in <code>option_parser</code> (<code>data</code> is passed along).
</p>
<hr>
<a name="gt_option_parser_set_version_func"></a>

<code>void             gt_option_parser_set_version_func(GtOptionParser *option_parser,
                                                  GtShowVersionFunc
                                                  version_func)</code>
<p>
Set the version function used by <code>option_parser</code> to <code>version_func</code>.
   This version function takes precedence to the one supplied to
   <code>gt_option_parser_parse()</code>.
</p>
<hr>
<a name="gt_option_parser_set_mail_address"></a>

<code>void             gt_option_parser_set_mail_address(GtOptionParser*,
                                                  const char *mail_address)</code>
<p>
Set the <code>mail_address</code> used in the final "Report bugs to" line of the <code>-help</code>
   output. It should be of the form <code><bill@microsoft.com></code> (email address
   enclosed in one pair of angle brackets).
</p>
<hr>
<a name="gt_option_parser_register_hook"></a>

<code>void             gt_option_parser_register_hook(GtOptionParser *option_parser,
                                               GtOptionParserHookFunc
                                               hook_function,
                                               void *data)</code>
<p>
Register a <code>hook_function</code> with <code>option_parser</code>. All registered hook
   functions are called at the end of <code>gt_option_parser_parse(</code>).
   This allows to have a module which registers a bunch of options in the option
   parser and automatically performs necessary postprocessing after the option
   parsing has been done via the hook function.
</p>
<hr>
<a name="gt_option_parser_set_min_args"></a>

<code>void             gt_option_parser_set_min_args(GtOptionParser *option_parser,
                                              unsigned int minimum)</code>
<p>
The the <code>minimum</code> number of additional command line arguments <code>option_parser</code>
   must parse in order to succeed.
</p>
<hr>
<a name="gt_option_parser_set_max_args"></a>

<code>void             gt_option_parser_set_max_args(GtOptionParser *option_parser,
                                              unsigned int maximum)</code>
<p>
The the <code>maximum</code> number of additional command line arguments <code>option_parser</code>
   must parse in order to succeed.
</p>
<hr>
<a name="gt_option_parser_set_min_max_args"></a>

<code>void             gt_option_parser_set_min_max_args(GtOptionParser *option_parser,
                                                  unsigned int minimum,
                                                  unsigned int maximum)</code>
<p>
The the <code>minimum</code> and <code>maximum</code> number of additional command line arguments
   <code>option_parser</code> must parse in order to succeed.
</p>
<hr>
<a name="gt_option_parser_parse"></a>

<code>GtOPrval         gt_option_parser_parse(GtOptionParser *option_parser,
                                       int *parsed_args,
                                       int argc, const char **argv,
                                       GtShowVersionFunc version_func,
                                       GtError *err)</code>
<p>
Use <code>option_parser</code> to parse options given in argument vector <code>argv</code> (with
   <code>argc</code> many arguments). The number of parsed arguments is stored in
   <code>parsed_args</code>. <code>version_func</code> is used for the output of option <code>-version</code>.
   In case of error, <code>GT_OPTION_PARSER_ERROR</code> is returned and <code>err</code> is set
   accordingly.
</p>
<hr>
<a name="gt_option_parser_delete"></a>

<code>void             gt_option_parser_delete(GtOptionParser *option_parser)</code>
<p>
Delete <code>option_parser</code>.
</p>
<hr>
<a name="GtPhase"></a>
<h2>Class GtPhase</h2>

<p> This enum type defines the possible phases. The following phases are
   defined: <code>GT_PHASE_ZERO</code>, <code>GT_PHASE_ONE</code>, <code>GT_PHASE_TWO</code>, and
   <code>GT_PHASE_UNDEFINED</code>. </p>

<hr>
<a name="GT_PHASE_CHARS"></a>

<code>#define GT_PHASE_CHARS</code>
<p>
Use this string to map phase enum types to their corresponding character.
</p>
<hr>
<a name="gt_phase_get"></a>

<code>GtPhase  gt_phase_get(char phase_char)</code>
<p>
Map <code>phase_char</code> to the corresponding phase enum type.
   An assertion will fail if <code>phase_char</code> is not a valid one.
</p>
<hr>
<a name="GtQueue"></a>
<h2>Class GtQueue</h2>

<p> <code>GtQueue</code> objects are generic queues which can be used to process objects of
   any type in an First-In-First-Out (FIFO) fashion. </p>

<hr>
<a name="gt_queue_new"></a>

<code>GtQueue*       gt_queue_new(void)</code>
<p>
Return a new <code>GtQueue</code> object.
</p>
<hr>
<a name="gt_queue_add"></a>

<code>void           gt_queue_add(GtQueue *queue, void *elem)</code>
<p>
Add <code>elem</code> to <code>queue</code> (<em>enqueue</em> in computer science terminology).
</p>
<hr>
<a name="gt_queue_get"></a>

<code>void*          gt_queue_get(GtQueue *queue)</code>
<p>
Remove the first element from non-empty <code>queue</code> and return it (<em>dequeue</em> in
   computer science terminology).
</p>
<hr>
<a name="gt_queue_head"></a>

<code>void*          gt_queue_head(GtQueue *queue)</code>
<p>
Return the first element in non-empty <code>queue</code> without removing it.
</p>
<hr>
<a name="gt_queue_remove"></a>

<code>void           gt_queue_remove(GtQueue *queue, void *elem)</code>
<p>
Remove <code>elem</code> from <code>queue</code> (<code>elem</code> has to be in <code>queue</code>).
   Thereby <code>queue</code> is traversed in reverse order, leading to
   O(<code>gt_queue_size(queue)</code>) worst-case running time.
</p>
<hr>
<a name="gt_queue_size"></a>

<code>unsigned long  gt_queue_size(const GtQueue *queue)</code>
<p>
Return the number of elements in <code>queue</code>.
</p>
<hr>
<a name="gt_queue_delete"></a>

<code>void           gt_queue_delete(GtQueue *queue)</code>
<p>
Delete <code>queue</code>. Elements contained in <code>queue</code> are not freed!
</p>
<hr>
<a name="GtRange"></a>
<h2>Class GtRange</h2>

<p> The <code>GtRange</code> class is used to represent genomic ranges in <em>GenomeTools</em>.
   Thereby, the <code>start</code> must <strong>always</strong> be smaller or equal than the <code>end</code>. </p>

<hr>
<a name="gt_range_compare"></a>

<code>int            gt_range_compare(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Compare <code>range_a</code> and <code>range_b</code>. Returns 0 if <code>range_a</code> equals <code>range_b</code>, -1
   if <code>range_a</code> starts before <code>range_b</code> or (for equal starts) <code>range_a</code> ends
   before <code>range_b</code>, and 1 else.
</p>
<hr>
<a name="gt_range_compare_with_delta"></a>

<code>int            gt_range_compare_with_delta(const GtRange *range_a,
                                          const GtRange *range_b,
                                          unsigned long delta)</code>
<p>
Compare <code>range_a</code> and <code>range_b</code> with given <code>delta</code>.
   Returns 0 if <code>range_a</code> equals <code>range_b</code> modulo <code>delta</code> (i.e., the start and
   end points of <code>range_a</code> and <code>range_b</code> are at most <code>delta</code> bases apart), -1
   if <code>range_a</code> starts before <code>range_b</code> or (for equal starts) <code>range_a</code> ends
   before <code>range_b</code>, and 1 else.
</p>
<hr>
<a name="gt_range_overlap"></a>

<code>bool           gt_range_overlap(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Returns <code>true</code> if <code>range_a</code> and <code>range_b</code> overlap, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_overlap_delta"></a>

<code>bool           gt_range_overlap_delta(const GtRange *range_a,
                                     const GtRange *range_b,
                                     unsigned long delta)</code>
<p>
Returns <code>true</code> if <code>range_a</code> and <code>range_b</code> overlap <strong>at least</strong> <code>delta</code> many
   positions, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_contains"></a>

<code>bool           gt_range_contains(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Returns <code>true</code> if <code>range_b</code> is contained in <code>range_a</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_within"></a>

<code>bool           gt_range_within(const GtRange *range, unsigned long point)</code>
<p>
Returns <code>true</code> if <code>point</code> lies within <code>range</code>, <code>false</code> otherwise.
</p>
<hr>
<a name="gt_range_join"></a>

<code>GtRange        gt_range_join(const GtRange *range_a, const GtRange *range_b)</code>
<p>
Join <code>range_a</code> and <code>range_b</code> and return the result.
</p>
<hr>
<a name="gt_range_offset"></a>

<code>GtRange        gt_range_offset(const GtRange *range, long offset)</code>
<p>
Transform start and end of <code>range</code> by <code>offset</code> and return the result.
</p>
<hr>
<a name="gt_range_length"></a>

<code>unsigned long  gt_range_length(const GtRange *range)</code>
<p>
Returns the length of the given <code>range</code>.
</p>
<hr>
<a name="GtReadmode"></a>
<h2>Class GtReadmode</h2>

<p> This enum type defines the possible reamodes, namely <code>GT_READMODE_FORWARD</code>,
   <code>GT_READMODE_REVERSE</code>, <code>GT_READMODE_COMPL</code>, and <code>GT_READMODE_REVCOMPL</code>. </p>

<hr>
<a name="gt_readmode_show"></a>

<code>const char*  gt_readmode_show(GtReadmode readmode)</code>
<p>
Returns the descriptive string for <code>readmode</code>.
</p>
<hr>
<a name="gt_readmode_parse"></a>

<code>int          gt_readmode_parse(const char *string, GtError *err)</code>
<p>
Returns the <code>GtReadmode</code> for the description <code>string</code>, which must be one
   of "fwd","rev","cpl" or "rcl". If <code>string</code> does not equal any of them,
   -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="GtRecMap"></a>
<h2>Class GtRecMap</h2>

<p> A <code>GtRecMap</code> object contains a mapping from a 2D coordinate pair
   which identifies a rectangle in a rendered image to the <code>GtFeatureNode</code> it
  represents. The rectangle is defined by the coordinates of its upper left
  (``northwest'') and lower right (``southeast'') points.</p><p>  <code>GtRecMap</code> objects are created by an <code>GtImageInfo</code> object which is filled
  during the generation of an image by <em>AnnotationSketch</em>. </p>

<hr>
<a name="gt_rec_map_get_northwest_x"></a>

<code>double                   gt_rec_map_get_northwest_x(const GtRecMap*)</code>
<p>
Retrieve <em>x</em> value of the the upper left point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_northwest_y"></a>

<code>double                   gt_rec_map_get_northwest_y(const GtRecMap*)</code>
<p>
Retrieve <em>y</em> value of the the upper left point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_southeast_x"></a>

<code>double                   gt_rec_map_get_southeast_x(const GtRecMap*)</code>
<p>
Retrieve <em>x</em> value of the the lower right point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_southeast_y"></a>

<code>double                   gt_rec_map_get_southeast_y(const GtRecMap*)</code>
<p>
Retrieve <em>y</em> value of the the lower right point of the rectangle.
</p>
<hr>
<a name="gt_rec_map_get_genome_feature"></a>

<code>const GtFeatureNode*     gt_rec_map_get_genome_feature(const GtRecMap*)</code>
<p>
Retrieve <code>GtFeatureNode</code> associated with this rectangle.
</p>
<hr>
<a name="gt_rec_map_has_omitted_children"></a>

<code>bool                     gt_rec_map_has_omitted_children(const GtRecMap*)</code>
<p>
Returns <code>true</code> if the rectangle represents a block root whose elements
   have not been drawn due to size restrictions.
</p>
<hr>
<a name="GtRegionMapping"></a>
<h2>Class GtRegionMapping</h2>

<p> A <code>GtRegionMapping</code> objects maps sequence-regions to the corresponding
   entries of sequence files. </p>

<hr>
<a name="gt_region_mapping_new_mapping"></a>

<code>GtRegionMapping*  gt_region_mapping_new_mapping(GtStr *mapping_filename,
                                               GtError *err)</code>
<p>
Return a new <code>GtRegionMapping</code> object for the mapping file with the given
   <code>mapping_filename</code>. In the case of an error, <code>NULL</code> is returned and <code>err</code> is
   set accordingly.
</p>
<hr>
<a name="gt_region_mapping_new_seqfiles"></a>

<code>GtRegionMapping*  gt_region_mapping_new_seqfiles(GtStrArray *sequence_filenames,
                                                bool matchdesc, bool usedesc)</code>
<p>
Return a new <code>GtRegionMapping</code> object for the sequence files given in
   <code>sequence_filenames</code>. If <code>matchdesc</code> is <code>true</code>, the sequence descriptions
   from the input files are matched for the desired sequence IDs (in GFF3).

   If <code>usedesc</code> is <code>true</code>, the sequence descriptions are used to map the
   sequence IDs (in GFF3) to actual sequence entries. If a description contains
   a sequence range (e.g., III:1000001..2000000), the first part is used as
   sequence ID ('III') and the first range position as offset ('1000001').

   <code>matchdesc</code> and <code>usedesc</code> cannot be <code>true</code> at the same time.
</p>
<hr>
<a name="gt_region_mapping_new_rawseq"></a>

<code>GtRegionMapping*  gt_region_mapping_new_rawseq(const char *rawseq,
                                              unsigned long length,
                                              unsigned long offset)</code>
<p>
Return a new <code>GtRegionMapping</code> object which maps to the given sequence
   <code>rawseq</code> with the corresponding <code>length</code> and <code>offset</code>.
</p>
<hr>
<a name="gt_region_mapping_ref"></a>

<code>GtRegionMapping*  gt_region_mapping_ref(GtRegionMapping *region_mapping)</code>
<p>
Increase the reference count for <code>region_mapping</code> and return it.
</p>
<hr>
<a name="gt_region_mapping_get_raw_sequence"></a>

<code>int               gt_region_mapping_get_raw_sequence(GtRegionMapping
                                                    *region_mapping,
                                                    const char **rawseq,
                                                    unsigned long *length,
                                                    unsigned long *offset,
                                                    GtStr *seqid,
                                                    const GtRange *range,
                                                    GtError *err)</code>
<p>
Use <code>region_mapping</code> to map the given sequence ID <code>seqid</code> and its
   corresponding <code>range</code> to an actual sequence. The sequence is returned in
   <code>rawseq</code>, its length and offset in <code>length</code> and <code>offset</code>.
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_get_description"></a>

<code>int               gt_region_mapping_get_description(GtRegionMapping
                                                   *region_mapping,
                                                   GtStr *desc,
                                                   GtStr *seqid,
                                                   GtError *err)</code>
<p>
Use <code>region_mapping</code> to get the description of the MD5 sequence ID <code>seqid</code>.
   The description is appended to <code>desc</code>.
   In the case of an error, -1 is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_get_md5_fingerprint"></a>

<code>const char*       gt_region_mapping_get_md5_fingerprint(GtRegionMapping
                                                       *region_mapping,
                                                       GtStr *seqid,
                                                       const GtRange *range,
                                                       unsigned long *offset,
                                                       GtError *err)</code>
<p>
Use <code>region_mapping</code> to return the MD5 fingerprint of the sequence with the
   sequence ID <code>seqid</code> and its corresponding <code>range</code>. The offset of the sequence
   is stored in <code>offset</code>.
   In the case of an error, <code>NULL</code> is returned and <code>err</code> is set accordingly.
</p>
<hr>
<a name="gt_region_mapping_delete"></a>

<code>void              gt_region_mapping_delete(GtRegionMapping *region_mapping)</code>
<p>
Delete <code>region_mapping</code>.
</p>
<hr>
<a name="GtRegionNode"></a>
<h2>Class GtRegionNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Region nodes correspond to the
   <code>##sequence-region</code> lines in GFF3 files.</p>

<hr>
<a name="gt_region_node_new"></a>

<code>GtGenomeNode*  gt_region_node_new(GtStr *seqid, unsigned long start,
                                               unsigned long end)</code>
<p>
Create a new <code>GtRegionNode*</code> representing sequence with ID <code>seqid</code> from
   base position <code>start</code> to base position <code>end</code> (1-based).
   <code>start</code> has to be smaller or equal than <code>end</code>.
   The <code>GtRegionNode*</code> stores a new reference to <code>seqid</code>, so make sure you do
   not modify the original <code>seqid</code> afterwards!
</p>
<hr>
<a name="GtSelectStream"></a>
<h2>Class GtSelectStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtSelectStream</code> selects certain
   nodes it retrieves from its node source and passes them along. </p>

<hr>
<a name="gt_select_stream_new"></a>

<code>GtNodeStream*  gt_select_stream_new(GtNodeStream *in_stream,
                                   GtStr *seqid,
                                   GtStr *source,
                                   const GtRange *contain_range,
                                   const GtRange *overlap_range,
                                   GtStrand strand,
                                   GtStrand targetstrand,
                                   bool has_CDS,
                                   unsigned long max_gene_length,
                                   unsigned long max_gene_num,
                                   double min_gene_score,
                                   double max_gene_score,
                                   double min_average_splice_site_prob,
                                   unsigned long feature_num)</code>
<p>
Create a <code>GtSelectStream</code> object which selects genome nodes it retrieves from
   its <code>in_stream</code> and passes them along if they meet the criteria defined by
   the other arguments. All comment nodes are selected.
   If <code>seqid</code> is defined, a genome node must have it to be selected.
   If <code>source</code> is defined, a genome node must have it to be selected.
   If <code>contain_range</code> is defined, a genome node must be contained in it to be
   selected.
   If <code>overlap_range</code> is defined, a genome node must overlap it to be selected.
   If <code>strand</code> is defined, a (top-level) genome node must have it to be
   selected.
   If <code>targetstrand</code> is defined, a feature with a target attribute must have
   exactly one of it and its strand must equal <code>targetstrand</code>.
   If <code>had_cds</code> is <code>true</code>, all top-level features are selected which have a
   child with type <em>CDS</em>.
   If <code>max_gene_length</code> is defined, only genes up to the this length are
   selected.
   If <code>max_gene_num</code> is defined, only so many genes are selected.
   If <code>min_gene_score</code> is defined, only genes with at least this score are
   selected.
   If <code>max_gene_score</code> is defined, only genes with at most this score are
   selected.
   If <code>min_average_splice_site_prob</code> is defined, feature nodes which have
   splice sites must have at least this average splice site score to be
   selected.
   If <code>feature_num</code> is defined, just the <code>feature_num</code>th feature node occurring
   in the <code>in_stream</code> is selected.
</p>
<hr>
<a name="GtSequenceNode"></a>
<h2>Class GtSequenceNode</h2>

<p> Implements the <code>GtGenomeNode</code> interface. Sequence nodes correspond to
   singular embedded FASTA sequences in GFF3 files. </p>

<hr>
<a name="gt_sequence_node_new"></a>

<code>GtGenomeNode*             gt_sequence_node_new(const char *description,
                                              GtStr *sequence)</code>
<p>
Create a new <code>GtSequenceNode*</code> representing a FASTA entry with the given
   <code>description</code> and <code>sequence</code>. Takes ownership of <code>sequence</code>.
</p>
<hr>
<a name="gt_sequence_node_get_description"></a>

<code>const char*               gt_sequence_node_get_description(const
                                                          GtSequenceNode
                                                          *sequence_node)</code>
<p>
Return the description of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_get_sequence"></a>

<code>const char*               gt_sequence_node_get_sequence(const GtSequenceNode
                                                       *sequence_node)</code>
<p>
Return the sequence of <code>sequence_node</code>.
</p>
<hr>
<a name="gt_sequence_node_get_sequence_length"></a>

<code>unsigned long             gt_sequence_node_get_sequence_length(const
                                                              GtSequenceNode
                                                              *sequence_node)</code>
<p>
Return the sequence length of <code>sequence_node</code>.
</p>
<hr>
<a name="GtSortStream"></a>
<h2>Class GtSortStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtSortStream</code> sorts the
   <code>GtGenomeNode</code> objects it retrieves from its node source. </p>

<hr>
<a name="gt_sort_stream_new"></a>

<code>GtNodeStream*  gt_sort_stream_new(GtNodeStream *in_stream)</code>
<p>
Create a <code>GtSortStream*</code> which sorts the genome nodes it retrieves from
   <code>in_stream</code> and returns them unmodified, but in sorted order.
</p>
<hr>
<a name="GtSplitter"></a>
<h2>Class GtSplitter</h2>

<p> The <code>GtSplitter</code> class defines objects which can split given strings into
   tokens delimited by a given character, allowing for convenient access to
   each token. </p>

<hr>
<a name="gt_splitter_new"></a>

<code>GtSplitter*    gt_splitter_new(void)</code>
<p>
Create a new <code>GtSplitter</code> object.
</p>
<hr>
<a name="gt_splitter_split"></a>

<code>void           gt_splitter_split(GtSplitter *splitter, char *string,
                                unsigned long length, char delimiter)</code>
<p>
Use <code>splitter</code> to split <code>string</code> of given <code>length</code> into tokens delimited by
   <code>delimiter</code>. Note that <code>string</code> is modified in the splitting process!
</p>
<hr>
<a name="gt_splitter_get_tokens"></a>

<code>char**         gt_splitter_get_tokens(GtSplitter *splitter)</code>
<p>
Return all tokens split by <code>splitter</code> in an array.
</p>
<hr>
<a name="gt_splitter_get_token"></a>

<code>char*          gt_splitter_get_token(GtSplitter *splitter,
                                    unsigned long token_num)</code>
<p>
Return token with number <code>token_num</code> from <code>splitter</code>.
</p>
<hr>
<a name="gt_splitter_reset"></a>

<code>void           gt_splitter_reset(GtSplitter *splitter)</code>
<p>
Reset the <code>splitter</code>.
</p>
<hr>
<a name="gt_splitter_size"></a>

<code>unsigned long  gt_splitter_size(GtSplitter *splitter)</code>
<p>
Return the number of tokens in <code>splitter</code>.
</p>
<hr>
<a name="gt_splitter_delete"></a>

<code>void           gt_splitter_delete(GtSplitter *splitter)</code>
<p>
Delete the <code>splitter</code>.
</p>
<hr>
<a name="GtStatStream"></a>
<h2>Class GtStatStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtStatStream</code> gathers statistics
   about the <code>GtGenomeNode</code> objects it retrieves from its node source and passes
   them along unmodified. </p>

<hr>
<a name="gt_stat_stream_new"></a>

<code>GtNodeStream*  gt_stat_stream_new(GtNodeStream *in_stream,
                                 bool gene_length_distribution,
                                 bool gene_score_distribution,
                                 bool exon_length_distribution,
                                 bool exon_number_distribution,
                                 bool intron_length_distribution,
                                 bool cds_length_distribution,
                                 bool used_sources)</code>
<p>
Create a <code>GtStatStream</code> object which gathers statistics about the
   <code>GtGenomeNode</code> objects it retrieves from its <code>in_stream</code> and returns them
   unmodified. Besides the basic statistics, statistics about the following
   distributions can be gathered, if the corresponding argument equals <code>true</code>:
   <code>gene_length_distribution</code>, <code>gene_score_distribution</code>,
   <code>exon_length_distribution</code>, <code>exon_number_distribution</code>,
   <code>intron_length_distribution</code>, <code>cds_length_distribution</code>.

   If <code>used_sources</code> equals <code>true</code>, it is recorded which source tags have been
   encountered.
</p>
<hr>
<a name="gt_stat_stream_show_stats"></a>

<code>void           gt_stat_stream_show_stats(GtStatStream *stat_stream,
                                        GtFile *outfp)</code>
<p>
Write the statistics gathered by <code>stat_stream</code> to <code>outfp</code>.
</p>
<hr>
<a name="GtStr"></a>
<h2>Class GtStr</h2>

<p> Objects of the <code>GtStr</code> class are strings which grow on demand. </p>

<hr>
<a name="gt_str_new"></a>

<code>GtStr*         gt_str_new(void)</code>
<p>
Return an empty <code>GtStr</code> object.
</p>
<hr>
<a name="gt_str_new_cstr"></a>

<code>GtStr*         gt_str_new_cstr(const char *cstr)</code>
<p>
Return a new <code>GtStr</code> object whose content is set to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_clone"></a>

<code>GtStr*         gt_str_clone(const GtStr *str)</code>
<p>
Return a clone of <code>str</code>.
</p>
<hr>
<a name="gt_str_ref"></a>

<code>GtStr*         gt_str_ref(GtStr *str)</code>
<p>
Increase the reference count for <code>str</code> and return it.
   If <code>str</code> is <code>NULL</code>, <code>NULL</code> is returned without any side effects.
</p>
<hr>
<a name="gt_str_get"></a>

<code>char*          gt_str_get(const GtStr *str)</code>
<p>
Return the content of <code>str</code>.  Never returns NULL, and the content is always
   <code>\0</code>-terminated
</p>
<hr>
<a name="gt_str_set"></a>

<code>void           gt_str_set(GtStr *str, const char *cstr)</code>
<p>
Set the content of <code>str</code> to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_append_str"></a>

<code>void           gt_str_append_str(GtStr *dest, const GtStr *src)</code>
<p>
Append the string <code>src</code> to <code>dest</code>.
</p>
<hr>
<a name="gt_str_append_cstr"></a>

<code>void           gt_str_append_cstr(GtStr *str, const char *cstr)</code>
<p>
Append the <code>\0</code>-terminated <code>cstr</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_cstr_nt"></a>

<code>void           gt_str_append_cstr_nt(GtStr *str,
                                    const char *cstr, unsigned long length)</code>
<p>
Append the (not necessarily <code>\0</code>-terminated) <code>cstr</code> with given <code>length</code> to
   <code>str</code>.
</p>
<hr>
<a name="gt_str_append_char"></a>

<code>void           gt_str_append_char(GtStr *str, char c)</code>
<p>
Append character <code>c</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_double"></a>

<code>void           gt_str_append_double(GtStr *str, double d, int precision)</code>
<p>
Append double <code>d</code> to <code>str</code> with given <code>precision</code>.
</p>
<hr>
<a name="gt_str_append_ulong"></a>

<code>void           gt_str_append_ulong(GtStr *str, unsigned long ulong)</code>
<p>
Append <code>ulong</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_int"></a>

<code>void           gt_str_append_int(GtStr *str, int intval)</code>
<p>
Append <code>intval</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_append_uint"></a>

<code>void           gt_str_append_uint(GtStr *str, unsigned int uint)</code>
<p>
Append <code>uint</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_set_length"></a>

<code>void           gt_str_set_length(GtStr *str, unsigned long length)</code>
<p>
Set length of <code>str</code> to <code>length</code>. <code>length</code> must be smaller or equal than
   <code>gt_str_length(str)</code>.
</p>
<hr>
<a name="gt_str_reset"></a>

<code>void           gt_str_reset(GtStr *str)</code>
<p>
Reset <code>str</code> to length 0.
</p>
<hr>
<a name="gt_str_cmp"></a>

<code>int            gt_str_cmp(const GtStr *str1, const GtStr *str2)</code>
<p>
Compare <code>str1</code> and <code>str2</code> and return the result (similar to <code>strcmp(3)</code>).
</p>
<hr>
<a name="gt_str_length"></a>

<code>unsigned long  gt_str_length(const GtStr *str)</code>
<p>
Return the length of <code>str</code>. If <code>str</code> is <code>NULL</code>, 0 is returned.
</p>
<hr>
<a name="gt_str_delete"></a>

<code>void           gt_str_delete(GtStr *str)</code>
<p>
Decrease the reference count for <code>str</code> or delete it, if this was the last
   reference.
</p>
<hr>
<a name="GtStrArray"></a>
<h2>Class GtStrArray</h2>

<p> <code>GtStrArray*</code> objects are arrays of string which grow on demand. </p>

<hr>
<a name="gt_str_array_new"></a>

<code>GtStrArray*    gt_str_array_new(void)</code>
<p>
Return a new <code>GtStrArray</code> object.
</p>
<hr>
<a name="gt_str_array_ref"></a>

<code>GtStrArray*    gt_str_array_ref(GtStrArray*)</code>
<p>
Increases the reference to a GtStrArray.
</p>
<hr>
<a name="gt_str_array_add_cstr"></a>

<code>void           gt_str_array_add_cstr(GtStrArray *str_array, const char *cstr)</code>
<p>
Add <code>cstr</code> to <code>str_array</code>. Thereby, an internal copy of <code>cstr</code> is created.
</p>
<hr>
<a name="gt_str_array_add_cstr_nt"></a>

<code>void           gt_str_array_add_cstr_nt(GtStrArray *str_array, const char *cstr,
                                       unsigned long length)</code>
<p>
Add the non <code>\0</code>-terminated <code>cstr</code> with given <code>length</code> to <code>str_array</code>.
   Thereby, an internal copy of <code>cstr</code> is created.
</p>
<hr>
<a name="gt_str_array_add"></a>

<code>void           gt_str_array_add(GtStrArray *str_array, const GtStr *str)</code>
<p>
Add <code>str</code> to <code>str_array</code>. Thereby, an internal copy of <code>str</code> is created.
</p>
<hr>
<a name="gt_str_array_get"></a>

<code>const char*    gt_str_array_get(const GtStrArray *str_array,
                               unsigned long strnum)</code>
<p>
Return pointer to internal string with number <code>strnum</code> of <code>str_array</code>.
   <code>strnum</code> must be smaller than <code>gt_str_array_size(str_array)</code>.
</p>
<hr>
<a name="gt_str_array_set_cstr"></a>

<code>void           gt_str_array_set_cstr(GtStrArray *str_array, unsigned long strnum,
                                    const char *cstr)</code>
<p>
Set the string with number <code>strnum</code> in <code>str_array</code> to <code>cstr</code>.
</p>
<hr>
<a name="gt_str_array_set"></a>

<code>void           gt_str_array_set(GtStrArray *str_array, unsigned long strnum,
                               const GtStr *str)</code>
<p>
Set the string with number <code>strnum</code> in <code>str_array</code> to <code>str</code>.
</p>
<hr>
<a name="gt_str_array_set_size"></a>

<code>void           gt_str_array_set_size(GtStrArray *str_array, unsigned long size)</code>
<p>
Set the size of <code>str_array</code> to <code>size</code>. <code>size</code> must be smaller or equal than
   <code>gt_str_array_size(str_array)</code>.
</p>
<hr>
<a name="gt_str_array_reset"></a>

<code>void           gt_str_array_reset(GtStrArray *str_array)</code>
<p>
Set the size of <code>str_array</code> to 0.
</p>
<hr>
<a name="gt_str_array_size"></a>

<code>unsigned long  gt_str_array_size(const GtStrArray *str_array)</code>
<p>
Return the number of strings stored in <code>str_array</code>.
</p>
<hr>
<a name="gt_str_array_delete"></a>

<code>void           gt_str_array_delete(GtStrArray *str_array)</code>
<p>
Delete <code>str_array</code>.
</p>
<hr>
<a name="GtStrand"></a>
<h2>Class GtStrand</h2>

<p> This enum type defines the possible strands. The following strands are
   defined: <code>GT_STRAND_FORWARD</code>, <code>GT_STRAND_REVERSE</code>, <code>GT_STRAND_BOTH</code>, and
   <code>GT_STRAND_UNKNOWN</code>. </p>

<hr>
<a name="GT_STRAND_CHARS"></a>

<code>#define GT_STRAND_CHARS</code>
<p>
Use this string to map strand enum types to their corresponding character.
</p>
<hr>
<a name="gt_strand_get"></a>

<code>GtStrand  gt_strand_get(char strand_char)</code>
<p>
Map <code>strand_char</code> to the corresponding strand enum type.
   Returns <code>GT_NUM_OF_STRAND_TYPES</code> if <code>strand_char</code> is not a valid one.
</p>
<hr>
<a name="GtStyle"></a>
<h2>Class GtStyle</h2>

<p> Objects of the <code>GtStyle</code> class hold <em>AnnotationSketch</em> style information
   like colors, margins, collapsing options, and others. The class provides
   methods to set values of various types. Each value is organized into
   a <em>section</em> and is identified by a <em>key</em>. That is, a <em>section</em>, <em>key</em>
   pair must uniquely identify a value. </p>

<hr>
<a name="gt_style_new"></a>

<code>GtStyle*  gt_style_new(GtError*)</code>
<p>
Creates a new <code>GtStyle</code> object.
</p>
<hr>
<a name="gt_style_ref"></a>

<code>GtStyle*  gt_style_ref(GtStyle*)</code>
<p>
Increments the reference count of the given <code>GtStyle</code>.
</p>
<hr>
<a name="gt_style_unsafe_mode"></a>

<code>void      gt_style_unsafe_mode(GtStyle*)</code>
<p>
Enables unsafe mode (``io'' and ``os'' libraries loaded).
</p>
<hr>
<a name="gt_style_safe_mode"></a>

<code>void      gt_style_safe_mode(GtStyle*)</code>
<p>
Enables safe mode (``io'' and ``os'' libraries not accessible).
</p>
<hr>
<a name="gt_style_is_unsafe"></a>

<code>bool      gt_style_is_unsafe(GtStyle *sty)</code>
<p>
Returns true if <code>sty</code> is in unsafe mode.
</p>
<hr>
<a name="gt_style_clone"></a>

<code>GtStyle*  gt_style_clone(const GtStyle*, GtError*)</code>
<p>
Creates a independent (``deep'') copy of the given <code>GtStyle</code> object.
</p>
<hr>
<a name="gt_style_load_file"></a>

<code>int       gt_style_load_file(GtStyle*, const char *filename, GtError*)</code>
<p>
Loads and executes Lua style file with given <code>filename</code>.
   This file must define a global table called <em>style</em>.
</p>
<hr>
<a name="gt_style_load_str"></a>

<code>int       gt_style_load_str(GtStyle*, GtStr *instr, GtError*)</code>
<p>
Loads and executes Lua style code from the given <code>GtStr</code> <code>instr</code>.
   This code must define a global table called <em>style</em>.
</p>
<hr>
<a name="gt_style_to_str"></a>

<code>int       gt_style_to_str(const GtStyle*, GtStr *outstr, GtError*)</code>
<p>
Generates Lua code which represents the given <code>GtStyle</code> object and
   writes it into the <code>GtStr</code> object <code>outstr</code>.
</p>
<hr>
<a name="gt_style_reload"></a>

<code>void      gt_style_reload(GtStyle*)</code>
<p>
Reloads the Lua style file.
</p>
<hr>
<a name="gt_style_set_color"></a>

<code>void      gt_style_set_color(GtStyle*, const char *section, const char *key,
                            const GtColor *color)</code>
<p>
Sets a color value in the <code>GtStyle</code> for section <code>section</code> and <code>key</code> to a
   certain <code>color</code>.
</p>
<hr>
<a name="gt_style_set_str"></a>

<code>void      gt_style_set_str(GtStyle*, const char *section, const char *key,
                          GtStr *value)</code>
<p>
Set string with key <code>key</code> in <code>section</code> to <code>value</code>.
</p>
<hr>
<a name="gt_style_set_num"></a>

<code>void      gt_style_set_num(GtStyle*, const char *section, const char *key,
                          double number)</code>
<p>
Set numeric value of key <code>key</code> in <code>section</code> to <code>number</code>.
</p>
<hr>
<a name="gt_style_set_bool"></a>

<code>void      gt_style_set_bool(GtStyle*, const char *section, const char *key,
                           bool val)</code>
<p>
Set boolean value of key <code>key</code> in <code>section</code> to <code>val</code>.
</p>
<hr>
<a name="gt_style_unset"></a>

<code>void      gt_style_unset(GtStyle*, const char *section, const char *key)</code>
<p>
Unset value of key <code>key</code> in <code>section</code>.
</p>
<hr>
<a name="gt_style_delete"></a>

<code>void      gt_style_delete(GtStyle *style)</code>
<p>
Deletes this <code>style</code>.
</p>
<hr>
<a name="GtTagValueMap"></a>
<h2>Class GtTagValueMap</h2>

<p> A very simple tag/value map absolutely optimized for space (i.e., memory
   consumption) on the cost of time. Basically, each read/write access costs
   O(n) time, whereas n denotes the accumulated length of all tags and values
   contained in the map. Tags and values cannot have length 0.</p><p>   The implementation as a char* shines through (also to save one additional
   memory allocation), therefore the usage is a little bit different compared
   to other <em>GenomeTools</em> classes.
   See the implementation of <code>gt_tag_value_map_example()</code> for an ussage
   example. </p>

<hr>
<a name="gt_tag_value_map_new"></a>

<code>GtTagValueMap  gt_tag_value_map_new(const char *tag, const char *value)</code>
<p>
Return a new <code>GtTagValueMap</code> object which stores the given <code>tag</code>/<code>value</code>
   pair.
</p>
<hr>
<a name="gt_tag_value_map_add"></a>

<code>void           gt_tag_value_map_add(GtTagValueMap *tag_value_map,
                                   const char *tag,
                                   const char *value)</code>
<p>
Add <code>tag</code>/<code>value</code> pair to <code>tag_value_map</code>. <code>tag_value_map</code> must not contain
   the given <code>tag</code> already!
</p>
<hr>
<a name="gt_tag_value_map_set"></a>

<code>void           gt_tag_value_map_set(GtTagValueMap *tag_value_map,
                                   const char *tag, const char *value)</code>
<p>
Set the given <code>tag</code> in <code>tag_value_map</code> to <code>value</code>.
</p>
<hr>
<a name="gt_tag_value_map_get"></a>

<code>const char*    gt_tag_value_map_get(const GtTagValueMap tag_value_map,
                                   const char *tag)</code>
<p>
Return value corresponding to <code>tag</code> from <code>tag_value_map</code>. If <code>tag_value_map</code>
   does not contain such a value, <code>NULL</code> is returned.
</p>
<hr>
<a name="gt_tag_value_map_foreach"></a>

<code>void           gt_tag_value_map_foreach(const GtTagValueMap tag_value_map,
                                       GtTagValueMapIteratorFunc iterator_func,
                                       void *data)</code>
<p>
Apply <code>iterator_func</code> to each tag/value pair contained in <code>tag_value_map</code> and
   pass <code>data</code> along.
</p>
<hr>
<a name="gt_tag_value_map_example"></a>

<code>int            gt_tag_value_map_example(GtError *err)</code>
<p>
Implements an example useage of a tag/value map.
</p>
<hr>
<a name="gt_tag_value_map_delete"></a>

<code>void           gt_tag_value_map_delete(GtTagValueMap tag_value_map)</code>
<p>
Delete <code>tag_value_map</code>.
</p>
<hr>
<a name="GtTextWidthCalculator"></a>
<h2>Class GtTextWidthCalculator</h2>

<p> The GtTextWidthCalculator interface answers queries w.r.t.
   text width in a specific drawing backend. This interface is needed to do
   proper line breaking in a <code>GtLayout</code> even if there is no <code>GtCanvas</code> or
   <code>GtGraphics</code> created yet. </p>

<hr>
<a name="gt_text_width_calculator_ref"></a>

<code>GtTextWidthCalculator*  gt_text_width_calculator_ref(GtTextWidthCalculator*)</code>
<p>
Increases the reference count of the <code>GtTextWidthCalculator</code>.
</p>
<hr>
<a name="gt_text_width_calculator_get_text_width"></a>

<code>double                  gt_text_width_calculator_get_text_width(
                                                    GtTextWidthCalculator*,
                                                    const char *text,
                                                    GtError *err)</code>
<p>
Requests the width of <code>text</code> from the <code>GtTextWidthCalculator</code>.
   If the returned value is negative, an error occurred. Otherwise,
   a positive double value is returned.
</p>
<hr>
<a name="gt_text_width_calculator_delete"></a>

<code>void                    gt_text_width_calculator_delete(GtTextWidthCalculator*)</code>
<p>
Deletes a <code>GtTextWidthCalculator</code> instance.
</p>
<hr>
<a name="GtTextWidthCalculatorCairo"></a>
<h2>Class GtTextWidthCalculatorCairo</h2>

<p> Implements the GtTextWidthCalculator interface with Cairo as the drawing
   backend. If text width is to be calculated with regard to a specific
   transformation etc. which is in effect in a <code>cairo_t</code> and which should be
   used later via a <code>GtCanvasCairoContext</code>, create a
   <code>GtTextWidthCalculatorCairo</code> object and pass it to the <code>GtLayout</code> via
   <code>gt_layout_new_with_twc()</code>. </p>

<hr>
<a name="gt_text_width_calculator_cairo_new"></a>

<code>GtTextWidthCalculator*  gt_text_width_calculator_cairo_new(cairo_t*, GtStyle*)</code>
<p>
Creates a new <code>GtTextWidthCalculatorCairo</code> object for the given context
   using the text size options given in the <code>GtStyle</code>. If the <code>GtStyle</code> is NULL,
   the current font settings in the <code>cairo_t</code> will be used for all text
   width calculations.
</p>
<hr>
<a name="GtTimer"></a>
<h2>Class GtTimer</h2>

<p> The <code>GtTimer</code> class encapsulates a timer which can be used for run-time
   measurements. </p>

<hr>
<a name="gt_timer_new"></a>

<code>GtTimer*  gt_timer_new(void)</code>
<p>
Return a new <code>GtTimer</code> object.
</p>
<hr>
<a name="gt_timer_new_with_progress_description"></a>

<code>GtTimer*  gt_timer_new_with_progress_description(const char* description)</code>
<p>
Return a new <code>GtTimer</code> object with the first <code>description</code>.
</p>
<hr>
<a name="gt_timer_start"></a>

<code>void      gt_timer_start(GtTimer *t)</code>
<p>
Start the time measurement on <code>t</code>.
</p>
<hr>
<a name="gt_timer_stop"></a>

<code>void      gt_timer_stop(GtTimer *t)</code>
<p>
Stop the time measurement on <code>t</code>.
</p>
<hr>
<a name="gt_timer_show"></a>

<code>void      gt_timer_show(GtTimer *t, FILE *fp)</code>
<p>
Output the current state of <code>t</code> in the format
   "%ld.%06lds real %lds user %lds system" to file
   pointer <code>fp</code> (see <code>gt_timer_show_formatted</code>).
   The timer is then stopped.
</p>
<hr>
<a name="gt_timer_show_formatted"></a>

<code>void      gt_timer_show_formatted(GtTimer *t, const char *fmt, FILE *fp)</code>
<p>
Output the current state of <code>t</code> in a user-defined format given by <code>fmt</code>.
   <code>fmt</code> must be a format string for four %ld numbers, which are filled with:
   elapsed seconds, elapsed microseconds, used usertime in seconds,
   system time in seconds. The output is written to <code>fp</code>.
</p>
<hr>
<a name="gt_timer_show_progress"></a>

<code>void      gt_timer_show_progress(GtTimer *t, const char *desc, FILE *fp)</code>
<p>
Output the current state of <code>t</code> on <code>fp</code> since the last call of
   <code>gt_timer_show_progress()</code> or the last start of <code>t</code>, along with the current
   description. The timer is not stopped, but updated with <code>desc</code> to be the
   next description.
</p>
<hr>
<a name="gt_timer_show_progress_final"></a>

<code>void      gt_timer_show_progress_final(GtTimer *t, FILE *fp)</code>
<p>
Output the overall time measured with <code>t</code> from start to now on <code>fp</code>.
</p>
<hr>
<a name="gt_timer_show_cpu_time_by_progress"></a>

<code>void      gt_timer_show_cpu_time_by_progress(GtTimer *t)</code>
<p>
Show also user and sys time in output of gt_timer_show_progress[_final]
</p>
<hr>
<a name="gt_timer_omit_last_stage"></a>

<code>void      gt_timer_omit_last_stage(GtTimer *t)</code>
<p>
Hide output of last stage time in gt_timer_show_progress_final
</p>
<hr>
<a name="gt_timer_delete"></a>

<code>void      gt_timer_delete(GtTimer *t)</code>
<p>
Delete <code>t</code>.
</p>
<hr>
<a name="GtTransTable"></a>
<h2>Class GtTransTable</h2>
<a name="gt_trans_table_get_scheme_descriptions"></a>

<code>GtStrArray*    gt_trans_table_get_scheme_descriptions(void)</code>
<p>
Returns a <code>GtStrArray</code> of translation scheme descriptions, each of the
   format "%d: %s" where the number is the translation scheme number (usable in
   <code>gt_translator_set_translation_scheme()</code> and the string is the scheme
   name.
</p>
<hr>
<a name="gt_trans_table_new"></a>

<code>GtTransTable*  gt_trans_table_new(unsigned int scheme, GtError *err)</code>
<p>
Returns a translation table as given by <code>scheme</code> which refers to the numbers
   as reported by <code>gt_translator_get_translation_table_descriptions()</code> or the
   list given at the NCBI web site
   <em>http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</em>.
   Returns NULL if an error occurred, see <code>err</code> for details.
</p>
<hr>
<a name="gt_trans_table_new_standard"></a>

<code>GtTransTable*  gt_trans_table_new_standard(GtError *err)</code>
<p>
Returns the standard translation table.
</p>
<hr>
<a name="gt_trans_table_description"></a>

<code>const char*    gt_trans_table_description(const GtTransTable *tt)</code>
<p>
Returns the description of <code>tt</code>.
</p>
<hr>
<a name="gt_trans_table_translate_codon"></a>

<code>int            gt_trans_table_translate_codon(const GtTransTable *tt,
                                             char c1, char c2, char c3,
                                             char *amino, GtError *err)</code>
<p>
Writes the translation for the codon <code>c1</code>,<code>c2</code>,<code>c3</code> to the position pointed
   to by <code>amino</code>. The current translation scheme set in <code>translator</code> is used.
   Returns a negative value if an error occurred, see <code>err</code> for details.
   Otherwise, 0 is returned.
</p>
<hr>
<a name="gt_trans_table_delete"></a>

<code>void           gt_trans_table_delete(GtTransTable *tt)</code>
<p>
Deletes <code>tt</code>.
</p>
<hr>
<a name="GtTranslator"></a>
<h2>Class GtTranslator</h2>

<p> The <code>GtTranslator</code> can be used to  produce 3-frame translations of DNA
   sequences via an iterator interface. </p>

<hr>
<a name="gt_translator_new_with_table"></a>

<code>GtTranslator*       gt_translator_new_with_table(GtTransTable *tt,
                                                GtCodonIterator *ci)</code>
<p>
Creates a new <code>GtTranslator</code>, starting its translation at the current
   position of <code>ci</code>. The current reading frame is also taken from the state of
   <code>ci</code>. The translation table <code>tt</code> is used.
</p>
<hr>
<a name="gt_translator_new"></a>

<code>GtTranslator*       gt_translator_new(GtCodonIterator *ci)</code>
<p>
Creates a new <code>GtTranslator</code>, starting its translation at the current
   position of <code>ci</code>. The current reading frame is also taken from the state of
   <code>ci</code>. The standard translation table is used.
</p>
<hr>
<a name="gt_translator_set_codon_iterator"></a>

<code>void                gt_translator_set_codon_iterator(GtTranslator *translator,
                                                    GtCodonIterator *ci)</code>
<p>
Reinitializes <code>translator</code> with the position and frame status as given in
   <code>ci</code>.
</p>
<hr>
<a name="gt_translator_set_translation_table"></a>

<code>void                gt_translator_set_translation_table(GtTranslator *translator,
                                                       GtTransTable *tt)</code>
<p>
Selects the translation scheme in <code>translator</code> to the one identified by
   translation table <code>tt</code>.
</p>
<hr>
<a name="gt_translator_next"></a>

<code>GtTranslatorStatus  gt_translator_next(GtTranslator *translator,
                                      char *translated,
                                      unsigned int *frame,
                                      GtError *err)</code>
<p>
Returns the translation of the next codon. The currently translated
   character is put in <code>translated</code> while the current reading frame is put in
   <code>frame</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to translate has been reached,
   GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_startcodon"></a>

<code>GtTranslatorStatus  gt_translator_find_startcodon(GtTranslator *translator,
                                                 unsigned long *pos,
                                                 GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which is a start codon according to the selected translation
   scheme in <code>translator</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding a
   start codon, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_stopcodon"></a>

<code>GtTranslatorStatus  gt_translator_find_stopcodon(GtTranslator *translator,
                                                unsigned long *pos,
                                                GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which is a stop codon according to the selected translation
   scheme in <code>translator</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding a
   stop codon, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_find_codon"></a>

<code>GtTranslatorStatus  gt_translator_find_codon(GtTranslator *translator,
                                            GtStrArray *codons,
                                            unsigned long *pos,
                                            GtError *err)</code>
<p>
Moves the <code>translator</code> to the beginning of the first codon in <code>dnaseq</code> (of
   length <code>dnalen</code>) which belongs to the set of codons specified in <code>codons</code>.
   The offset is written to the location pointed to by <code>pos</code>.
   Returns GT_TRANSLATOR_ERROR if an error occurred, see <code>err</code> for details.
   If the end of the sequence region to scan has been reached without finding
   one of the codons, GT_TRANSLATOR_END is returned.
   Otherwise, GT_TRANSLATOR_OK (equal to 0) is returned.
</p>
<hr>
<a name="gt_translator_delete"></a>

<code>void                gt_translator_delete(GtTranslator *translator)</code>
<p>
Delete <code>translator</code>.
</p>
<hr>
<a name="GtTypeChecker"></a>
<h2>Class GtTypeChecker</h2>

<p> The <code>GtTypeChecker</code> interface, allows to check the validity of (genome
   feature) types. </p>

<hr>
<a name="gt_type_checker_ref"></a>

<code>GtTypeChecker*  gt_type_checker_ref(GtTypeChecker *type_checker)</code>
<p>
Increase the reference count for <code>type_checker</code> and return it.
</p>
<hr>
<a name="gt_type_checker_is_valid"></a>

<code>bool            gt_type_checker_is_valid(GtTypeChecker *type_checker,
                                        const char *type)</code>
<p>
Return <code>true</code> if <code>type</code> is a valid type for the given <code>type_checker</code>, <code>false</code>
   otherwise.
</p>
<hr>
<a name="gt_type_checker_delete"></a>

<code>void            gt_type_checker_delete(GtTypeChecker *type_checker)</code>
<p>
Decrease the reference count for <code>type_checker</code> or delete it, if this was the
   last reference.
</p>
<hr>
<a name="GtTypeCheckerOBO"></a>
<h2>Class GtTypeCheckerOBO</h2>

<p> Implements the <code>GtTypeChecker</code> interface with types from an OBO file. </p>

<hr>
<a name="gt_type_checker_obo_new"></a>

<code>GtTypeChecker*  gt_type_checker_obo_new(const char *obo_file_path, GtError *err)</code>
<p>
Create a new <code>GtTypeChecker*</code> for OBO file with given <code>obo_file_path</code>.
   If the OBO file cannot be parsed correctly, <code>NULL</code> is returned and <code>err</code> is
   set correspondingly.
</p>
<hr>
<a name="GtUniqStream"></a>
<h2>Class GtUniqStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. A <code>GtUniqStream</code> filters out
   repeated features it retrieves from its node source. </p>

<hr>
<a name="gt_uniq_stream_new"></a>

<code>GtNodeStream*  gt_uniq_stream_new(GtNodeStream*)</code>
<p>
Create a <code>GtUniqStream</code> object which filters out repeated feature node graphs
   it retrieves from the sorted <code>in_stream</code> and return all other nodes.  Two
   feature node graphs are considered to be <em>repeated</em> if they have the same
   depth-first traversal and each corresponding feature node pair is similar
   according to the <code>gt_feature_node_is_similar()</code> method. For such a repeated
   feature node graph the one with the higher score (of the top-level feature)
   is kept. If only one of the feature node graphs has a defined score, this one
   is kept.
</p>
<hr>
<a name="GtVisitorStream"></a>
<h2>Class GtVisitorStream</h2>

<p> Implements the <code>GtNodeStream</code> interface. </p>

<hr>
<a name="gt_visitor_stream_new"></a>

<code>GtNodeStream*  gt_visitor_stream_new(GtNodeStream *in_stream,
                                    GtNodeVisitor *node_visitor)</code>
<p>
Create a new <code>GtVisitorStream*</code>, takes ownership of <code>node_visitor</code>.
   This stream applies <code>node_visitor</code> to each node which passes through it.
   Can be used to implement all streams with such a functionality.
</p>
<hr>
<a name="Array2dim"></a>
<h2>Module Array2dim</h2>
<a name="gt_array2dim_malloc"></a>

<code>#define gt_array2dim_malloc(ARRAY2DIM, ROWS, COLUMNS)</code>
<p>
Allocates a new 2-dimensional array with dimensions <code>ROWS</code> x <code>COLUMNS</code> and
   assigns a pointer to the newly allocated space to <code>ARRAY2DIM</code>.
   The size of each element is determined automatically from the type of the
   <code>ARRAY2DIM</code> pointer.
</p>
<hr>
<a name="gt_array2dim_calloc"></a>

<code>#define gt_array2dim_calloc(ARRAY2DIM, ROWS, COLUMNS)</code>
<p>
Allocates a new 2-dimensional array with dimensions <code>ROWS</code> x <code>COLUMNS</code> and
   assigns a pointer to the newly allocated space to <code>ARRAY2DIM</code>.
   The allocated space is initialized to be filled with zeroes.
   The size of each element is determined automatically from the type of the
   <code>ARRAY2DIM</code> pointer.
</p>
<hr>
<a name="gt_array2dim_example"></a>

<code>int      gt_array2dim_example(GtError*)</code>
<p>
An example for usage of the <code>Array2dim</code> module.
</p>
<hr>
<a name="gt_array2dim_delete"></a>

<code>#define gt_array2dim_delete(ARRAY2DIM)</code>
<p>
Frees the space allocated for the 2-dimensional array pointed to by
   <code>ARRAY2DIM</code>.
</p>
<hr>
<a name="Assert"></a>
<h2>Module Assert</h2>
<a name="gt_assert"></a>

<code>#define gt_assert(expression)</code>
<p>
The <code>gt_assert()</code> macro tests the given <code>expression</code> and if it is false, the
   calling process is terminated. A diagnostic message is written to <code>stderr</code>
   and the <code>exit(3)</code> function is called (with error code 2 as argument),
   effectively terminating the program.
   If <code>expression</code> is true, the <code>gt_assert()</code> macro does nothing.
</p>
<hr>
<a name="Bsearch"></a>
<h2>Module Bsearch</h2>
<a name="gt_bsearch_data"></a>

<code>void*  gt_bsearch_data(const void *key, const void *base, size_t nmemb,
                      size_t size, GtCompareWithData, void *data)</code>
<p>
Similar interface to <code>bsearch(3)</code>, except that the <code>GtCompareWithData</code>
   function gets an additional <code>data</code> pointer.
</p>
<hr>
<a name="gt_bsearch_all"></a>

<code>void   gt_bsearch_all(GtArray *members, const void *key, const void *base,
                     size_t nmemb, size_t size, GtCompareWithData, void *data)</code>
<p>
Similar interface to <code>gt_bsearch_data()</code>, except that all members which
   compare as equal are stored in the <code>members</code> array. The order in which the
   elements are added is undefined.
</p>
<hr>
<a name="gt_bsearch_all_mark"></a>

<code>void   gt_bsearch_all_mark(GtArray *members, const void *key, const void *base,
                          size_t nmemb, size_t size, GtCompareWithData,
                          void *data, GtBittab*)</code>
<p>
Similar interface to <code>gt_bsearch_all()</code>. Additionally, if a bittab is given
   (which must be of size <code>nmemb</code>), the bits corresponding to the found
   elements are marked (i.e., set).
</p>
<hr>
<a name="Countingsort"></a>
<h2>Module Countingsort</h2>
<a name="gt_countingsort"></a>

<code>void           gt_countingsort(void *out, const void *in, size_t elem_size,
                              unsigned long size, unsigned long max_elemvalue,
                              void *data, GtGetElemvalue get_elemvalue)</code>
<p>
Sort the array of elements pointed to by <code>in</code> containing <code>size</code> many elements
   of size <code>elem_size</code> and store the result in the array <code>out</code> of the same size.
   <code>max_elemvalue</code> denotes the maximum value an element can have.
   <code>get_elemvalue</code> should return an integer value for the given element <code>elem</code>.

   Implements the counting sort algorithm.
   For a description see for example page 175 to page 177 of the book:

   T.H. Cormen, C.E. Leiserson and R.L. Rivest. <em>Introduction to Algorithms</em>.
   MIT Press: Cambridge, MA, 1990.
</p>
<hr>
<a name="gt_countingsort_get_max"></a>

<code>unsigned long  gt_countingsort_get_max(const void *in, size_t elem_size,
                                      unsigned long size, void *data,
                                      GtGetElemvalue get_elemvalue)</code>
<p>
If <code>max_elemvalue</code> is not known, it can be determined with this function.
</p>
<hr>
<a name="Cstr"></a>
<h2>Module Cstr</h2>
<a name="gt_cstr_dup"></a>

<code>char*          gt_cstr_dup(const char *cstr)</code>
<p>
Creates a duplicate of string <code>cstr</code> using the GenomeTools memory
   allocator.
</p>
<hr>
<a name="gt_cstr_dup_nt"></a>

<code>char*          gt_cstr_dup_nt(const char *cstr, unsigned long length)</code>
<p>
Creates a duplicate of string <code>cstr</code> using the GenomeTools memory allocator.
   The string needs not be \0-terminated, instead its <code>length</code> must be given.
</p>
<hr>
<a name="gt_cstr_rep"></a>

<code>void           gt_cstr_rep(char *cstr, char f, char t)</code>
<p>
Replace each occurence of <code>f</code> in <code>cstr</code> to <code>t</code>.
</p>
<hr>
<a name="gt_cstr_show"></a>

<code>void           gt_cstr_show(const char *cstr, unsigned long length, FILE *outfp)</code>
<p>
Outputs the first <code>length</code> characters of the string <code>cstr</code> to file pointer
   <code>outfp</code>.
</p>
<hr>
<a name="gt_cstr_length_up_to_char"></a>

<code>unsigned long  gt_cstr_length_up_to_char(const char *cstr, char c)</code>
<p>
Returns the length of the prefix of <code>cstr</code> ending just before <code>c</code>, if <code>cstr</code>
   does not contain <code>c</code>, strlen(cstr) is returned.
</p>
<hr>
<a name="gt_cstr_rtrim"></a>

<code>char*          gt_cstr_rtrim(char* cstr, char remove)</code>
<p>
Removes all occurrences of <code>remove</code> from the right end of <code>cstr</code>.
</p>
<hr>
<a name="Endianess"></a>
<h2>Module Endianess</h2>
<a name="gt_is_little_endian"></a>

<code>bool  gt_is_little_endian(void)</code>
<p>
Returns <code>true</code> if host CPU is little-endian, <code>false</code> otherwise.
</p>
<hr>
<a name="Fileutils"></a>
<h2>Module Fileutils</h2>
<a name="gt_file_exists"></a>

<code>bool            gt_file_exists(const char *path)</code>
<p>
Returns true if the file with the given <code>path</code> exists, false otherwise.
</p>
<hr>
<a name="gt_file_is_newer"></a>

<code>bool            gt_file_is_newer(const char *a, const char *b)</code>
<p>
Returns true if the file with path <code>a</code> has a later modification time than the
   file with path <code>b</code>, false otherwise.
</p>
<hr>
<a name="gt_file_number_of_lines"></a>

<code>unsigned long   gt_file_number_of_lines(const char*)</code>
<p>
Returns the number of lines in a file.
</p>
<hr>
<a name="gt_file_suffix"></a>

<code>const char*     gt_file_suffix(const char *path)</code>
<p>
Returns the suffix of <code>path</code>, if there is any. Returns "" otherwise.
   The suffix is the part after and including the last '.' but after the last
   '/'. Except if <code>path</code> ends with ".gz" or ".bz2", then the suffix is the part
   after and including the second last '.'.
</p>
<hr>
<a name="gt_file_dirname"></a>

<code>void            gt_file_dirname(GtStr *path, const char *file)</code>
<p>
Set <code>path</code> to the dirname of <code>file</code>, if it has one, to "" otherwise.
</p>
<hr>
<a name="gt_file_find_in_path"></a>

<code>int             gt_file_find_in_path(GtStr *path, const char *file, GtError*)</code>
<p>
Find <code>file</code> in $PATH, if it has no dirname; set <code>path</code> to dirname otherwise.
   Sets <code>path</code> to the empty string if <code>file</code> could not be found in $PATH.
</p>
<hr>
<a name="gt_file_find_in_env"></a>

<code>int             gt_file_find_in_env(GtStr *path, const char *file,
                                   const char *env, GtError*)</code>
<p>
Find  <code>file</code> in the ':'-separated directory list specified in environment
   variable $<code>env</code>, if it has no dirname; set <code>path</code> to dirname otherwise.
   Sets <code>path</code> to the empty string if <code>file</code> could not be found in $<code>env</code>.
</p>
<hr>
<a name="gt_file_estimate_size"></a>

<code>off_t           gt_file_estimate_size(const char *file)</code>
<p>
Return the (estimated) size of <code>file</code>. If <code>file</code> is uncompressed, the exact
   size is returned. If <code>file</code> is compressed, an estimation which assumes that
   <code>file</code> contains a DNA sequence is returned.
</p>
<hr>
<a name="gt_files_estimate_total_size"></a>

<code>off_t           gt_files_estimate_total_size(const GtStrArray *filenames)</code>
<p>
Return the (estimated) total size of all files given in <code>filenames</code>.
   Uses <code>gt_file_estimate_size()</code>.
</p>
<hr>
<a name="gt_files_guess_if_protein_sequences"></a>

<code>int             gt_files_guess_if_protein_sequences(const GtStrArray *filenames,
                                                   GtError *err)</code>
<p>
Guesse if the sequences contained in the files given in <code>filenames</code> are
   protein sequences. Returns 1 if the guess is that the files contain protein
   sequences. Returns 0 if the guess is that the files contain DNA sequences.
   Returns -1 if an error occurs while reading the files (<code>err</code> is set
   accordingly).
</p>
<hr>
<a name="FunctionPointer"></a>
<h2>Module FunctionPointer</h2>
<code>int  (*GtCompare)(const void *a, const void *b)</code>
<p>
 Functions of this type return less than 0 if <code>a</code> is <em>smaller</em> than <code>b</code>,
   0 if <code>a</code> is <em>equal</em> to <code>b</code>, and greater 0 if <code>a</code> is <em>larger</em> than <code>b</code>.
   Thereby, the operators <em>smaller</em>, <em>equal</em>, and <em>larger</em> are
   implementation dependent.
   Do not count on these functions to return -1, 0, or 1!  
</p>
<hr>
<code>int  (*GtCompareWithData)(const void*, const void*, void *data)</code>
<p>
 Similar to <code>GtCompare</code>, but with an additional <code>data</code> pointer. 
</p>
<hr>
<code>void (*GtFree)(void*)</code>
<p>
 The generic free function pointer type. 
</p>
<hr>
<a name="Grep"></a>
<h2>Module Grep</h2>
<a name="gt_grep"></a>

<code>int   gt_grep(bool *match, const char *pattern, const char *line, GtError*)</code>
<p>
Set <code>match</code> to <code>true</code> if <code>pattern</code> matches <code>line</code>, to <code>false</code> otherwise.
</p>
<hr>
<a name="Init"></a>
<h2>Module Init</h2>
<a name="gt_lib_init"></a>

<code>void  gt_lib_init(void)</code>
<p>
Initialize this <em>GenomeTools</em> library instance.
   This has to be called before the library is used!
</p>
<hr>
<a name="gt_lib_reg_atexit_func"></a>

<code>void  gt_lib_reg_atexit_func(void)</code>
<p>
Registers exit function which calls <code>gt_lib_clean()</code> at exit.
</p>
<hr>
<a name="gt_lib_clean"></a>

<code>int   gt_lib_clean(void)</code>
<p>
Returns 0 if no memory map, file pointer, or memory has been leaked and a
   value != 0 otherwise.
</p>
<hr>
<a name="Log"></a>
<h2>Module Log</h2>
<a name="gt_log_enable"></a>

<code>void  gt_log_enable(void)</code>
<p>
Enable logging.
</p>
<hr>
<a name="gt_log_enabled"></a>

<code>bool  gt_log_enabled(void)</code>
<p>
Returns true if logging is enabled, false otherwise
</p>
<hr>
<a name="gt_log_log"></a>

<code>void   gt_log_log(const char *format, ...)</code>
<p>
Prints the log message obtained from format and following parameters
   according if logging is enabled. The logging output is prefixed with the
   string "debug: " and finished by a newline.
</p>
<hr>
<a name="gt_log_vlog"></a>

<code>void   gt_log_vlog(const char *format, va_list)</code>
<p>
Prints the log message obtained from format and following parameter according
   to if logging is enabled analog to <code>gt_log_log()</code>. But in contrast to
   <code>gt_log_log()</code> <code>gt_log_vlog()</code> does not accept individual arguments but a single
   va_list argument instead.
</p>
<hr>
<a name="gt_log_fp"></a>

<code>FILE*  gt_log_fp(void)</code>
<p>
Return logging file pointer.
</p>
<hr>
<a name="gt_log_set_fp"></a>

<code>void   gt_log_set_fp(FILE *fp)</code>
<p>
Set logging file pointer to <code>fp</code>.
</p>
<hr>
<a name="MemoryAllocation"></a>
<h2>Module MemoryAllocation</h2>
<a name="gt_malloc"></a>

<code>#define gt_malloc(size)</code>
<p>
Allocate <strong>uninitialized</strong> space for an object whose size is specified by
   <code>size</code> and return it.
   Besides the fact that it never returns <code>NULL</code> analog to <code>malloc(3)</code>.
</p>
<hr>
<a name="gt_calloc"></a>

<code>#define gt_calloc(nmemb, size)</code>
<p>
Allocate contiguous space for an array of <code>nmemb</code> objects, each of whose size
   is <code>size</code>.  The space is initialized to zero.
   Besides the fact that it never returns <code>NULL</code> analog to <code>calloc(3)</code>.
</p>
<hr>
<a name="gt_realloc"></a>

<code>#define gt_realloc(ptr, size)</code>
<p>
Change the size of the object pointed to by <code>ptr</code> to <code>size</code> bytes and return
   a pointer to the (possibly moved) object.
   Besides the fact that it never returns <code>NULL</code> analog to <code>realloc(3)</code>.
</p>
<hr>
<a name="gt_free"></a>

<code>#define gt_free(ptr)</code>
<p>
Free the space pointed to by <code>ptr</code>. If <code>ptr</code> equals <code>NULL</code>, no action occurs.
   Analog to <code>free(3)</code>.
</p>
<hr>
<a name="gt_free_func"></a>

<code>void           gt_free_func(void *ptr)</code>
<p>
Analog to <code>gt_free()</code>, but usable as a function pointer.
</p>
<hr>
<a name="Msort"></a>
<h2>Module Msort</h2>
<a name="gt_msort"></a>

<code>void  gt_msort(void *base, size_t nmemb, size_t size, GtCompare compar)</code>
<p>
Sorts an array of <code>nmemb</code> elements, each of size <code>size</code>, according to compare
   function <code>compar</code>. Uses the merge sort algorithm, the interface equals
   <code>qsort(3)</code>.
</p>
<hr>
<a name="gt_msort_r"></a>

<code>void  gt_msort_r(void *base, size_t nmemb, size_t size, void *comparinfo,
                GtCompareWithData compar)</code>
<p>
Identical to <code>gt_msort()</code> except that the compare function is of
   <code>GtCompareWithData</code> type accepting <code>comparinfo</code> as arbitrary data.
</p>
<hr>
<a name="POSIX"></a>
<h2>Module POSIX</h2>
<a name="gt_basename"></a>

<code>char*  gt_basename(const char *path)</code>
<p>
This module implements the function <code>gt_basename()</code> according to the
  specifications in
  http://www.unix-systems.org/onlinepubs/7908799/xsh/basename.html
  and
  http://www.opengroup.org/onlinepubs/009695399/

  <code>gt_basename()</code> is equivalent to the function basename(3) which
  is available on most unix systems, but in different libraries and
  with slightly different functionality.

  <code>gt_basename()</code> takes the pathname pointed to by <code>path</code> and returns a pointer to
  the final component of the pathname, deleting any trailing '/' characters.

  If <code>path</code> consists entirely of the '/' character,  then <code>gt_basename()</code> returns
  a pointer to the string "/".

  If <code>path</code> is a null pointer or points to an empty string, <code>gt_basename()</code>
  returns a pointer to the string ".".

  See the implementation of <code>gt_basename_unit_test()</code> for additional examples.

  The caller is responsible for freeing the received pointer!
</p>
<hr>
<a name="Parseutils"></a>
<h2>Module Parseutils</h2>
<a name="gt_parse_int"></a>

<code>int  gt_parse_int(int *out, const char *nptr)</code>
<p>
Parse integer from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_uint"></a>

<code>int  gt_parse_uint(unsigned int *out, const char *nptr)</code>
<p>
Parse unsigned integer from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_long"></a>

<code>int  gt_parse_long(long *out, const char *nptr)</code>
<p>
Parse long from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_ulong"></a>

<code>int  gt_parse_ulong(unsigned long *out, const char *nptr)</code>
<p>
Parse unsigned long from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_double"></a>

<code>int  gt_parse_double(double *out, const char *nptr)</code>
<p>
Parse double from <code>nptr</code> and store result in <code>out</code>.
   Returns 0 upon success and -1 upon failure.
</p>
<hr>
<a name="gt_parse_range"></a>

<code>int  gt_parse_range(GtRange *rng, const char *start, const char *end,
                   unsigned int line_number, const char *filename, GtError*)</code>
<p>
Parse a range given by <code>start</code> and <code>end</code>, writing the result into <code>rng</code>.
   Enforces that <code>start</code> is smaller or equal than <code>end</code>. Give <code>filename</code> and
   <code>line_number</code> for error reporting. Returns 0 upon success and -1 upon
   failure.
</p>
<hr>
<a name="gt_parse_range_tidy"></a>

<code>int  gt_parse_range_tidy(GtRange *rng, const char *start, const char *end,
                        unsigned int line_number, const char *filename,
                        GtError*)</code>
<p>
Like <code>gt_parse_range</code>, but issues a warning if <code>start</code> is larger then <code>end</code>
   and swaps both values.
</p>
<hr>
<a name="Qsort"></a>
<h2>Module Qsort</h2>
<a name="gt_qsort_r"></a>

<code>void  gt_qsort_r(void *a, size_t n, size_t es, void *data,
                GtCompareWithData cmp)</code>
<p>
Like <code>qsort(3)</code>, but allows an additional <code>data</code> pointer passed to the
   <code>GtCompareWithData</code> comparison function <code>cmp</code>.
</p>
<hr>
<a name="Strcmp"></a>
<h2>Module Strcmp</h2>
<a name="gt_strcmp"></a>

<code>int  gt_strcmp(const char *s1, const char *s2)</code>
<p>
Returns 0 if <code>s1</code> == <code>s2</code>, otherwise the equivalent of <code>strcmp(s1,s2)</code>.
   Useful as a performance improvement in some cases (for example, to compare
   symbols).
</p>
<hr>
<a name="Symbol"></a>
<h2>Module Symbol</h2>
<a name="gt_symbol"></a>

<code>const char*  gt_symbol(const char *cstr)</code>
<p>
Return a symbol (a canonical representation) for <code>cstr</code>. An advantage of
   symbols is that they can be compared for equality by a simple pointer
   comparison, rather than using <code>strcmp()</code> (as it is done in <code>gt_strcmp()</code>).
   Furthermore, a symbol is stored only once in memory for equal <code>cstr</code>s, but
   keep in mind that this memory can never be freed safely during the lifetime
   of the calling program. Therefore, it should only be used for a small set of
   <code>cstr</code>s.
</p>
<hr>
<a name="Undef"></a>
<h2>Module Undef</h2>
<a name="GT_UNDEF_BOOL"></a>

<code>#define GT_UNDEF_BOOL</code>
<p>
The undefined <code>bool</code> value.
</p>
<hr>
<a name="GT_UNDEF_CHAR"></a>

<code>#define GT_UNDEF_CHAR</code>
<p>
The undefined <code>char</code> value.
</p>
<hr>
<a name="GT_UNDEF_DOUBLE"></a>

<code>#define GT_UNDEF_DOUBLE</code>
<p>
The undefined <code>double</code> value.
</p>
<hr>
<a name="GT_UNDEF_FLOAT"></a>

<code>#define GT_UNDEF_FLOAT</code>
<p>
The undefined <code>float</code> value.
</p>
<hr>
<a name="GT_UNDEF_INT"></a>

<code>#define GT_UNDEF_INT</code>
<p>
The undefined <code>int</code> value.
</p>
<hr>
<a name="GT_UNDEF_LONG"></a>

<code>#define GT_UNDEF_LONG</code>
<p>
The undefined <code>long</code> value.
</p>
<hr>
<a name="GT_UNDEF_UCHAR"></a>

<code>#define GT_UNDEF_UCHAR</code>
<p>
The undefined <code>unsigned char</code> value.
</p>
<hr>
<a name="GT_UNDEF_UINT"></a>

<code>#define GT_UNDEF_UINT</code>
<p>
The undefined <code>unsigned int</code> value.
</p>
<hr>
<a name="GT_UNDEF_ULONG"></a>

<code>#define GT_UNDEF_ULONG</code>
<p>
The undefined <code>unsigned long</code> value.
</p>
<hr>
<a name="Unused"></a>
<h2>Module Unused</h2>
<a name="GT_UNUSED"></a>

<code>#define GT_UNUSED</code>
<p>
Unused function arguments should be annotated with this macro to get rid of
   compiler warnings.
</p>
<hr>
<a name="Version"></a>
<h2>Module Version</h2>
<a name="gt_version_check"></a>

<code>const char*  gt_version_check(unsigned int required_major,
                             unsigned int required_minor,
                             unsigned int required_micro)</code>
<p>
Check that the <em>GenomeTools</em> library in use is compatible with the given
   version. Generally you would pass in the constants <code>GT_MAJOR_VERSION</code>,
   <code>GT_MINOR_VERSION</code>, and <code>GT_MICRO_VERSION</code> as the three arguments to this
   function.

   Returns <code>NULL</code> if the <em>GenomeTools</em> library is compatible with the given
   version, or a string describing the version mismatch, if the library is not
   compatible.
</p>
<hr>
<a name="Warning"></a>
<h2>Module Warning</h2>
<code>void (*GtWarningHandler)(void *data, const char *format, va_list ap)</code>
<p>
 Handler type used to process warnings. 
</p>
<hr>
<a name="gt_warning"></a>

<code>void  gt_warning(const char *format, ...)</code>
<p>
Print a warning according to <code>format</code> and <code>...</code>, if a handler is set.
</p>
<hr>
<a name="gt_warning_disable"></a>

<code>void  gt_warning_disable(void)</code>
<p>
Disable that warnings are shown. That is, subsequent <code>gt_warning()</code> calls
   have no effect.
</p>
<hr>
<a name="gt_warning_set_handler"></a>

<code>void  gt_warning_set_handler(GtWarningHandler warn_handler, void *data)</code>
<p>
Set <code>warn_handler</code> to handle all warnings issued with <code>gt_warning()</code>.
   The <code>data</code> is passed to <code>warning_handler</code> on each invocation.
</p>
<hr>
<a name="gt_warning_default_handler"></a>

<code>void  gt_warning_default_handler(void *data, const char *format, va_list ap)</code>
<p>
The default warning handler which prints on <code>stderr</code>.
   "warning: " is prepended and a newline is appended to the message defined by
   <code>format</code> and <code>ap</code>. Does not use <code>data</code>.
</p>
<hr>
<a name="gt_warning_get_handler"></a>

<code>GtWarningHandler  gt_warning_get_handler(void)</code>
<p>
Return currently used <code>GtWarningHandler</code>.
</p>
<hr>
<a name="gt_warning_get_data"></a>

<code>void*  gt_warning_get_data(void)</code>
<p>
Return currently used <code>data</code> which is passed to the currently used
   <code>GtWarningHandler</code>.
</p>
<hr>
<a name="XANSI"></a>
<h2>Module XANSI</h2>
<a name="gt_xatexit"></a>

<code>void    gt_xatexit(void (*function)</code>
<p>
Similar to <code>atexit(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfclose"></a>

<code>void    gt_xfclose(FILE*)</code>
<p>
Similar to <code>fclose(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfflush"></a>

<code>void    gt_xfflush(FILE*)</code>
<p>
Similar to <code>fflush(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgetc"></a>

<code>int     gt_xfgetc(FILE*)</code>
<p>
Similar to <code>fgetc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgets"></a>

<code>char*   gt_xfgets(char *s, int size, FILE *stream)</code>
<p>
Similar to <code>fgets(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfgetpos"></a>

<code>void    gt_xfgetpos(FILE*, fpos_t*)</code>
<p>
Similar to <code>fgetpos(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfopen"></a>

<code>FILE*   gt_xfopen(const char *path, const char *mode)</code>
<p>
Similar to <code>fopen(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfputc"></a>

<code>void    gt_xfputc(int, FILE*)</code>
<p>
Similar to <code>fputc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfputs"></a>

<code>void    gt_xfputs(const char*, FILE*)</code>
<p>
Similar to <code>fputs(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfread"></a>

<code>size_t  gt_xfread(void *ptr, size_t size, size_t nmemb, FILE*)</code>
<p>
Similar to <code>fread(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfseek"></a>

<code>void    gt_xfseek(FILE*, long offset, int whence)</code>
<p>
Similar to <code>fseek(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfsetpos"></a>

<code>void    gt_xfsetpos(FILE*, const fpos_t*)</code>
<p>
Similar to <code>fsetpos(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xfwrite"></a>

<code>void    gt_xfwrite(const void *ptr, size_t size, size_t nmemb, FILE*)</code>
<p>
Similar to <code>fwrite(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xputchar"></a>

<code>void    gt_xputchar(int)</code>
<p>
Similar to <code>putchar(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xputs"></a>

<code>void    gt_xputs(const char*)</code>
<p>
Similar to <code>puts(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xremove"></a>

<code>void    gt_xremove(const char*)</code>
<p>
Similar to <code>remove(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xungetc"></a>

<code>void    gt_xungetc(int, FILE*)</code>
<p>
Similar to <code>ungetc(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xvfprintf"></a>

<code>void    gt_xvfprintf(FILE *stream, const char *format, va_list ap)</code>
<p>
Similar to <code>vfprintf(3)</code>, terminates on error.
</p>
<hr>
<a name="gt_xvsnprintf"></a>

<code>int     gt_xvsnprintf(char *str, size_t size, const char *format, va_list ap)</code>
<p>
Similar to <code>vsnprintf(3)</code>, terminates on error.
</p>
<hr>
<a name="Index"></a>
<h2>Index</h2>

  <a href="#GT_OPTION_PARSER_TERMINAL_WIDTH"><code>GT_OPTION_PARSER_TERMINAL_WIDTH</code></a><br>

  <a href="#GT_PHASE_CHARS"><code>GT_PHASE_CHARS</code></a><br>

  <a href="#GT_STRAND_CHARS"><code>GT_STRAND_CHARS</code></a><br>

  <a href="#GT_UNDEF_BOOL"><code>GT_UNDEF_BOOL</code></a><br>

  <a href="#GT_UNDEF_CHAR"><code>GT_UNDEF_CHAR</code></a><br>

  <a href="#GT_UNDEF_DOUBLE"><code>GT_UNDEF_DOUBLE</code></a><br>

  <a href="#GT_UNDEF_FLOAT"><code>GT_UNDEF_FLOAT</code></a><br>

  <a href="#GT_UNDEF_INT"><code>GT_UNDEF_INT</code></a><br>

  <a href="#GT_UNDEF_LONG"><code>GT_UNDEF_LONG</code></a><br>

  <a href="#GT_UNDEF_UCHAR"><code>GT_UNDEF_UCHAR</code></a><br>

  <a href="#GT_UNDEF_UINT"><code>GT_UNDEF_UINT</code></a><br>

  <a href="#GT_UNDEF_ULONG"><code>GT_UNDEF_ULONG</code></a><br>

  <a href="#GT_UNUSED"><code>GT_UNUSED</code></a><br>

  <a href="#gt_add_introns_stream_new"><code>gt_add_introns_stream_new</code></a><br>

  <a href="#gt_alphabet_add_mapping"><code>gt_alphabet_add_mapping</code></a><br>

  <a href="#gt_alphabet_add_wildcard"><code>gt_alphabet_add_wildcard</code></a><br>

  <a href="#gt_alphabet_bits_per_symbol"><code>gt_alphabet_bits_per_symbol</code></a><br>

  <a href="#gt_alphabet_characters"><code>gt_alphabet_characters</code></a><br>

  <a href="#gt_alphabet_clone"><code>gt_alphabet_clone</code></a><br>

  <a href="#gt_alphabet_decode"><code>gt_alphabet_decode</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_cstr"><code>gt_alphabet_decode_seq_to_cstr</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_fp"><code>gt_alphabet_decode_seq_to_fp</code></a><br>

  <a href="#gt_alphabet_decode_seq_to_str"><code>gt_alphabet_decode_seq_to_str</code></a><br>

  <a href="#gt_alphabet_delete"><code>gt_alphabet_delete</code></a><br>

  <a href="#gt_alphabet_echo_pretty_symbol"><code>gt_alphabet_echo_pretty_symbol</code></a><br>

  <a href="#gt_alphabet_encode"><code>gt_alphabet_encode</code></a><br>

  <a href="#gt_alphabet_encode_seq"><code>gt_alphabet_encode_seq</code></a><br>

  <a href="#gt_alphabet_guess"><code>gt_alphabet_guess</code></a><br>

  <a href="#gt_alphabet_is_dna"><code>gt_alphabet_is_dna</code></a><br>

  <a href="#gt_alphabet_is_protein"><code>gt_alphabet_is_protein</code></a><br>

  <a href="#gt_alphabet_new_dna"><code>gt_alphabet_new_dna</code></a><br>

  <a href="#gt_alphabet_new_empty"><code>gt_alphabet_new_empty</code></a><br>

  <a href="#gt_alphabet_new_from_file"><code>gt_alphabet_new_from_file</code></a><br>

  <a href="#gt_alphabet_new_from_file_no_suffix"><code>gt_alphabet_new_from_file_no_suffix</code></a><br>

  <a href="#gt_alphabet_new_from_sequence"><code>gt_alphabet_new_from_sequence</code></a><br>

  <a href="#gt_alphabet_new_from_string"><code>gt_alphabet_new_from_string</code></a><br>

  <a href="#gt_alphabet_new_protein"><code>gt_alphabet_new_protein</code></a><br>

  <a href="#gt_alphabet_num_of_chars"><code>gt_alphabet_num_of_chars</code></a><br>

  <a href="#gt_alphabet_output"><code>gt_alphabet_output</code></a><br>

  <a href="#gt_alphabet_pretty_symbol"><code>gt_alphabet_pretty_symbol</code></a><br>

  <a href="#gt_alphabet_ref"><code>gt_alphabet_ref</code></a><br>

  <a href="#gt_alphabet_size"><code>gt_alphabet_size</code></a><br>

  <a href="#gt_alphabet_symbolmap"><code>gt_alphabet_symbolmap</code></a><br>

  <a href="#gt_alphabet_to_file"><code>gt_alphabet_to_file</code></a><br>

  <a href="#gt_alphabet_to_str"><code>gt_alphabet_to_str</code></a><br>

  <a href="#gt_alphabet_valid_input"><code>gt_alphabet_valid_input</code></a><br>

  <a href="#gt_alphabet_wildcard_show"><code>gt_alphabet_wildcard_show</code></a><br>

  <a href="#gt_array2dim_calloc"><code>gt_array2dim_calloc</code></a><br>

  <a href="#gt_array2dim_delete"><code>gt_array2dim_delete</code></a><br>

  <a href="#gt_array2dim_example"><code>gt_array2dim_example</code></a><br>

  <a href="#gt_array2dim_malloc"><code>gt_array2dim_malloc</code></a><br>

  <a href="#gt_array_add"><code>gt_array_add</code></a><br>

  <a href="#gt_array_add_array"><code>gt_array_add_array</code></a><br>

  <a href="#gt_array_add_elem"><code>gt_array_add_elem</code></a><br>

  <a href="#gt_array_clone"><code>gt_array_clone</code></a><br>

  <a href="#gt_array_cmp"><code>gt_array_cmp</code></a><br>

  <a href="#gt_array_delete"><code>gt_array_delete</code></a><br>

  <a href="#gt_array_elem_size"><code>gt_array_elem_size</code></a><br>

  <a href="#gt_array_get"><code>gt_array_get</code></a><br>

  <a href="#gt_array_get_first"><code>gt_array_get_first</code></a><br>

  <a href="#gt_array_get_last"><code>gt_array_get_last</code></a><br>

  <a href="#gt_array_get_space"><code>gt_array_get_space</code></a><br>

  <a href="#gt_array_new"><code>gt_array_new</code></a><br>

  <a href="#gt_array_pop"><code>gt_array_pop</code></a><br>

  <a href="#gt_array_ref"><code>gt_array_ref</code></a><br>

  <a href="#gt_array_rem"><code>gt_array_rem</code></a><br>

  <a href="#gt_array_rem_span"><code>gt_array_rem_span</code></a><br>

  <a href="#gt_array_reset"><code>gt_array_reset</code></a><br>

  <a href="#gt_array_reverse"><code>gt_array_reverse</code></a><br>

  <a href="#gt_array_set_size"><code>gt_array_set_size</code></a><br>

  <a href="#gt_array_size"><code>gt_array_size</code></a><br>

  <a href="#gt_array_sort"><code>gt_array_sort</code></a><br>

  <a href="#gt_array_sort_stable"><code>gt_array_sort_stable</code></a><br>

  <a href="#gt_array_sort_stable_with_data"><code>gt_array_sort_stable_with_data</code></a><br>

  <a href="#gt_array_sort_with_data"><code>gt_array_sort_with_data</code></a><br>

  <a href="#gt_assert"><code>gt_assert</code></a><br>

  <a href="#gt_basename"><code>gt_basename</code></a><br>

  <a href="#gt_bed_in_stream_new"><code>gt_bed_in_stream_new</code></a><br>

  <a href="#gt_bed_in_stream_set_block_type"><code>gt_bed_in_stream_set_block_type</code></a><br>

  <a href="#gt_bed_in_stream_set_feature_type"><code>gt_bed_in_stream_set_feature_type</code></a><br>

  <a href="#gt_bed_in_stream_set_thick_feature_type"><code>gt_bed_in_stream_set_thick_feature_type</code></a><br>

  <a href="#gt_bittab_and"><code>gt_bittab_and</code></a><br>

  <a href="#gt_bittab_and_equal"><code>gt_bittab_and_equal</code></a><br>

  <a href="#gt_bittab_bit_is_set"><code>gt_bittab_bit_is_set</code></a><br>

  <a href="#gt_bittab_cmp"><code>gt_bittab_cmp</code></a><br>

  <a href="#gt_bittab_complement"><code>gt_bittab_complement</code></a><br>

  <a href="#gt_bittab_count_set_bits"><code>gt_bittab_count_set_bits</code></a><br>

  <a href="#gt_bittab_delete"><code>gt_bittab_delete</code></a><br>

  <a href="#gt_bittab_equal"><code>gt_bittab_equal</code></a><br>

  <a href="#gt_bittab_get_all_bitnums"><code>gt_bittab_get_all_bitnums</code></a><br>

  <a href="#gt_bittab_get_first_bitnum"><code>gt_bittab_get_first_bitnum</code></a><br>

  <a href="#gt_bittab_get_last_bitnum"><code>gt_bittab_get_last_bitnum</code></a><br>

  <a href="#gt_bittab_get_next_bitnum"><code>gt_bittab_get_next_bitnum</code></a><br>

  <a href="#gt_bittab_nand"><code>gt_bittab_nand</code></a><br>

  <a href="#gt_bittab_new"><code>gt_bittab_new</code></a><br>

  <a href="#gt_bittab_or"><code>gt_bittab_or</code></a><br>

  <a href="#gt_bittab_or_equal"><code>gt_bittab_or_equal</code></a><br>

  <a href="#gt_bittab_set_bit"><code>gt_bittab_set_bit</code></a><br>

  <a href="#gt_bittab_shift_left_equal"><code>gt_bittab_shift_left_equal</code></a><br>

  <a href="#gt_bittab_shift_right_equal"><code>gt_bittab_shift_right_equal</code></a><br>

  <a href="#gt_bittab_show"><code>gt_bittab_show</code></a><br>

  <a href="#gt_bittab_size"><code>gt_bittab_size</code></a><br>

  <a href="#gt_bittab_unset"><code>gt_bittab_unset</code></a><br>

  <a href="#gt_bittab_unset_bit"><code>gt_bittab_unset_bit</code></a><br>

  <a href="#gt_block_caption_is_visible"><code>gt_block_caption_is_visible</code></a><br>

  <a href="#gt_block_clone"><code>gt_block_clone</code></a><br>

  <a href="#gt_block_delete"><code>gt_block_delete</code></a><br>

  <a href="#gt_block_get_caption"><code>gt_block_get_caption</code></a><br>

  <a href="#gt_block_get_range"><code>gt_block_get_range</code></a><br>

  <a href="#gt_block_get_range_ptr"><code>gt_block_get_range_ptr</code></a><br>

  <a href="#gt_block_get_size"><code>gt_block_get_size</code></a><br>

  <a href="#gt_block_get_strand"><code>gt_block_get_strand</code></a><br>

  <a href="#gt_block_get_top_level_feature"><code>gt_block_get_top_level_feature</code></a><br>

  <a href="#gt_block_has_only_one_fullsize_element"><code>gt_block_has_only_one_fullsize_element</code></a><br>

  <a href="#gt_block_merge"><code>gt_block_merge</code></a><br>

  <a href="#gt_block_new"><code>gt_block_new</code></a><br>

  <a href="#gt_block_new_from_node"><code>gt_block_new_from_node</code></a><br>

  <a href="#gt_block_ref"><code>gt_block_ref</code></a><br>

  <a href="#gt_block_set_caption"><code>gt_block_set_caption</code></a><br>

  <a href="#gt_block_set_caption_visibility"><code>gt_block_set_caption_visibility</code></a><br>

  <a href="#gt_block_set_strand"><code>gt_block_set_strand</code></a><br>

  <a href="#gt_bsearch_all"><code>gt_bsearch_all</code></a><br>

  <a href="#gt_bsearch_all_mark"><code>gt_bsearch_all_mark</code></a><br>

  <a href="#gt_bsearch_data"><code>gt_bsearch_data</code></a><br>

  <a href="#gt_calloc"><code>gt_calloc</code></a><br>

  <a href="#gt_canvas_cairo_context_new"><code>gt_canvas_cairo_context_new</code></a><br>

  <a href="#gt_canvas_cairo_file_new"><code>gt_canvas_cairo_file_new</code></a><br>

  <a href="#gt_canvas_cairo_file_to_file"><code>gt_canvas_cairo_file_to_file</code></a><br>

  <a href="#gt_canvas_cairo_file_to_stream"><code>gt_canvas_cairo_file_to_stream</code></a><br>

  <a href="#gt_canvas_delete"><code>gt_canvas_delete</code></a><br>

  <a href="#gt_canvas_get_height"><code>gt_canvas_get_height</code></a><br>

  <a href="#gt_cds_stream_new"><code>gt_cds_stream_new</code></a><br>

  <a href="#gt_codon_iterator_current_position"><code>gt_codon_iterator_current_position</code></a><br>

  <a href="#gt_codon_iterator_delete"><code>gt_codon_iterator_delete</code></a><br>

  <a href="#gt_codon_iterator_length"><code>gt_codon_iterator_length</code></a><br>

  <a href="#gt_codon_iterator_next"><code>gt_codon_iterator_next</code></a><br>

  <a href="#gt_codon_iterator_rewind"><code>gt_codon_iterator_rewind</code></a><br>

  <a href="#gt_color_delete"><code>gt_color_delete</code></a><br>

  <a href="#gt_color_equals"><code>gt_color_equals</code></a><br>

  <a href="#gt_color_new"><code>gt_color_new</code></a><br>

  <a href="#gt_color_set"><code>gt_color_set</code></a><br>

  <a href="#gt_comment_node_get_comment"><code>gt_comment_node_get_comment</code></a><br>

  <a href="#gt_comment_node_new"><code>gt_comment_node_new</code></a><br>

  <a href="#gt_countingsort"><code>gt_countingsort</code></a><br>

  <a href="#gt_countingsort_get_max"><code>gt_countingsort_get_max</code></a><br>

  <a href="#gt_csa_stream_new"><code>gt_csa_stream_new</code></a><br>

  <a href="#gt_cstr_dup"><code>gt_cstr_dup</code></a><br>

  <a href="#gt_cstr_dup_nt"><code>gt_cstr_dup_nt</code></a><br>

  <a href="#gt_cstr_length_up_to_char"><code>gt_cstr_length_up_to_char</code></a><br>

  <a href="#gt_cstr_rep"><code>gt_cstr_rep</code></a><br>

  <a href="#gt_cstr_rtrim"><code>gt_cstr_rtrim</code></a><br>

  <a href="#gt_cstr_show"><code>gt_cstr_show</code></a><br>

  <a href="#gt_cstr_table_add"><code>gt_cstr_table_add</code></a><br>

  <a href="#gt_cstr_table_delete"><code>gt_cstr_table_delete</code></a><br>

  <a href="#gt_cstr_table_get"><code>gt_cstr_table_get</code></a><br>

  <a href="#gt_cstr_table_get_all"><code>gt_cstr_table_get_all</code></a><br>

  <a href="#gt_cstr_table_new"><code>gt_cstr_table_new</code></a><br>

  <a href="#gt_custom_track_delete"><code>gt_custom_track_delete</code></a><br>

  <a href="#gt_custom_track_gc_content_new"><code>gt_custom_track_gc_content_new</code></a><br>

  <a href="#gt_custom_track_ref"><code>gt_custom_track_ref</code></a><br>

  <a href="#gt_custom_track_script_wrapper_new"><code>gt_custom_track_script_wrapper_new</code></a><br>

  <a href="#gt_diagram_add_custom_track"><code>gt_diagram_add_custom_track</code></a><br>

  <a href="#gt_diagram_delete"><code>gt_diagram_delete</code></a><br>

  <a href="#gt_diagram_get_range"><code>gt_diagram_get_range</code></a><br>

  <a href="#gt_diagram_new"><code>gt_diagram_new</code></a><br>

  <a href="#gt_diagram_new_from_array"><code>gt_diagram_new_from_array</code></a><br>

  <a href="#gt_diagram_reset_track_selector_func"><code>gt_diagram_reset_track_selector_func</code></a><br>

  <a href="#gt_diagram_set_track_selector_func"><code>gt_diagram_set_track_selector_func</code></a><br>

  <a href="#gt_dlist_add"><code>gt_dlist_add</code></a><br>

  <a href="#gt_dlist_delete"><code>gt_dlist_delete</code></a><br>

  <a href="#gt_dlist_example"><code>gt_dlist_example</code></a><br>

  <a href="#gt_dlist_find"><code>gt_dlist_find</code></a><br>

  <a href="#gt_dlist_first"><code>gt_dlist_first</code></a><br>

  <a href="#gt_dlist_last"><code>gt_dlist_last</code></a><br>

  <a href="#gt_dlist_new"><code>gt_dlist_new</code></a><br>

  <a href="#gt_dlist_remove"><code>gt_dlist_remove</code></a><br>

  <a href="#gt_dlist_size"><code>gt_dlist_size</code></a><br>

  <a href="#gt_dlistelem_get_data"><code>gt_dlistelem_get_data</code></a><br>

  <a href="#gt_dlistelem_next"><code>gt_dlistelem_next</code></a><br>

  <a href="#gt_dlistelem_previous"><code>gt_dlistelem_previous</code></a><br>

  <a href="#gt_encseq_alphabet"><code>gt_encseq_alphabet</code></a><br>

  <a href="#gt_encseq_builder_add_cstr"><code>gt_encseq_builder_add_cstr</code></a><br>

  <a href="#gt_encseq_builder_add_encoded"><code>gt_encseq_builder_add_encoded</code></a><br>

  <a href="#gt_encseq_builder_add_encoded_own"><code>gt_encseq_builder_add_encoded_own</code></a><br>

  <a href="#gt_encseq_builder_add_str"><code>gt_encseq_builder_add_str</code></a><br>

  <a href="#gt_encseq_builder_build"><code>gt_encseq_builder_build</code></a><br>

  <a href="#gt_encseq_builder_create_des_tab"><code>gt_encseq_builder_create_des_tab</code></a><br>

  <a href="#gt_encseq_builder_create_esq_tab"><code>gt_encseq_builder_create_esq_tab</code></a><br>

  <a href="#gt_encseq_builder_create_sds_tab"><code>gt_encseq_builder_create_sds_tab</code></a><br>

  <a href="#gt_encseq_builder_create_ssp_tab"><code>gt_encseq_builder_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_builder_delete"><code>gt_encseq_builder_delete</code></a><br>

  <a href="#gt_encseq_builder_disable_description_support"><code>gt_encseq_builder_disable_description_support</code></a><br>

  <a href="#gt_encseq_builder_disable_multiseq_support"><code>gt_encseq_builder_disable_multiseq_support</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_des_tab"><code>gt_encseq_builder_do_not_create_des_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_esq_tab"><code>gt_encseq_builder_do_not_create_esq_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_sds_tab"><code>gt_encseq_builder_do_not_create_sds_tab</code></a><br>

  <a href="#gt_encseq_builder_do_not_create_ssp_tab"><code>gt_encseq_builder_do_not_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_builder_enable_description_support"><code>gt_encseq_builder_enable_description_support</code></a><br>

  <a href="#gt_encseq_builder_enable_multiseq_support"><code>gt_encseq_builder_enable_multiseq_support</code></a><br>

  <a href="#gt_encseq_builder_new"><code>gt_encseq_builder_new</code></a><br>

  <a href="#gt_encseq_builder_reset"><code>gt_encseq_builder_reset</code></a><br>

  <a href="#gt_encseq_builder_set_logger"><code>gt_encseq_builder_set_logger</code></a><br>

  <a href="#gt_encseq_create_reader_with_readmode"><code>gt_encseq_create_reader_with_readmode</code></a><br>

  <a href="#gt_encseq_delete"><code>gt_encseq_delete</code></a><br>

  <a href="#gt_encseq_description"><code>gt_encseq_description</code></a><br>

  <a href="#gt_encseq_effective_filelength"><code>gt_encseq_effective_filelength</code></a><br>

  <a href="#gt_encseq_encoder_create_des_tab"><code>gt_encseq_encoder_create_des_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_sds_tab"><code>gt_encseq_encoder_create_sds_tab</code></a><br>

  <a href="#gt_encseq_encoder_create_ssp_tab"><code>gt_encseq_encoder_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_encoder_delete"><code>gt_encseq_encoder_delete</code></a><br>

  <a href="#gt_encseq_encoder_des_tab_requested"><code>gt_encseq_encoder_des_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_disable_description_support"><code>gt_encseq_encoder_disable_description_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_lossless_support"><code>gt_encseq_encoder_disable_lossless_support</code></a><br>

  <a href="#gt_encseq_encoder_disable_multiseq_support"><code>gt_encseq_encoder_disable_multiseq_support</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_des_tab"><code>gt_encseq_encoder_do_not_create_des_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_sds_tab"><code>gt_encseq_encoder_do_not_create_sds_tab</code></a><br>

  <a href="#gt_encseq_encoder_do_not_create_ssp_tab"><code>gt_encseq_encoder_do_not_create_ssp_tab</code></a><br>

  <a href="#gt_encseq_encoder_enable_description_support"><code>gt_encseq_encoder_enable_description_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_lossless_support"><code>gt_encseq_encoder_enable_lossless_support</code></a><br>

  <a href="#gt_encseq_encoder_enable_multiseq_support"><code>gt_encseq_encoder_enable_multiseq_support</code></a><br>

  <a href="#gt_encseq_encoder_encode"><code>gt_encseq_encoder_encode</code></a><br>

  <a href="#gt_encseq_encoder_get_timer"><code>gt_encseq_encoder_get_timer</code></a><br>

  <a href="#gt_encseq_encoder_is_input_dna"><code>gt_encseq_encoder_is_input_dna</code></a><br>

  <a href="#gt_encseq_encoder_is_input_protein"><code>gt_encseq_encoder_is_input_protein</code></a><br>

  <a href="#gt_encseq_encoder_new"><code>gt_encseq_encoder_new</code></a><br>

  <a href="#gt_encseq_encoder_representation"><code>gt_encseq_encoder_representation</code></a><br>

  <a href="#gt_encseq_encoder_sds_tab_requested"><code>gt_encseq_encoder_sds_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_set_input_dna"><code>gt_encseq_encoder_set_input_dna</code></a><br>

  <a href="#gt_encseq_encoder_set_input_protein"><code>gt_encseq_encoder_set_input_protein</code></a><br>

  <a href="#gt_encseq_encoder_set_logger"><code>gt_encseq_encoder_set_logger</code></a><br>

  <a href="#gt_encseq_encoder_set_timer"><code>gt_encseq_encoder_set_timer</code></a><br>

  <a href="#gt_encseq_encoder_ssp_tab_requested"><code>gt_encseq_encoder_ssp_tab_requested</code></a><br>

  <a href="#gt_encseq_encoder_symbolmap_file"><code>gt_encseq_encoder_symbolmap_file</code></a><br>

  <a href="#gt_encseq_encoder_use_representation"><code>gt_encseq_encoder_use_representation</code></a><br>

  <a href="#gt_encseq_encoder_use_symbolmap_file"><code>gt_encseq_encoder_use_symbolmap_file</code></a><br>

  <a href="#gt_encseq_extract_decoded"><code>gt_encseq_extract_decoded</code></a><br>

  <a href="#gt_encseq_extract_encoded"><code>gt_encseq_extract_encoded</code></a><br>

  <a href="#gt_encseq_filenames"><code>gt_encseq_filenames</code></a><br>

  <a href="#gt_encseq_filenum"><code>gt_encseq_filenum</code></a><br>

  <a href="#gt_encseq_filestartpos"><code>gt_encseq_filestartpos</code></a><br>

  <a href="#gt_encseq_get_decoded_char"><code>gt_encseq_get_decoded_char</code></a><br>

  <a href="#gt_encseq_get_encoded_char"><code>gt_encseq_get_encoded_char</code></a><br>

  <a href="#gt_encseq_has_description_support"><code>gt_encseq_has_description_support</code></a><br>

  <a href="#gt_encseq_has_multiseq_support"><code>gt_encseq_has_multiseq_support</code></a><br>

  <a href="#gt_encseq_is_64_bit"><code>gt_encseq_is_64_bit</code></a><br>

  <a href="#gt_encseq_is_mirrored"><code>gt_encseq_is_mirrored</code></a><br>

  <a href="#gt_encseq_loader_delete"><code>gt_encseq_loader_delete</code></a><br>

  <a href="#gt_encseq_loader_des_tab_required"><code>gt_encseq_loader_des_tab_required</code></a><br>

  <a href="#gt_encseq_loader_disable_autosupport"><code>gt_encseq_loader_disable_autosupport</code></a><br>

  <a href="#gt_encseq_loader_do_not_mirror"><code>gt_encseq_loader_do_not_mirror</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_des_tab"><code>gt_encseq_loader_do_not_require_des_tab</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_sds_tab"><code>gt_encseq_loader_do_not_require_sds_tab</code></a><br>

  <a href="#gt_encseq_loader_do_not_require_ssp_tab"><code>gt_encseq_loader_do_not_require_ssp_tab</code></a><br>

  <a href="#gt_encseq_loader_drop_description_support"><code>gt_encseq_loader_drop_description_support</code></a><br>

  <a href="#gt_encseq_loader_drop_lossless_support"><code>gt_encseq_loader_drop_lossless_support</code></a><br>

  <a href="#gt_encseq_loader_drop_multiseq_support"><code>gt_encseq_loader_drop_multiseq_support</code></a><br>

  <a href="#gt_encseq_loader_enable_autosupport"><code>gt_encseq_loader_enable_autosupport</code></a><br>

  <a href="#gt_encseq_loader_load"><code>gt_encseq_loader_load</code></a><br>

  <a href="#gt_encseq_loader_mirror"><code>gt_encseq_loader_mirror</code></a><br>

  <a href="#gt_encseq_loader_new"><code>gt_encseq_loader_new</code></a><br>

  <a href="#gt_encseq_loader_require_des_tab"><code>gt_encseq_loader_require_des_tab</code></a><br>

  <a href="#gt_encseq_loader_require_description_support"><code>gt_encseq_loader_require_description_support</code></a><br>

  <a href="#gt_encseq_loader_require_lossless_support"><code>gt_encseq_loader_require_lossless_support</code></a><br>

  <a href="#gt_encseq_loader_require_multiseq_support"><code>gt_encseq_loader_require_multiseq_support</code></a><br>

  <a href="#gt_encseq_loader_require_sds_tab"><code>gt_encseq_loader_require_sds_tab</code></a><br>

  <a href="#gt_encseq_loader_require_ssp_tab"><code>gt_encseq_loader_require_ssp_tab</code></a><br>

  <a href="#gt_encseq_loader_sds_tab_required"><code>gt_encseq_loader_sds_tab_required</code></a><br>

  <a href="#gt_encseq_loader_set_logger"><code>gt_encseq_loader_set_logger</code></a><br>

  <a href="#gt_encseq_loader_ssp_tab_required"><code>gt_encseq_loader_ssp_tab_required</code></a><br>

  <a href="#gt_encseq_max_seq_length"><code>gt_encseq_max_seq_length</code></a><br>

  <a href="#gt_encseq_min_seq_length"><code>gt_encseq_min_seq_length</code></a><br>

  <a href="#gt_encseq_mirror"><code>gt_encseq_mirror</code></a><br>

  <a href="#gt_encseq_num_of_files"><code>gt_encseq_num_of_files</code></a><br>

  <a href="#gt_encseq_num_of_sequences"><code>gt_encseq_num_of_sequences</code></a><br>

  <a href="#gt_encseq_position_is_separator"><code>gt_encseq_position_is_separator</code></a><br>

  <a href="#gt_encseq_reader_delete"><code>gt_encseq_reader_delete</code></a><br>

  <a href="#gt_encseq_reader_next_decoded_char"><code>gt_encseq_reader_next_decoded_char</code></a><br>

  <a href="#gt_encseq_reader_next_encoded_char"><code>gt_encseq_reader_next_encoded_char</code></a><br>

  <a href="#gt_encseq_reader_reinit_with_readmode"><code>gt_encseq_reader_reinit_with_readmode</code></a><br>

  <a href="#gt_encseq_ref"><code>gt_encseq_ref</code></a><br>

  <a href="#gt_encseq_seqlength"><code>gt_encseq_seqlength</code></a><br>

  <a href="#gt_encseq_seqnum"><code>gt_encseq_seqnum</code></a><br>

  <a href="#gt_encseq_seqstartpos"><code>gt_encseq_seqstartpos</code></a><br>

  <a href="#gt_encseq_total_length"><code>gt_encseq_total_length</code></a><br>

  <a href="#gt_encseq_unmirror"><code>gt_encseq_unmirror</code></a><br>

  <a href="#gt_encseq_version"><code>gt_encseq_version</code></a><br>

  <a href="#gt_eof_node_new"><code>gt_eof_node_new</code></a><br>

  <a href="#gt_error_check"><code>gt_error_check</code></a><br>

  <a href="#gt_error_delete"><code>gt_error_delete</code></a><br>

  <a href="#gt_error_get"><code>gt_error_get</code></a><br>

  <a href="#gt_error_is_set"><code>gt_error_is_set</code></a><br>

  <a href="#gt_error_new"><code>gt_error_new</code></a><br>

  <a href="#gt_error_set"><code>gt_error_set</code></a><br>

  <a href="#gt_error_set_nonvariadic"><code>gt_error_set_nonvariadic</code></a><br>

  <a href="#gt_error_unset"><code>gt_error_unset</code></a><br>

  <a href="#gt_error_vset"><code>gt_error_vset</code></a><br>

  <a href="#gt_extract_feature_stream_new"><code>gt_extract_feature_stream_new</code></a><br>

  <a href="#gt_feature_index_add_feature_node"><code>gt_feature_index_add_feature_node</code></a><br>

  <a href="#gt_feature_index_add_gff3file"><code>gt_feature_index_add_gff3file</code></a><br>

  <a href="#gt_feature_index_add_region_node"><code>gt_feature_index_add_region_node</code></a><br>

  <a href="#gt_feature_index_delete"><code>gt_feature_index_delete</code></a><br>

  <a href="#gt_feature_index_get_features_for_range"><code>gt_feature_index_get_features_for_range</code></a><br>

  <a href="#gt_feature_index_get_features_for_seqid"><code>gt_feature_index_get_features_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_first_seqid"><code>gt_feature_index_get_first_seqid</code></a><br>

  <a href="#gt_feature_index_get_range_for_seqid"><code>gt_feature_index_get_range_for_seqid</code></a><br>

  <a href="#gt_feature_index_get_seqids"><code>gt_feature_index_get_seqids</code></a><br>

  <a href="#gt_feature_index_has_seqid"><code>gt_feature_index_has_seqid</code></a><br>

  <a href="#gt_feature_index_memory_new"><code>gt_feature_index_memory_new</code></a><br>

  <a href="#gt_feature_node_add_attribute"><code>gt_feature_node_add_attribute</code></a><br>

  <a href="#gt_feature_node_add_child"><code>gt_feature_node_add_child</code></a><br>

  <a href="#gt_feature_node_get_attribute"><code>gt_feature_node_get_attribute</code></a><br>

  <a href="#gt_feature_node_get_attribute_list"><code>gt_feature_node_get_attribute_list</code></a><br>

  <a href="#gt_feature_node_get_multi_representative"><code>gt_feature_node_get_multi_representative</code></a><br>

  <a href="#gt_feature_node_get_phase"><code>gt_feature_node_get_phase</code></a><br>

  <a href="#gt_feature_node_get_score"><code>gt_feature_node_get_score</code></a><br>

  <a href="#gt_feature_node_get_source"><code>gt_feature_node_get_source</code></a><br>

  <a href="#gt_feature_node_get_strand"><code>gt_feature_node_get_strand</code></a><br>

  <a href="#gt_feature_node_get_type"><code>gt_feature_node_get_type</code></a><br>

  <a href="#gt_feature_node_has_source"><code>gt_feature_node_has_source</code></a><br>

  <a href="#gt_feature_node_has_type"><code>gt_feature_node_has_type</code></a><br>

  <a href="#gt_feature_node_is_multi"><code>gt_feature_node_is_multi</code></a><br>

  <a href="#gt_feature_node_is_pseudo"><code>gt_feature_node_is_pseudo</code></a><br>

  <a href="#gt_feature_node_is_similar"><code>gt_feature_node_is_similar</code></a><br>

  <a href="#gt_feature_node_iterator_delete"><code>gt_feature_node_iterator_delete</code></a><br>

  <a href="#gt_feature_node_iterator_new"><code>gt_feature_node_iterator_new</code></a><br>

  <a href="#gt_feature_node_iterator_new_direct"><code>gt_feature_node_iterator_new_direct</code></a><br>

  <a href="#gt_feature_node_iterator_next"><code>gt_feature_node_iterator_next</code></a><br>

  <a href="#gt_feature_node_make_multi_representative"><code>gt_feature_node_make_multi_representative</code></a><br>

  <a href="#gt_feature_node_new"><code>gt_feature_node_new</code></a><br>

  <a href="#gt_feature_node_new_pseudo"><code>gt_feature_node_new_pseudo</code></a><br>

  <a href="#gt_feature_node_new_pseudo_template"><code>gt_feature_node_new_pseudo_template</code></a><br>

  <a href="#gt_feature_node_new_standard_gene"><code>gt_feature_node_new_standard_gene</code></a><br>

  <a href="#gt_feature_node_score_is_defined"><code>gt_feature_node_score_is_defined</code></a><br>

  <a href="#gt_feature_node_set_attribute"><code>gt_feature_node_set_attribute</code></a><br>

  <a href="#gt_feature_node_set_multi_representative"><code>gt_feature_node_set_multi_representative</code></a><br>

  <a href="#gt_feature_node_set_phase"><code>gt_feature_node_set_phase</code></a><br>

  <a href="#gt_feature_node_set_score"><code>gt_feature_node_set_score</code></a><br>

  <a href="#gt_feature_node_set_source"><code>gt_feature_node_set_source</code></a><br>

  <a href="#gt_feature_node_set_strand"><code>gt_feature_node_set_strand</code></a><br>

  <a href="#gt_feature_node_set_type"><code>gt_feature_node_set_type</code></a><br>

  <a href="#gt_feature_node_unset_multi"><code>gt_feature_node_unset_multi</code></a><br>

  <a href="#gt_feature_node_unset_score"><code>gt_feature_node_unset_score</code></a><br>

  <a href="#gt_file_delete"><code>gt_file_delete</code></a><br>

  <a href="#gt_file_dirname"><code>gt_file_dirname</code></a><br>

  <a href="#gt_file_estimate_size"><code>gt_file_estimate_size</code></a><br>

  <a href="#gt_file_exists"><code>gt_file_exists</code></a><br>

  <a href="#gt_file_find_in_env"><code>gt_file_find_in_env</code></a><br>

  <a href="#gt_file_find_in_path"><code>gt_file_find_in_path</code></a><br>

  <a href="#gt_file_is_newer"><code>gt_file_is_newer</code></a><br>

  <a href="#gt_file_new"><code>gt_file_new</code></a><br>

  <a href="#gt_file_number_of_lines"><code>gt_file_number_of_lines</code></a><br>

  <a href="#gt_file_suffix"><code>gt_file_suffix</code></a><br>

  <a href="#gt_file_xfgetc"><code>gt_file_xfgetc</code></a><br>

  <a href="#gt_file_xfputs"><code>gt_file_xfputs</code></a><br>

  <a href="#gt_file_xprintf"><code>gt_file_xprintf</code></a><br>

  <a href="#gt_file_xread"><code>gt_file_xread</code></a><br>

  <a href="#gt_file_xrewind"><code>gt_file_xrewind</code></a><br>

  <a href="#gt_file_xwrite"><code>gt_file_xwrite</code></a><br>

  <a href="#gt_files_estimate_total_size"><code>gt_files_estimate_total_size</code></a><br>

  <a href="#gt_files_guess_if_protein_sequences"><code>gt_files_guess_if_protein_sequences</code></a><br>

  <a href="#gt_free"><code>gt_free</code></a><br>

  <a href="#gt_free_func"><code>gt_free_func</code></a><br>

  <a href="#gt_genome_node_accept"><code>gt_genome_node_accept</code></a><br>

  <a href="#gt_genome_node_add_user_data"><code>gt_genome_node_add_user_data</code></a><br>

  <a href="#gt_genome_node_cmp"><code>gt_genome_node_cmp</code></a><br>

  <a href="#gt_genome_node_delete"><code>gt_genome_node_delete</code></a><br>

  <a href="#gt_genome_node_get_end"><code>gt_genome_node_get_end</code></a><br>

  <a href="#gt_genome_node_get_filename"><code>gt_genome_node_get_filename</code></a><br>

  <a href="#gt_genome_node_get_length"><code>gt_genome_node_get_length</code></a><br>

  <a href="#gt_genome_node_get_line_number"><code>gt_genome_node_get_line_number</code></a><br>

  <a href="#gt_genome_node_get_range"><code>gt_genome_node_get_range</code></a><br>

  <a href="#gt_genome_node_get_seqid"><code>gt_genome_node_get_seqid</code></a><br>

  <a href="#gt_genome_node_get_start"><code>gt_genome_node_get_start</code></a><br>

  <a href="#gt_genome_node_get_user_data"><code>gt_genome_node_get_user_data</code></a><br>

  <a href="#gt_genome_node_ref"><code>gt_genome_node_ref</code></a><br>

  <a href="#gt_genome_node_release_user_data"><code>gt_genome_node_release_user_data</code></a><br>

  <a href="#gt_genome_node_set_range"><code>gt_genome_node_set_range</code></a><br>

  <a href="#gt_gff3_in_stream_check_id_attributes"><code>gt_gff3_in_stream_check_id_attributes</code></a><br>

  <a href="#gt_gff3_in_stream_enable_tidy_mode"><code>gt_gff3_in_stream_enable_tidy_mode</code></a><br>

  <a href="#gt_gff3_in_stream_new_sorted"><code>gt_gff3_in_stream_new_sorted</code></a><br>

  <a href="#gt_gff3_in_stream_new_unsorted"><code>gt_gff3_in_stream_new_unsorted</code></a><br>

  <a href="#gt_gff3_in_stream_show_progress_bar"><code>gt_gff3_in_stream_show_progress_bar</code></a><br>

  <a href="#gt_gff3_out_stream_new"><code>gt_gff3_out_stream_new</code></a><br>

  <a href="#gt_gff3_out_stream_retain_id_attributes"><code>gt_gff3_out_stream_retain_id_attributes</code></a><br>

  <a href="#gt_gff3_out_stream_set_fasta_width"><code>gt_gff3_out_stream_set_fasta_width</code></a><br>

  <a href="#gt_gff3_parser_check_id_attributes"><code>gt_gff3_parser_check_id_attributes</code></a><br>

  <a href="#gt_gff3_parser_check_region_boundaries"><code>gt_gff3_parser_check_region_boundaries</code></a><br>

  <a href="#gt_gff3_parser_delete"><code>gt_gff3_parser_delete</code></a><br>

  <a href="#gt_gff3_parser_do_not_check_region_boundaries"><code>gt_gff3_parser_do_not_check_region_boundaries</code></a><br>

  <a href="#gt_gff3_parser_enable_tidy_mode"><code>gt_gff3_parser_enable_tidy_mode</code></a><br>

  <a href="#gt_gff3_parser_new"><code>gt_gff3_parser_new</code></a><br>

  <a href="#gt_gff3_parser_parse_genome_nodes"><code>gt_gff3_parser_parse_genome_nodes</code></a><br>

  <a href="#gt_gff3_parser_reset"><code>gt_gff3_parser_reset</code></a><br>

  <a href="#gt_gff3_parser_set_offset"><code>gt_gff3_parser_set_offset</code></a><br>

  <a href="#gt_gff3_visitor_new"><code>gt_gff3_visitor_new</code></a><br>

  <a href="#gt_gff3_visitor_retain_id_attributes"><code>gt_gff3_visitor_retain_id_attributes</code></a><br>

  <a href="#gt_gff3_visitor_set_fasta_width"><code>gt_gff3_visitor_set_fasta_width</code></a><br>

  <a href="#gt_graphics_delete"><code>gt_graphics_delete</code></a><br>

  <a href="#gt_graphics_draw_arrowhead"><code>gt_graphics_draw_arrowhead</code></a><br>

  <a href="#gt_graphics_draw_box"><code>gt_graphics_draw_box</code></a><br>

  <a href="#gt_graphics_draw_caret"><code>gt_graphics_draw_caret</code></a><br>

  <a href="#gt_graphics_draw_colored_text"><code>gt_graphics_draw_colored_text</code></a><br>

  <a href="#gt_graphics_draw_curve_data"><code>gt_graphics_draw_curve_data</code></a><br>

  <a href="#gt_graphics_draw_dashes"><code>gt_graphics_draw_dashes</code></a><br>

  <a href="#gt_graphics_draw_horizontal_line"><code>gt_graphics_draw_horizontal_line</code></a><br>

  <a href="#gt_graphics_draw_line"><code>gt_graphics_draw_line</code></a><br>

  <a href="#gt_graphics_draw_rectangle"><code>gt_graphics_draw_rectangle</code></a><br>

  <a href="#gt_graphics_draw_text"><code>gt_graphics_draw_text</code></a><br>

  <a href="#gt_graphics_draw_text_centered"><code>gt_graphics_draw_text_centered</code></a><br>

  <a href="#gt_graphics_draw_text_clip"><code>gt_graphics_draw_text_clip</code></a><br>

  <a href="#gt_graphics_draw_text_left"><code>gt_graphics_draw_text_left</code></a><br>

  <a href="#gt_graphics_draw_text_right"><code>gt_graphics_draw_text_right</code></a><br>

  <a href="#gt_graphics_draw_vertical_line"><code>gt_graphics_draw_vertical_line</code></a><br>

  <a href="#gt_graphics_get_image_height"><code>gt_graphics_get_image_height</code></a><br>

  <a href="#gt_graphics_get_image_width"><code>gt_graphics_get_image_width</code></a><br>

  <a href="#gt_graphics_get_text_height"><code>gt_graphics_get_text_height</code></a><br>

  <a href="#gt_graphics_get_text_width"><code>gt_graphics_get_text_width</code></a><br>

  <a href="#gt_graphics_get_xmargins"><code>gt_graphics_get_xmargins</code></a><br>

  <a href="#gt_graphics_get_ymargins"><code>gt_graphics_get_ymargins</code></a><br>

  <a href="#gt_graphics_save_to_file"><code>gt_graphics_save_to_file</code></a><br>

  <a href="#gt_graphics_save_to_stream"><code>gt_graphics_save_to_stream</code></a><br>

  <a href="#gt_graphics_set_background_color"><code>gt_graphics_set_background_color</code></a><br>

  <a href="#gt_graphics_set_font"><code>gt_graphics_set_font</code></a><br>

  <a href="#gt_graphics_set_margins"><code>gt_graphics_set_margins</code></a><br>

  <a href="#gt_grep"><code>gt_grep</code></a><br>

  <a href="#gt_gtf_in_stream_new"><code>gt_gtf_in_stream_new</code></a><br>

  <a href="#gt_gtf_out_stream_new"><code>gt_gtf_out_stream_new</code></a><br>

  <a href="#gt_hashmap_add"><code>gt_hashmap_add</code></a><br>

  <a href="#gt_hashmap_delete"><code>gt_hashmap_delete</code></a><br>

  <a href="#gt_hashmap_foreach"><code>gt_hashmap_foreach</code></a><br>

  <a href="#gt_hashmap_foreach_in_key_order"><code>gt_hashmap_foreach_in_key_order</code></a><br>

  <a href="#gt_hashmap_foreach_ordered"><code>gt_hashmap_foreach_ordered</code></a><br>

  <a href="#gt_hashmap_get"><code>gt_hashmap_get</code></a><br>

  <a href="#gt_hashmap_new"><code>gt_hashmap_new</code></a><br>

  <a href="#gt_hashmap_remove"><code>gt_hashmap_remove</code></a><br>

  <a href="#gt_hashmap_reset"><code>gt_hashmap_reset</code></a><br>

  <a href="#gt_id_to_md5_stream_new"><code>gt_id_to_md5_stream_new</code></a><br>

  <a href="#gt_image_info_delete"><code>gt_image_info_delete</code></a><br>

  <a href="#gt_image_info_get_height"><code>gt_image_info_get_height</code></a><br>

  <a href="#gt_image_info_get_rec_map"><code>gt_image_info_get_rec_map</code></a><br>

  <a href="#gt_image_info_new"><code>gt_image_info_new</code></a><br>

  <a href="#gt_image_info_num_of_rec_maps"><code>gt_image_info_num_of_rec_maps</code></a><br>

  <a href="#gt_inter_feature_stream_new"><code>gt_inter_feature_stream_new</code></a><br>

  <a href="#gt_interval_tree_delete"><code>gt_interval_tree_delete</code></a><br>

  <a href="#gt_interval_tree_find_all_overlapping"><code>gt_interval_tree_find_all_overlapping</code></a><br>

  <a href="#gt_interval_tree_find_first_overlapping"><code>gt_interval_tree_find_first_overlapping</code></a><br>

  <a href="#gt_interval_tree_insert"><code>gt_interval_tree_insert</code></a><br>

  <a href="#gt_interval_tree_new"><code>gt_interval_tree_new</code></a><br>

  <a href="#gt_interval_tree_node_get_data"><code>gt_interval_tree_node_get_data</code></a><br>

  <a href="#gt_interval_tree_node_new"><code>gt_interval_tree_node_new</code></a><br>

  <a href="#gt_interval_tree_size"><code>gt_interval_tree_size</code></a><br>

  <a href="#gt_interval_tree_traverse"><code>gt_interval_tree_traverse</code></a><br>

  <a href="#gt_is_little_endian"><code>gt_is_little_endian</code></a><br>

  <a href="#gt_layout_delete"><code>gt_layout_delete</code></a><br>

  <a href="#gt_layout_get_height"><code>gt_layout_get_height</code></a><br>

  <a href="#gt_layout_new"><code>gt_layout_new</code></a><br>

  <a href="#gt_layout_new_with_twc"><code>gt_layout_new_with_twc</code></a><br>

  <a href="#gt_layout_set_track_ordering_func"><code>gt_layout_set_track_ordering_func</code></a><br>

  <a href="#gt_layout_sketch"><code>gt_layout_sketch</code></a><br>

  <a href="#gt_lib_clean"><code>gt_lib_clean</code></a><br>

  <a href="#gt_lib_init"><code>gt_lib_init</code></a><br>

  <a href="#gt_lib_reg_atexit_func"><code>gt_lib_reg_atexit_func</code></a><br>

  <a href="#gt_log_enable"><code>gt_log_enable</code></a><br>

  <a href="#gt_log_enabled"><code>gt_log_enabled</code></a><br>

  <a href="#gt_log_fp"><code>gt_log_fp</code></a><br>

  <a href="#gt_log_log"><code>gt_log_log</code></a><br>

  <a href="#gt_log_set_fp"><code>gt_log_set_fp</code></a><br>

  <a href="#gt_log_vlog"><code>gt_log_vlog</code></a><br>

  <a href="#gt_logger_delete"><code>gt_logger_delete</code></a><br>

  <a href="#gt_logger_disable"><code>gt_logger_disable</code></a><br>

  <a href="#gt_logger_enable"><code>gt_logger_enable</code></a><br>

  <a href="#gt_logger_enabled"><code>gt_logger_enabled</code></a><br>

  <a href="#gt_logger_log"><code>gt_logger_log</code></a><br>

  <a href="#gt_logger_log_force"><code>gt_logger_log_force</code></a><br>

  <a href="#gt_logger_log_va"><code>gt_logger_log_va</code></a><br>

  <a href="#gt_logger_log_va_force"><code>gt_logger_log_va_force</code></a><br>

  <a href="#gt_logger_new"><code>gt_logger_new</code></a><br>

  <a href="#gt_logger_set_target"><code>gt_logger_set_target</code></a><br>

  <a href="#gt_logger_target"><code>gt_logger_target</code></a><br>

  <a href="#gt_malloc"><code>gt_malloc</code></a><br>

  <a href="#gt_md5_to_id_stream_new"><code>gt_md5_to_id_stream_new</code></a><br>

  <a href="#gt_merge_feature_stream_new"><code>gt_merge_feature_stream_new</code></a><br>

  <a href="#gt_merge_stream_new"><code>gt_merge_stream_new</code></a><br>

  <a href="#gt_msort"><code>gt_msort</code></a><br>

  <a href="#gt_msort_r"><code>gt_msort_r</code></a><br>

  <a href="#gt_node_stream_cast"><code>gt_node_stream_cast</code></a><br>

  <a href="#gt_node_stream_class_new"><code>gt_node_stream_class_new</code></a><br>

  <a href="#gt_node_stream_create"><code>gt_node_stream_create</code></a><br>

  <a href="#gt_node_stream_delete"><code>gt_node_stream_delete</code></a><br>

  <a href="#gt_node_stream_is_sorted"><code>gt_node_stream_is_sorted</code></a><br>

  <a href="#gt_node_stream_next"><code>gt_node_stream_next</code></a><br>

  <a href="#gt_node_stream_pull"><code>gt_node_stream_pull</code></a><br>

  <a href="#gt_node_stream_ref"><code>gt_node_stream_ref</code></a><br>

  <a href="#gt_node_visitor_delete"><code>gt_node_visitor_delete</code></a><br>

  <a href="#gt_node_visitor_visit_comment_node"><code>gt_node_visitor_visit_comment_node</code></a><br>

  <a href="#gt_node_visitor_visit_feature_node"><code>gt_node_visitor_visit_feature_node</code></a><br>

  <a href="#gt_node_visitor_visit_region_node"><code>gt_node_visitor_visit_region_node</code></a><br>

  <a href="#gt_node_visitor_visit_sequence_node"><code>gt_node_visitor_visit_sequence_node</code></a><br>

  <a href="#gt_option_argument_is_optional"><code>gt_option_argument_is_optional</code></a><br>

  <a href="#gt_option_delete"><code>gt_option_delete</code></a><br>

  <a href="#gt_option_exclude"><code>gt_option_exclude</code></a><br>

  <a href="#gt_option_get_name"><code>gt_option_get_name</code></a><br>

  <a href="#gt_option_hide_default"><code>gt_option_hide_default</code></a><br>

  <a href="#gt_option_imply"><code>gt_option_imply</code></a><br>

  <a href="#gt_option_imply_either_2"><code>gt_option_imply_either_2</code></a><br>

  <a href="#gt_option_is_development_option"><code>gt_option_is_development_option</code></a><br>

  <a href="#gt_option_is_extended_option"><code>gt_option_is_extended_option</code></a><br>

  <a href="#gt_option_is_mandatory"><code>gt_option_is_mandatory</code></a><br>

  <a href="#gt_option_is_mandatory_either"><code>gt_option_is_mandatory_either</code></a><br>

  <a href="#gt_option_is_mandatory_either_3"><code>gt_option_is_mandatory_either_3</code></a><br>

  <a href="#gt_option_is_set"><code>gt_option_is_set</code></a><br>

  <a href="#gt_option_new_bool"><code>gt_option_new_bool</code></a><br>

  <a href="#gt_option_new_choice"><code>gt_option_new_choice</code></a><br>

  <a href="#gt_option_new_debug"><code>gt_option_new_debug</code></a><br>

  <a href="#gt_option_new_double"><code>gt_option_new_double</code></a><br>

  <a href="#gt_option_new_double_min"><code>gt_option_new_double_min</code></a><br>

  <a href="#gt_option_new_double_min_max"><code>gt_option_new_double_min_max</code></a><br>

  <a href="#gt_option_new_filename"><code>gt_option_new_filename</code></a><br>

  <a href="#gt_option_new_filename_array"><code>gt_option_new_filename_array</code></a><br>

  <a href="#gt_option_new_int"><code>gt_option_new_int</code></a><br>

  <a href="#gt_option_new_int_max"><code>gt_option_new_int_max</code></a><br>

  <a href="#gt_option_new_int_min"><code>gt_option_new_int_min</code></a><br>

  <a href="#gt_option_new_int_min_max"><code>gt_option_new_int_min_max</code></a><br>

  <a href="#gt_option_new_long"><code>gt_option_new_long</code></a><br>

  <a href="#gt_option_new_probability"><code>gt_option_new_probability</code></a><br>

  <a href="#gt_option_new_range"><code>gt_option_new_range</code></a><br>

  <a href="#gt_option_new_range_min_max"><code>gt_option_new_range_min_max</code></a><br>

  <a href="#gt_option_new_string"><code>gt_option_new_string</code></a><br>

  <a href="#gt_option_new_string_array"><code>gt_option_new_string_array</code></a><br>

  <a href="#gt_option_new_uint"><code>gt_option_new_uint</code></a><br>

  <a href="#gt_option_new_uint_max"><code>gt_option_new_uint_max</code></a><br>

  <a href="#gt_option_new_uint_min"><code>gt_option_new_uint_min</code></a><br>

  <a href="#gt_option_new_uint_min_max"><code>gt_option_new_uint_min_max</code></a><br>

  <a href="#gt_option_new_ulong"><code>gt_option_new_ulong</code></a><br>

  <a href="#gt_option_new_ulong_min"><code>gt_option_new_ulong_min</code></a><br>

  <a href="#gt_option_new_ulong_min_max"><code>gt_option_new_ulong_min_max</code></a><br>

  <a href="#gt_option_new_verbose"><code>gt_option_new_verbose</code></a><br>

  <a href="#gt_option_new_width"><code>gt_option_new_width</code></a><br>

  <a href="#gt_option_parse_spacespec"><code>gt_option_parse_spacespec</code></a><br>

  <a href="#gt_option_parser_add_option"><code>gt_option_parser_add_option</code></a><br>

  <a href="#gt_option_parser_delete"><code>gt_option_parser_delete</code></a><br>

  <a href="#gt_option_parser_get_option"><code>gt_option_parser_get_option</code></a><br>

  <a href="#gt_option_parser_new"><code>gt_option_parser_new</code></a><br>

  <a href="#gt_option_parser_parse"><code>gt_option_parser_parse</code></a><br>

  <a href="#gt_option_parser_refer_to_manual"><code>gt_option_parser_refer_to_manual</code></a><br>

  <a href="#gt_option_parser_register_hook"><code>gt_option_parser_register_hook</code></a><br>

  <a href="#gt_option_parser_set_comment_func"><code>gt_option_parser_set_comment_func</code></a><br>

  <a href="#gt_option_parser_set_mail_address"><code>gt_option_parser_set_mail_address</code></a><br>

  <a href="#gt_option_parser_set_max_args"><code>gt_option_parser_set_max_args</code></a><br>

  <a href="#gt_option_parser_set_min_args"><code>gt_option_parser_set_min_args</code></a><br>

  <a href="#gt_option_parser_set_min_max_args"><code>gt_option_parser_set_min_max_args</code></a><br>

  <a href="#gt_option_parser_set_version_func"><code>gt_option_parser_set_version_func</code></a><br>

  <a href="#gt_option_ref"><code>gt_option_ref</code></a><br>

  <a href="#gt_parse_double"><code>gt_parse_double</code></a><br>

  <a href="#gt_parse_int"><code>gt_parse_int</code></a><br>

  <a href="#gt_parse_long"><code>gt_parse_long</code></a><br>

  <a href="#gt_parse_range"><code>gt_parse_range</code></a><br>

  <a href="#gt_parse_range_tidy"><code>gt_parse_range_tidy</code></a><br>

  <a href="#gt_parse_uint"><code>gt_parse_uint</code></a><br>

  <a href="#gt_parse_ulong"><code>gt_parse_ulong</code></a><br>

  <a href="#gt_phase_get"><code>gt_phase_get</code></a><br>

  <a href="#gt_qsort_r"><code>gt_qsort_r</code></a><br>

  <a href="#gt_queue_add"><code>gt_queue_add</code></a><br>

  <a href="#gt_queue_delete"><code>gt_queue_delete</code></a><br>

  <a href="#gt_queue_get"><code>gt_queue_get</code></a><br>

  <a href="#gt_queue_head"><code>gt_queue_head</code></a><br>

  <a href="#gt_queue_new"><code>gt_queue_new</code></a><br>

  <a href="#gt_queue_remove"><code>gt_queue_remove</code></a><br>

  <a href="#gt_queue_size"><code>gt_queue_size</code></a><br>

  <a href="#gt_range_compare"><code>gt_range_compare</code></a><br>

  <a href="#gt_range_compare_with_delta"><code>gt_range_compare_with_delta</code></a><br>

  <a href="#gt_range_contains"><code>gt_range_contains</code></a><br>

  <a href="#gt_range_join"><code>gt_range_join</code></a><br>

  <a href="#gt_range_length"><code>gt_range_length</code></a><br>

  <a href="#gt_range_offset"><code>gt_range_offset</code></a><br>

  <a href="#gt_range_overlap"><code>gt_range_overlap</code></a><br>

  <a href="#gt_range_overlap_delta"><code>gt_range_overlap_delta</code></a><br>

  <a href="#gt_range_within"><code>gt_range_within</code></a><br>

  <a href="#gt_readmode_parse"><code>gt_readmode_parse</code></a><br>

  <a href="#gt_readmode_show"><code>gt_readmode_show</code></a><br>

  <a href="#gt_realloc"><code>gt_realloc</code></a><br>

  <a href="#gt_rec_map_get_genome_feature"><code>gt_rec_map_get_genome_feature</code></a><br>

  <a href="#gt_rec_map_get_northwest_x"><code>gt_rec_map_get_northwest_x</code></a><br>

  <a href="#gt_rec_map_get_northwest_y"><code>gt_rec_map_get_northwest_y</code></a><br>

  <a href="#gt_rec_map_get_southeast_x"><code>gt_rec_map_get_southeast_x</code></a><br>

  <a href="#gt_rec_map_get_southeast_y"><code>gt_rec_map_get_southeast_y</code></a><br>

  <a href="#gt_rec_map_has_omitted_children"><code>gt_rec_map_has_omitted_children</code></a><br>

  <a href="#gt_region_mapping_delete"><code>gt_region_mapping_delete</code></a><br>

  <a href="#gt_region_mapping_get_description"><code>gt_region_mapping_get_description</code></a><br>

  <a href="#gt_region_mapping_get_md5_fingerprint"><code>gt_region_mapping_get_md5_fingerprint</code></a><br>

  <a href="#gt_region_mapping_get_raw_sequence"><code>gt_region_mapping_get_raw_sequence</code></a><br>

  <a href="#gt_region_mapping_new_mapping"><code>gt_region_mapping_new_mapping</code></a><br>

  <a href="#gt_region_mapping_new_rawseq"><code>gt_region_mapping_new_rawseq</code></a><br>

  <a href="#gt_region_mapping_new_seqfiles"><code>gt_region_mapping_new_seqfiles</code></a><br>

  <a href="#gt_region_mapping_ref"><code>gt_region_mapping_ref</code></a><br>

  <a href="#gt_region_node_new"><code>gt_region_node_new</code></a><br>

  <a href="#gt_select_stream_new"><code>gt_select_stream_new</code></a><br>

  <a href="#gt_sequence_node_get_description"><code>gt_sequence_node_get_description</code></a><br>

  <a href="#gt_sequence_node_get_sequence"><code>gt_sequence_node_get_sequence</code></a><br>

  <a href="#gt_sequence_node_get_sequence_length"><code>gt_sequence_node_get_sequence_length</code></a><br>

  <a href="#gt_sequence_node_new"><code>gt_sequence_node_new</code></a><br>

  <a href="#gt_sort_stream_new"><code>gt_sort_stream_new</code></a><br>

  <a href="#gt_splitter_delete"><code>gt_splitter_delete</code></a><br>

  <a href="#gt_splitter_get_token"><code>gt_splitter_get_token</code></a><br>

  <a href="#gt_splitter_get_tokens"><code>gt_splitter_get_tokens</code></a><br>

  <a href="#gt_splitter_new"><code>gt_splitter_new</code></a><br>

  <a href="#gt_splitter_reset"><code>gt_splitter_reset</code></a><br>

  <a href="#gt_splitter_size"><code>gt_splitter_size</code></a><br>

  <a href="#gt_splitter_split"><code>gt_splitter_split</code></a><br>

  <a href="#gt_stat_stream_new"><code>gt_stat_stream_new</code></a><br>

  <a href="#gt_stat_stream_show_stats"><code>gt_stat_stream_show_stats</code></a><br>

  <a href="#gt_str_append_char"><code>gt_str_append_char</code></a><br>

  <a href="#gt_str_append_cstr"><code>gt_str_append_cstr</code></a><br>

  <a href="#gt_str_append_cstr_nt"><code>gt_str_append_cstr_nt</code></a><br>

  <a href="#gt_str_append_double"><code>gt_str_append_double</code></a><br>

  <a href="#gt_str_append_int"><code>gt_str_append_int</code></a><br>

  <a href="#gt_str_append_str"><code>gt_str_append_str</code></a><br>

  <a href="#gt_str_append_uint"><code>gt_str_append_uint</code></a><br>

  <a href="#gt_str_append_ulong"><code>gt_str_append_ulong</code></a><br>

  <a href="#gt_str_array_add"><code>gt_str_array_add</code></a><br>

  <a href="#gt_str_array_add_cstr"><code>gt_str_array_add_cstr</code></a><br>

  <a href="#gt_str_array_add_cstr_nt"><code>gt_str_array_add_cstr_nt</code></a><br>

  <a href="#gt_str_array_delete"><code>gt_str_array_delete</code></a><br>

  <a href="#gt_str_array_get"><code>gt_str_array_get</code></a><br>

  <a href="#gt_str_array_new"><code>gt_str_array_new</code></a><br>

  <a href="#gt_str_array_ref"><code>gt_str_array_ref</code></a><br>

  <a href="#gt_str_array_reset"><code>gt_str_array_reset</code></a><br>

  <a href="#gt_str_array_set"><code>gt_str_array_set</code></a><br>

  <a href="#gt_str_array_set_cstr"><code>gt_str_array_set_cstr</code></a><br>

  <a href="#gt_str_array_set_size"><code>gt_str_array_set_size</code></a><br>

  <a href="#gt_str_array_size"><code>gt_str_array_size</code></a><br>

  <a href="#gt_str_clone"><code>gt_str_clone</code></a><br>

  <a href="#gt_str_cmp"><code>gt_str_cmp</code></a><br>

  <a href="#gt_str_delete"><code>gt_str_delete</code></a><br>

  <a href="#gt_str_get"><code>gt_str_get</code></a><br>

  <a href="#gt_str_length"><code>gt_str_length</code></a><br>

  <a href="#gt_str_new"><code>gt_str_new</code></a><br>

  <a href="#gt_str_new_cstr"><code>gt_str_new_cstr</code></a><br>

  <a href="#gt_str_ref"><code>gt_str_ref</code></a><br>

  <a href="#gt_str_reset"><code>gt_str_reset</code></a><br>

  <a href="#gt_str_set"><code>gt_str_set</code></a><br>

  <a href="#gt_str_set_length"><code>gt_str_set_length</code></a><br>

  <a href="#gt_strand_get"><code>gt_strand_get</code></a><br>

  <a href="#gt_strcmp"><code>gt_strcmp</code></a><br>

  <a href="#gt_style_clone"><code>gt_style_clone</code></a><br>

  <a href="#gt_style_delete"><code>gt_style_delete</code></a><br>

  <a href="#gt_style_is_unsafe"><code>gt_style_is_unsafe</code></a><br>

  <a href="#gt_style_load_file"><code>gt_style_load_file</code></a><br>

  <a href="#gt_style_load_str"><code>gt_style_load_str</code></a><br>

  <a href="#gt_style_new"><code>gt_style_new</code></a><br>

  <a href="#gt_style_ref"><code>gt_style_ref</code></a><br>

  <a href="#gt_style_reload"><code>gt_style_reload</code></a><br>

  <a href="#gt_style_safe_mode"><code>gt_style_safe_mode</code></a><br>

  <a href="#gt_style_set_bool"><code>gt_style_set_bool</code></a><br>

  <a href="#gt_style_set_color"><code>gt_style_set_color</code></a><br>

  <a href="#gt_style_set_num"><code>gt_style_set_num</code></a><br>

  <a href="#gt_style_set_str"><code>gt_style_set_str</code></a><br>

  <a href="#gt_style_to_str"><code>gt_style_to_str</code></a><br>

  <a href="#gt_style_unsafe_mode"><code>gt_style_unsafe_mode</code></a><br>

  <a href="#gt_style_unset"><code>gt_style_unset</code></a><br>

  <a href="#gt_symbol"><code>gt_symbol</code></a><br>

  <a href="#gt_tag_value_map_add"><code>gt_tag_value_map_add</code></a><br>

  <a href="#gt_tag_value_map_delete"><code>gt_tag_value_map_delete</code></a><br>

  <a href="#gt_tag_value_map_example"><code>gt_tag_value_map_example</code></a><br>

  <a href="#gt_tag_value_map_foreach"><code>gt_tag_value_map_foreach</code></a><br>

  <a href="#gt_tag_value_map_get"><code>gt_tag_value_map_get</code></a><br>

  <a href="#gt_tag_value_map_new"><code>gt_tag_value_map_new</code></a><br>

  <a href="#gt_tag_value_map_set"><code>gt_tag_value_map_set</code></a><br>

  <a href="#gt_text_width_calculator_cairo_new"><code>gt_text_width_calculator_cairo_new</code></a><br>

  <a href="#gt_text_width_calculator_delete"><code>gt_text_width_calculator_delete</code></a><br>

  <a href="#gt_text_width_calculator_get_text_width"><code>gt_text_width_calculator_get_text_width</code></a><br>

  <a href="#gt_text_width_calculator_ref"><code>gt_text_width_calculator_ref</code></a><br>

  <a href="#gt_timer_delete"><code>gt_timer_delete</code></a><br>

  <a href="#gt_timer_new"><code>gt_timer_new</code></a><br>

  <a href="#gt_timer_new_with_progress_description"><code>gt_timer_new_with_progress_description</code></a><br>

  <a href="#gt_timer_omit_last_stage"><code>gt_timer_omit_last_stage</code></a><br>

  <a href="#gt_timer_show"><code>gt_timer_show</code></a><br>

  <a href="#gt_timer_show_cpu_time_by_progress"><code>gt_timer_show_cpu_time_by_progress</code></a><br>

  <a href="#gt_timer_show_formatted"><code>gt_timer_show_formatted</code></a><br>

  <a href="#gt_timer_show_progress"><code>gt_timer_show_progress</code></a><br>

  <a href="#gt_timer_show_progress_final"><code>gt_timer_show_progress_final</code></a><br>

  <a href="#gt_timer_start"><code>gt_timer_start</code></a><br>

  <a href="#gt_timer_stop"><code>gt_timer_stop</code></a><br>

  <a href="#gt_trans_table_delete"><code>gt_trans_table_delete</code></a><br>

  <a href="#gt_trans_table_description"><code>gt_trans_table_description</code></a><br>

  <a href="#gt_trans_table_get_scheme_descriptions"><code>gt_trans_table_get_scheme_descriptions</code></a><br>

  <a href="#gt_trans_table_new"><code>gt_trans_table_new</code></a><br>

  <a href="#gt_trans_table_new_standard"><code>gt_trans_table_new_standard</code></a><br>

  <a href="#gt_trans_table_translate_codon"><code>gt_trans_table_translate_codon</code></a><br>

  <a href="#gt_translator_delete"><code>gt_translator_delete</code></a><br>

  <a href="#gt_translator_find_codon"><code>gt_translator_find_codon</code></a><br>

  <a href="#gt_translator_find_startcodon"><code>gt_translator_find_startcodon</code></a><br>

  <a href="#gt_translator_find_stopcodon"><code>gt_translator_find_stopcodon</code></a><br>

  <a href="#gt_translator_new"><code>gt_translator_new</code></a><br>

  <a href="#gt_translator_new_with_table"><code>gt_translator_new_with_table</code></a><br>

  <a href="#gt_translator_next"><code>gt_translator_next</code></a><br>

  <a href="#gt_translator_set_codon_iterator"><code>gt_translator_set_codon_iterator</code></a><br>

  <a href="#gt_translator_set_translation_table"><code>gt_translator_set_translation_table</code></a><br>

  <a href="#gt_type_checker_delete"><code>gt_type_checker_delete</code></a><br>

  <a href="#gt_type_checker_is_valid"><code>gt_type_checker_is_valid</code></a><br>

  <a href="#gt_type_checker_obo_new"><code>gt_type_checker_obo_new</code></a><br>

  <a href="#gt_type_checker_ref"><code>gt_type_checker_ref</code></a><br>

  <a href="#gt_uniq_stream_new"><code>gt_uniq_stream_new</code></a><br>

  <a href="#gt_version_check"><code>gt_version_check</code></a><br>

  <a href="#gt_visitor_stream_new"><code>gt_visitor_stream_new</code></a><br>

  <a href="#gt_warning"><code>gt_warning</code></a><br>

  <a href="#gt_warning_default_handler"><code>gt_warning_default_handler</code></a><br>

  <a href="#gt_warning_disable"><code>gt_warning_disable</code></a><br>

  <a href="#gt_warning_get_data"><code>gt_warning_get_data</code></a><br>

  <a href="#gt_warning_get_handler"><code>gt_warning_get_handler</code></a><br>

  <a href="#gt_warning_set_handler"><code>gt_warning_set_handler</code></a><br>

  <a href="#gt_xatexit"><code>gt_xatexit</code></a><br>

  <a href="#gt_xfclose"><code>gt_xfclose</code></a><br>

  <a href="#gt_xfflush"><code>gt_xfflush</code></a><br>

  <a href="#gt_xfgetc"><code>gt_xfgetc</code></a><br>

  <a href="#gt_xfgetpos"><code>gt_xfgetpos</code></a><br>

  <a href="#gt_xfgets"><code>gt_xfgets</code></a><br>

  <a href="#gt_xfopen"><code>gt_xfopen</code></a><br>

  <a href="#gt_xfputc"><code>gt_xfputc</code></a><br>

  <a href="#gt_xfputs"><code>gt_xfputs</code></a><br>

  <a href="#gt_xfread"><code>gt_xfread</code></a><br>

  <a href="#gt_xfseek"><code>gt_xfseek</code></a><br>

  <a href="#gt_xfsetpos"><code>gt_xfsetpos</code></a><br>

  <a href="#gt_xfwrite"><code>gt_xfwrite</code></a><br>

  <a href="#gt_xputchar"><code>gt_xputchar</code></a><br>

  <a href="#gt_xputs"><code>gt_xputs</code></a><br>

  <a href="#gt_xremove"><code>gt_xremove</code></a><br>

  <a href="#gt_xungetc"><code>gt_xungetc</code></a><br>

  <a href="#gt_xvfprintf"><code>gt_xvfprintf</code></a><br>

  <a href="#gt_xvsnprintf"><code>gt_xvsnprintf</code></a><br>

<div id="footer">
Copyright &copy; 2008-2011
<a href="mailto:gremme@gmail.com">Gordon Gremme.</a>
Last update: 2012-02-15
</div>
</div>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ?  "https://gremme.org/piwik/" : "http://gremme.org/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 5);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://gremme.org/piwik/piwik.php?idsite=5" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Tag -->
</body>
</html>
